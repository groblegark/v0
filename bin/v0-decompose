#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/lib/v0-common.sh"
v0_load_config

if [[ -z "$1" ]]; then
  cat <<EOF
Usage: v0 decompose <plan-file>

Convert a plan file into issues using wk.

Example:
  v0 decompose plans/rust.md
EOF
  exit 1
fi

PLAN_FILE="$1"
BASENAME="$(basename "${PLAN_FILE}" .md)"

if [[ ! -f "${PLAN_FILE}" ]]; then
  echo "Error: Plan file not found: ${PLAN_FILE}"
  exit 1
fi

# Check if plan file is committed (skip check if not in a git repo or if gitignored)
if git -C "${V0_ROOT}" rev-parse --is-inside-work-tree &>/dev/null; then
  if ! git -C "${V0_ROOT}" check-ignore -q "${PLAN_FILE}" 2>/dev/null; then
    # Not gitignored - verify it's committed
    if ! git -C "${V0_ROOT}" ls-files --error-unmatch "${PLAN_FILE}" &>/dev/null; then
      echo "Error: Plan file is not committed: ${PLAN_FILE}"
      echo "Commit the plan first: git add ${PLAN_FILE} && git commit -m 'Add plan: ${BASENAME}'"
      echo "Or add '${V0_PLANS_DIR}/' to .gitignore if plans should not be tracked."
      exit 1
    fi
    if ! git -C "${V0_ROOT}" diff --quiet -- "${PLAN_FILE}" 2>/dev/null; then
      echo "Error: Plan file has uncommitted changes: ${PLAN_FILE}"
      echo "Commit the changes first: git add ${PLAN_FILE} && git commit -m 'Update plan: ${BASENAME}'"
      exit 1
    fi
  fi
fi

# Create state directory and operation tracking
STATE_DIR="${BUILD_DIR}/operations/${BASENAME}"
STATE_FILE="${STATE_DIR}/state.json"
mkdir -p "${STATE_DIR}/logs"

# Check if operation is held
if [[ -f "${STATE_FILE}" ]]; then
  v0_exit_if_held "${BASENAME}" "decompose"
fi

# Create or update operation state if it doesn't exist
if [[ ! -f "${STATE_FILE}" ]]; then
  machine=$(hostname -s)
  cat > "${STATE_FILE}" <<EOF
{
  "name": "${BASENAME}",
  "type": "decompose",
  "machine": "${machine}",
  "prompt": null,
  "phase": "planned",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "plan_file": "${V0_PLANS_DIR}/${BASENAME}.md",
  "tmux_session": null,
  "epic_id": null
}
EOF
fi

# Build full prompt with context
PROMPT="$(cat "${V0_DIR}/lib/prompts/feature.md")

---

$(cat "${PLAN_FILE}")

---

The plan basename is: ${BASENAME}. Label all issues with plan:${BASENAME}"

# Default: skip permissions; V0_SAFE=1: require permission prompts
# (respects .claude/settings.json allow list when in safe mode)
if [[ "${V0_SAFE:-}" = "1" ]]; then
  claude --model opus "${PROMPT}"
  DECOMPOSE_EXIT=$?
else
  claude --model opus --dangerously-skip-permissions "${PROMPT}"
  DECOMPOSE_EXIT=$?
fi

# Check for epic_id in plan file after decompose
ISSUE_PATTERN=$(v0_issue_pattern)
EPIC_ID=$(grep -oE "\`${ISSUE_PATTERN}\`" "${PLAN_FILE}" | head -1 | tr -d '`' || true)

# Update state based on result
if [[ ${DECOMPOSE_EXIT} -eq 0 ]] || [[ -n "${EPIC_ID}" ]]; then
  # Update state to queued with epic_id
  tmp=$(mktemp)
  if [[ -n "${EPIC_ID}" ]]; then
    jq ".phase = \"queued\" | .epic_id = \"${EPIC_ID}\"" "${STATE_FILE}" > "${tmp}" && mv "${tmp}" "${STATE_FILE}"
  else
    jq ".phase = \"queued\"" "${STATE_FILE}" > "${tmp}" && mv "${tmp}" "${STATE_FILE}"
  fi
  exit 0
else
  exit "${DECOMPOSE_EXIT}"
fi
