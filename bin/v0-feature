#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/lib/v0-common.sh"
v0_load_config

# Source nudge functions for idle session monitoring
source "${V0_DIR}/lib/nudge-common.sh"

usage() {
  cat <<EOF
Usage: v0 feature <name> <prompt> [options]
       v0 feature <name> --resume [phase] [options]

Transform a prompt into an autonomous development pipeline.

Options:
  --enqueue      Plan and create issues but don't launch worker
  --resume [p]   Resume an existing operation, optionally from phase p
                 Valid phases: init, planned, queued
  --no-merge     Don't auto-merge when work completes (default: auto-merge)
  --label <l>    Add label to all created issues (can repeat)
  --safe         Require permission prompts in worker (default: skip prompts)
  --dry-run      Show what would happen without executing
  --after <op>       Wait for operation to merge before executing
  --eager            With --after: run planning before waiting (default: wait first)
  --plan <file>      Use existing plan (skips decompose if feature ID present)
  --foreground       Run plan/decompose/build in foreground (blocking)
  --attach           Follow worker logs after queuing

Modes:
  Default: Queue feature and run in background (exits immediately)
  --foreground: Plan -> Decompose -> Launch worker -> Auto-merge (blocking)
  --enqueue: Plan -> Decompose -> Stop (work available for wk ready)
  --resume: Check state and continue from last phase
  --no-merge: Skip automatic merge after completion
  --after: Wait for another operation to merge before executing
    Default: Block immediately, don't start any work until unblocked
    --eager: Run planning phases first, then block before execution
  --plan: Use existing plan file
    If plan has feature ID (\$ISSUE_PREFIX-xxx): Skip planning AND decompose, go to execute
    If no feature ID: Skip planning, run decompose, then execute

Examples:
  v0 feature auth "Add JWT authentication"          # Queue and run in background
  v0 feature auth "Add JWT auth" --foreground       # Run in foreground (blocking)
  v0 feature api "Build REST API" --enqueue         # Plan only, no worker
  v0 feature auth --resume                          # Resume from current phase
  v0 feature auth --resume --attach                 # Resume and follow logs
  v0 feature auth --resume init                     # Restart from planning phase
  v0 feature addx "Add X" --no-merge                # Don't auto-merge
  v0 feature api "Build API" --after auth           # Wait for auth before starting
  v0 feature api "Build API" --after auth --eager   # Plan first, then wait
  v0 feature refactor --plan plans/refactor.md      # Use existing plan
EOF
  exit 1
}

NAME=""
PROMPT=""
ENQUEUE_ONLY=""
RESUME=""
RESUME_PHASE=""
NO_MERGE=""
LABELS=()
SAFE=""
DRY_RUN=""
AFTER=""
EAGER=""
PLAN_FILE_ARG=""
FOREGROUND=""
ATTACH=""

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --enqueue) ENQUEUE_ONLY=1; shift ;;
    --resume)
      RESUME=1
      shift
      if [[ $# -gt 0 ]] && [[ "$1" =~ ^(init|planned|queued)$ ]]; then
        RESUME_PHASE="$1"
        shift
      fi
      ;;
    --no-merge) NO_MERGE=1; shift ;;
    --label) LABELS+=("$2"); shift 2 ;;
    --safe) SAFE=1; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    --after) AFTER="$2"; shift 2 ;;
    --eager) EAGER=1; shift ;;
    --plan) PLAN_FILE_ARG="$2"; shift 2 ;;
    --foreground) FOREGROUND=1; shift ;;
    --attach) ATTACH=1; shift ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *)
      if [[ -z "${NAME}" ]]; then
        NAME="$1"
      elif [[ -z "${PROMPT}" ]]; then
        PROMPT="$1"
      else
        echo "Unexpected argument: $1"; usage
      fi
      shift
      ;;
  esac
done

[[ -z "${NAME}" ]] && usage

# Handle direct markdown file path: v0 feature plans/foo.md -> v0 feature foo --plan plans/foo.md
if [[ "${NAME}" == *.md ]] && [[ -f "${NAME}" ]]; then
  PLAN_FILE_ARG="${NAME}"
  NAME=$(basename "${NAME}" .md)
fi

[[ -z "${PROMPT}" ]] && [[ -z "${RESUME}" ]] && [[ -z "${PLAN_FILE_ARG}" ]] && usage

# Validate --plan flag
if [[ -n "${PLAN_FILE_ARG}" ]]; then
  if [[ -n "${RESUME}" ]]; then
    echo "Error: --plan and --resume are mutually exclusive"
    exit 1
  fi
  if [[ ! -f "${PLAN_FILE_ARG}" ]]; then
    echo "Error: Plan file not found: ${PLAN_FILE_ARG}"
    exit 1
  fi
fi

# Validate --after and --eager flags
if [[ -n "${AFTER}" ]]; then
  if [[ -z "${RESUME}" ]]; then
    if [[ ! -f "${BUILD_DIR}/operations/${AFTER}/state.json" ]]; then
      echo "Error: Operation '${AFTER}' does not exist"
      echo "Create it first with: v0 feature ${AFTER} \"...\""
      exit 1
    fi
    check_circular_dep() {
      local checking="$1"
      local visited="$2"

      if [[ "${visited}" == *":${checking}:"* ]]; then
        return 1
      fi

      local check_state="${BUILD_DIR}/operations/${checking}/state.json"
      [[ ! -f "${check_state}" ]] && return 1

      local check_after
      check_after=$(jq -r '.after // empty' "${check_state}")
      [[ -z "${check_after}" ]] || [[ "${check_after}" = "null" ]] && return 1

      if [[ "${check_after}" = "${NAME}" ]]; then
        return 0
      fi

      check_circular_dep "${check_after}" "${visited}:${checking}:"
    }

    if check_circular_dep "${AFTER}" ":"; then
      echo "Error: Circular dependency detected"
      echo "  '${NAME}' would wait for '${AFTER}'"
      echo "  but '${AFTER}' is (transitively) waiting for '${NAME}'"
      exit 1
    fi
  fi
elif [[ -n "${EAGER}" ]]; then
  echo "Error: --eager requires --after"
  exit 1
fi

# Require dependencies
v0_check_deps tmux jq claude m4

# Validate name format
if [[ ! "${NAME}" =~ ^[a-zA-Z][a-zA-Z0-9-]*$ ]]; then
  echo "Error: Name must start with a letter and contain only alphanumeric characters and hyphens"
  exit 1
fi

# State management
STATE_DIR="${BUILD_DIR}/operations/${NAME}"
STATE_FILE="${STATE_DIR}/state.json"

init_state() {
  mkdir -p "${STATE_DIR}/logs"
  local machine
  machine=$(hostname -s)

  local labels_json
  if [[ ${#LABELS[@]} -eq 0 ]]; then
    labels_json="[]"
  else
    labels_json=$(printf '%s\n' "${LABELS[@]}" | jq -R . | jq -s .)
  fi

  local merge_queued="true"
  [[ -n "${NO_MERGE}" ]] && merge_queued="false"

  local after="null"
  local eager="false"
  local safe="false"
  local blocked_phase="null"
  if [[ -n "${AFTER}" ]]; then
    after="\"${AFTER}\""
    [[ -n "${EAGER}" ]] && eager="true"
  fi
  [[ -n "${SAFE}" ]] && safe="true"

  cat > "${STATE_FILE}" <<EOF
{
  "name": "${NAME}",
  "machine": "${machine}",
  "prompt": $(printf '%s' "${PROMPT}" | jq -Rs .),
  "phase": "init",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "labels": ${labels_json},
  "plan_file": null,
  "epic_id": null,
  "tmux_session": null,
  "worktree": null,
  "current_issue": null,
  "completed": [],
  "merge_queued": ${merge_queued},
  "merge_status": null,
  "merged_at": null,
  "merge_error": null,
  "after": ${after},
  "eager": ${eager},
  "safe": ${safe},
  "blocked_phase": ${blocked_phase},
  "worker_pid": null,
  "worker_log": null,
  "worker_started_at": null
}
EOF
}

update_state() {
  local key="$1"
  local value="$2"
  local tmp
  tmp=$(mktemp)
  jq ".${key} = ${value}" "${STATE_FILE}" > "${tmp}" && mv "${tmp}" "${STATE_FILE}"
}

get_state() {
  jq -r ".$1 // empty" "${STATE_FILE}"
}

emit_event() {
  local event="$1"
  local details="$2"
  echo "[$(date +%H:%M:%S)] ${event}: ${details}"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] ${event}: ${details}" >> "${STATE_DIR}/logs/events.log"
}

is_after_op_merged() {
  local op="$1"
  local state_file="${BUILD_DIR}/operations/${op}/state.json"
  [[ ! -f "${state_file}" ]] && return 1
  local phase
  phase=$(jq -r '.phase' "${state_file}")
  [[ "${phase}" = "merged" ]]
}

get_blocker_phase() {
  local op="$1"
  local state_file="${BUILD_DIR}/operations/${op}/state.json"
  [[ -f "${state_file}" ]] && jq -r '.phase' "${state_file}" || echo "unknown"
}

create_done_script() {
  local target_dir="$1"
  local exit_file="${2:-}"

  if [[ -n "${exit_file}" ]]; then
    cat > "${target_dir}/done" <<DONE_SCRIPT
#!/bin/bash
echo "0" > '${exit_file}'
find_claude() {
  local pid=\$1
  while [[ -n "\${pid}" ]] && [[ "\${pid}" != "1" ]]; do
    local cmd=\$(ps -o comm= -p \${pid} 2>/dev/null)
    if [[ "\${cmd}" == *"claude"* ]]; then
      echo "\${pid}"
      return
    fi
    pid=\$(ps -o ppid= -p \${pid} 2>/dev/null | tr -d ' ')
  done
}
CLAUDE_PID=\$(find_claude \$\$)
if [[ -n "\${CLAUDE_PID}" ]]; then
  kill -TERM "\${CLAUDE_PID}" 2>/dev/null || true
fi
exit 0
DONE_SCRIPT
  else
    cat > "${target_dir}/done" <<'DONE_SCRIPT'
#!/bin/bash
find_claude() {
  local pid=$1
  while [[ -n "${pid}" ]] && [[ "${pid}" != "1" ]]; do
    local cmd=$(ps -o comm= -p ${pid} 2>/dev/null)
    if [[ "${cmd}" == *"claude"* ]]; then
      echo "${pid}"
      return
    fi
    pid=$(ps -o ppid= -p ${pid} 2>/dev/null | tr -d ' ')
  done
}
CLAUDE_PID=$(find_claude $$)
if [[ -n "${CLAUDE_PID}" ]]; then
  kill -TERM "${CLAUDE_PID}" 2>/dev/null || true
fi
exit 0
DONE_SCRIPT
  fi
  chmod +x "${target_dir}/done"
}

# Resume logic
if [[ -n "${RESUME}" ]]; then
  if [[ ! -f "${STATE_FILE}" ]]; then
    echo "Error: No operation found for '${NAME}'"
    exit 1
  fi
  PHASE=$(get_state phase)
  PROMPT=$(get_state prompt)
  if [[ -n "${RESUME_PHASE}" ]]; then
    PHASE="${RESUME_PHASE}"
    update_state "phase" "\"${PHASE}\""
  fi
  LABELS=()
  while IFS= read -r label; do
    [[ -n "${label}" ]] && LABELS+=("${label}")
  done < <(jq -r '.labels[]' "${STATE_FILE}" 2>/dev/null || true)
  AFTER=$(get_state after)
  EAGER=$(get_state eager)
  [[ "${EAGER}" = "true" ]] && EAGER=1 || EAGER=""
  SAFE_CHANGED=""
  if [[ -n "${SAFE}" ]]; then
    SAFE_STATE=$(get_state safe)
    if [[ "${SAFE_STATE}" != "true" ]]; then
      SAFE_CHANGED=1
    fi
    update_state "safe" 'true'
  else
    SAFE_STATE=$(get_state safe)
    [[ "${SAFE_STATE}" = "true" ]] && SAFE=1
  fi

  # Add merge_queued field if missing (for operations created by v0 plan)
  MERGE_QUEUED_STATE=$(get_state merge_queued)
  if [[ -z "${MERGE_QUEUED_STATE}" ]] || [[ "${MERGE_QUEUED_STATE}" = "null" ]]; then
    if [[ -n "${NO_MERGE}" ]]; then
      update_state "merge_queued" 'false'
    else
      update_state "merge_queued" 'true'
    fi
    emit_event "state:upgraded" "Added missing merge_queued field"
  fi

  # Clear hold on resume
  if v0_is_held "${NAME}"; then
    echo "Clearing hold on '${NAME}'..."
    tmp=$(mktemp)
    jq '.held = false | .held_at = null' "${STATE_FILE}" > "${tmp}" && mv "${tmp}" "${STATE_FILE}"
    emit_event "hold:cleared" "Hold cleared by resume"
  fi

  echo "Resuming '${NAME}' from phase: ${PHASE}"

  # Handle --attach flag for resume mode
  if [[ -n "${ATTACH}" ]]; then
    WORKER_PID=$(get_state worker_pid)
    WORKER_LOG=$(get_state worker_log)
    if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
      echo "Worker is running (PID: ${WORKER_PID})"
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
      exit 0
    elif [[ -n "${WORKER_LOG}" ]] && [[ "${WORKER_LOG}" != "null" ]] && [[ -f "${WORKER_LOG}" ]]; then
      echo "Worker is not running. Showing recent log:"
      echo ""
      tail -50 "${WORKER_LOG}"
      exit 0
    else
      echo "No worker log found"
      exit 1
    fi
  fi

  # Check if background worker is already running
  WORKER_PID=$(get_state worker_pid)
  WORKER_LOG=$(get_state worker_log)
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
    echo "Background worker already running (PID: ${WORKER_PID})"
    echo ""
    echo "View logs:    tail -f ${WORKER_LOG}"
    echo "Check status: v0 status ${NAME}"
    echo ""
    echo "To force restart, first kill the worker:"
    echo "  kill ${WORKER_PID}"
    echo "  v0 feature ${NAME} --resume"
    exit 0
  fi

  # Clear stale worker_pid if process is dead
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]]; then
    update_state "worker_pid" "null"
  fi

  # Background execution for resume (like new operations)
  # Spawn a worker to continue from current phase unless --foreground or --dry-run
  if [[ -z "${FOREGROUND}" ]] && [[ -z "${DRY_RUN}" ]]; then
    # Don't spawn worker for phases that don't need it
    if [[ "${PHASE}" != "completed" ]] && [[ "${PHASE}" != "merged" ]] && [[ "${PHASE}" != "pending_merge" ]] && [[ "${PHASE}" != "blocked" ]] && [[ "${PHASE}" != "executing" ]]; then
      WORKER_LOG="${STATE_DIR}/logs/worker.log"
      mkdir -p "${STATE_DIR}/logs"

      nohup "${V0_DIR}/bin/v0-feature-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
      WORKER_PID=$!

      update_state "worker_pid" "${WORKER_PID}"
      update_state "worker_log" "\"${WORKER_LOG}\""

      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Resuming '${NAME}' at phase: ${PHASE} ===${C_RESET}"
      echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
      echo ""
      echo -e "Check status: ${C_BOLD}v0 status ${NAME}${C_RESET}"
      echo -e "View logs:    ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
      echo -e "Attach:       ${C_BOLD}v0 feature ${NAME} --resume --attach${C_RESET}"
      echo ""

      if [[ -n "${ATTACH}" ]]; then
        echo "Following worker log (Ctrl+C to detach)..."
        echo ""
        tail -f "${WORKER_LOG}"
      fi
      exit 0
    fi
  fi

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  TREE_DIR="${V0_STATE_DIR}/tree/${FEATURE_BRANCH}"
  if [[ -d "${TREE_DIR}" ]] && [[ -f "${V0_ROOT}/.claude/settings.json" ]]; then
    mkdir -p "${TREE_DIR}/.claude"
    if [[ ! -f "${TREE_DIR}/.claude/settings.local.json" ]]; then
      cp -f "${V0_ROOT}/.claude/settings.json" "${TREE_DIR}/.claude/settings.local.json"
    fi
  fi

  if [[ "${PHASE}" = "pending_merge" ]]; then
    MERGE_STATUS=$(get_state merge_status)
    if [[ "${MERGE_STATUS}" = "conflict" ]]; then
      echo "Retrying merge after conflict..."
      emit_event "merge:retry" "Retrying merge from pending_merge with conflict"
      "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null || true
      echo "Operation '${NAME}' re-added to merge queue"
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      echo "  v0 attach mergeq"
      exit 0
    else
      "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null || true
      echo "Operation '${NAME}' is pending merge (status: ${MERGE_STATUS})"
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      exit 0
    fi
  fi

  if [[ "${PHASE}" = "blocked" ]]; then
    if [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
      after_state_file="${BUILD_DIR}/operations/${AFTER}/state.json"
      if [[ ! -f "${after_state_file}" ]]; then
        echo "Operation '${AFTER}' no longer exists, proceeding..."
        PHASE=$(get_state blocked_phase)
        [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
        update_state "after" 'null'
        emit_event "unblock:resumed" "After op ${AFTER} deleted"
      elif is_after_op_merged "${AFTER}"; then
        echo "Operation '${AFTER}' has merged, proceeding..."
        PHASE=$(get_state blocked_phase)
        if [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]]; then
          PHASE="init"
        fi
        update_state "after" 'null'
        emit_event "unblock:resumed" "Unblocked by ${AFTER} merge"
      else
        after_phase=$(get_blocker_phase "${AFTER}")
        if [[ "${after_phase}" = "failed" ]] || [[ "${after_phase}" = "conflict" ]]; then
          echo "Warning: Operation '${AFTER}' has ${after_phase} status"
          echo "It needs to be resolved before this operation can proceed."
          echo ""
          echo "To manually unblock, clear the after field:"
          echo "  jq '.after = null | .phase = .blocked_phase' ${STATE_FILE} > tmp && mv tmp ${STATE_FILE}"
          echo "  v0 feature ${NAME} --resume"
        else
          echo "Still waiting for '${AFTER}' (phase: ${after_phase})"
        fi
        exit 0
      fi
    else
      PHASE=$(get_state blocked_phase)
      [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
    fi
  fi

  if [[ "${PHASE}" = "executing" ]]; then
    SESSION=$(get_state tmux_session)
    if [[ -z "${SESSION}" ]] || ! tmux has-session -t "${SESSION}" 2>/dev/null; then
      echo "Previous session is no longer active, restarting..."
      update_state "phase" '"queued"'
      update_state "tmux_session" 'null'
      PHASE="queued"
    elif [[ -n "${SAFE_CHANGED}" ]]; then
      echo "Restarting session to apply --safe flag..."
      tmux kill-session -t "${SESSION}" 2>/dev/null || true
      update_state "phase" '"queued"'
      update_state "tmux_session" 'null'
      PHASE="queued"
    fi
  fi

  # Handle failed/interrupted/cancelled phases - reset to last known good phase
  if [[ "${PHASE}" = "failed" ]] || [[ "${PHASE}" = "interrupted" ]] || [[ "${PHASE}" = "cancelled" ]]; then
    echo "Clearing ${PHASE} state and resuming..."
    update_state "error" "null"
    # Determine what phase to resume from based on state
    PLAN_FILE=$(get_state plan_file)
    EPIC_ID=$(get_state epic_id)
    if [[ -n "${EPIC_ID}" ]] && [[ "${EPIC_ID}" != "null" ]]; then
      PHASE="queued"
    elif [[ -n "${PLAN_FILE}" ]] && [[ "${PLAN_FILE}" != "null" ]]; then
      PHASE="planned"
    else
      PHASE="init"
    fi
    update_state "phase" "\"${PHASE}\""
    emit_event "resume:from_error" "Resuming from ${PHASE} after error/interrupt/cancel"
  fi
else
  init_state
  PHASE="init"

  # Check if operation is held (for new operations with existing state)
  if [[ -f "${STATE_FILE}" ]]; then
    v0_exit_if_held "${NAME}" "feature"
  fi

  if [[ -z "${EAGER}" ]] && [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
    if ! is_after_op_merged "${AFTER}"; then
      emit_event "blocked:waiting" "Waiting for ${AFTER} to merge"
      update_state "phase" '"blocked"'
      update_state "blocked_phase" '"init"'
      echo ""
      echo -e "${C_BOLD}${C_YELLOW}=== Waiting for '${AFTER}' ===${C_RESET}"
      echo "Will start after '${AFTER}' merges."
      echo -e "Current phase: ${C_DIM}$(get_blocker_phase "${AFTER}")${C_RESET}"
      echo ""
      echo "Resume manually with:"
      echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
      exit 0
    fi
  fi

  if [[ -n "${PLAN_FILE_ARG}" ]]; then
    mkdir -p "${PLANS_DIR}"
    DEST_PLAN="${PLANS_DIR}/${NAME}.md"
    if [[ "$(realpath "${PLAN_FILE_ARG}")" != "$(realpath "${DEST_PLAN}" 2>/dev/null)" ]]; then
      /bin/cp "${PLAN_FILE_ARG}" "${DEST_PLAN}"
    fi
    update_state "plan_file" "\"${V0_PLANS_DIR}/${NAME}.md\""

    if [[ -z "${PROMPT}" ]]; then
      PROMPT="Implement $(basename "${PLAN_FILE_ARG}" .md)"
      update_state "prompt" "$(printf '%s' "${PROMPT}" | jq -Rs .)"
    fi

    ISSUE_PATTERN=$(v0_issue_pattern)
    EXISTING_FEATURE=$(grep -oE "\`${ISSUE_PATTERN}\`" "${PLAN_FILE_ARG}" | head -1 | tr -d '`' || true)
    if [[ -n "${EXISTING_FEATURE}" ]]; then
      FEATURE_STATUS=$(wk show "${EXISTING_FEATURE}" --format json 2>/dev/null | jq -r '.status // "unknown"' || echo "unknown")
      if [[ "${FEATURE_STATUS}" = "open" ]] || [[ "${FEATURE_STATUS}" = "in_progress" ]]; then
        update_state "epic_id" "\"${EXISTING_FEATURE}\""
        update_state "phase" '"queued"'
        emit_event "plan:provided" "Using existing feature ${EXISTING_FEATURE} from ${PLAN_FILE_ARG}"
        PHASE="queued"
      else
        echo "Warning: Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, will re-decompose"
        update_state "phase" '"planned"'
        emit_event "plan:provided" "Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, needs re-decompose"
        PHASE="planned"
      fi
    else
      update_state "phase" '"planned"'
      emit_event "plan:provided" "Copied from ${PLAN_FILE_ARG} (needs decompose)"
      PHASE="planned"
    fi
  fi

  # Background execution (default for new operations)
  # The worker (v0-feature-worker) runs plan -> decompose -> build in background.
  # This allows the user to queue features and continue with other work.
  # Use --foreground to preserve the old blocking behavior.
  if [[ -z "${FOREGROUND}" ]] && [[ -z "${DRY_RUN}" ]]; then
    WORKER_LOG="${STATE_DIR}/logs/worker.log"
    mkdir -p "${STATE_DIR}/logs"

    nohup "${V0_DIR}/bin/v0-feature-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
    WORKER_PID=$!

    update_state "worker_pid" "${WORKER_PID}"
    update_state "worker_log" "\"${WORKER_LOG}\""

    echo ""
    echo -e "${C_BOLD}${C_CYAN}=== Feature '${NAME}' queued for planning ===${C_RESET}"
    echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
    echo ""
    echo -e "Check status: ${C_BOLD}v0 status ${NAME}${C_RESET}"
    echo -e "View logs:    ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
    echo -e "Attach:       ${C_BOLD}v0 feature ${NAME} --resume --attach${C_RESET}"
    echo ""

    if [[ -n "${ATTACH}" ]]; then
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
    fi
    exit 0
  fi
fi

# Phase 1: Plan
if [[ "${PHASE}" = "init" ]]; then
  mkdir -p "${STATE_DIR}/logs"

  emit_event "plan:starting" "Creating implementation plan"

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  if ! tree_output=$("${V0_DIR}/bin/v0-tree" "${FEATURE_BRANCH}"); then
    echo "Error: Failed to create worktree for ${FEATURE_BRANCH}"
    exit 1
  fi
  { read -r TREE_DIR; read -r WORKTREE; } <<< "${tree_output}"

  PLAN_SESSION=$(v0_session_name "${NAME}" "plan")

  if [[ -n "${DRY_RUN}" ]]; then
    echo "[DRY-RUN] Would run: v0 plan ${NAME} \"${PROMPT}\" in tmux session ${PLAN_SESSION}"
  else
    if tmux has-session -t "${PLAN_SESSION}" 2>/dev/null; then
      echo "Plan session '${PLAN_SESSION}' already running, waiting for completion..."
      echo "Attach with: v0 attach feature ${NAME}"
    else
      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Starting planning step ===${C_RESET}"
      echo -e "Session: ${C_DIM}${PLAN_SESSION}${C_RESET}"
      echo ""
      echo "Attach to watch planning:"
      echo -e "  ${C_BOLD}v0 attach feature ${NAME}${C_RESET}"
      echo -e "  ${C_DIM}(Ctrl-B D to detach)${C_RESET}"
      echo ""

      printf '%s' "${PROMPT}" > "${STATE_DIR}/prompt.txt"
      create_done_script "${STATE_DIR}" "${STATE_DIR}/logs/plan.exit"

      V0_SAFE_EXPORT=""
      [[ -n "${SAFE}" ]] && V0_SAFE_EXPORT="export V0_SAFE=1"

      cat > "${STATE_DIR}/run-plan.sh" <<EOF
#!/bin/bash
cd '${TREE_DIR}'
export V0_ROOT='${V0_ROOT}'
${V0_SAFE_EXPORT}
PROMPT="\$(cat '${STATE_DIR}/prompt.txt')"
script -q '${STATE_DIR}/logs/plan.log' '${V0_DIR}/bin/v0-plan' '${NAME}' "\${PROMPT}" --direct
EXIT_CODE=\$?
[[ ! -f '${STATE_DIR}/logs/plan.exit' ]] && echo \${EXIT_CODE} > '${STATE_DIR}/logs/plan.exit'
EOF
      chmod +x "${STATE_DIR}/run-plan.sh"
      tmux new-session -d -s "${PLAN_SESSION}" -c "${TREE_DIR}" "${STATE_DIR}/run-plan.sh"
    fi

    update_state "tmux_session" "\"${PLAN_SESSION}\""

    IDLE_COUNT=0
    IDLE_THRESHOLD=6
    LAST_OUTPUT=""
    while tmux has-session -t "${PLAN_SESSION}" 2>/dev/null; do
      if [[ -f "${STATE_DIR}/logs/plan.exit" ]]; then
        tmux kill-session -t "${PLAN_SESSION}" 2>/dev/null || true
        break
      fi
      sleep 2
      if [[ -f "${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md" ]] || [[ -f "${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md" ]] || [[ -f "${PLANS_DIR}/${NAME}.md" ]]; then
        CURRENT_OUTPUT=$(tmux capture-pane -t "${PLAN_SESSION}" -p 2>/dev/null | tail -5 | md5sum)
        if [[ "${CURRENT_OUTPUT}" = "${LAST_OUTPUT}" ]]; then
          IDLE_COUNT=$((IDLE_COUNT + 1))
          if [[ ${IDLE_COUNT} -ge ${IDLE_THRESHOLD} ]]; then
            emit_event "plan:idle_complete" "Plan file exists and agent idle, terminating session"
            tmux kill-session -t "${PLAN_SESSION}" 2>/dev/null || true
            echo "0" > "${STATE_DIR}/logs/plan.exit"
            break
          fi
        else
          IDLE_COUNT=0
        fi
        LAST_OUTPUT="${CURRENT_OUTPUT}"
      fi
    done

    if [[ -f "${STATE_DIR}/logs/plan.exit" ]]; then
      PLAN_EXIT=$(cat "${STATE_DIR}/logs/plan.exit")
      rm -f "${STATE_DIR}/logs/plan.exit"
    else
      PLAN_EXIT=1
    fi
    set -e

    mkdir -p "${PLANS_DIR}"
    PLAN_FOUND=""
    if [[ -f "${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md" ]]; then
      PLAN_FOUND="${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md"
    elif [[ -f "${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md" ]]; then
      PLAN_FOUND="${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md"
    elif [[ -f "${PLANS_DIR}/${NAME}.md" ]]; then
      PLAN_FOUND="${PLANS_DIR}/${NAME}.md"
    fi

    if [[ ${PLAN_EXIT} -ne 0 ]]; then
      if [[ -n "${PLAN_FOUND}" ]]; then
        emit_event "plan:recovered" "Exit code ${PLAN_EXIT} but plan file exists at ${PLAN_FOUND}"
        echo "Note: Process exited with code ${PLAN_EXIT} but plan file was created successfully"
      else
        emit_event "plan:failed" "Exit code ${PLAN_EXIT}"
        echo "Error: Plan creation failed. Check ${STATE_DIR}/logs/plan.log for details."
        rm -f "${STATE_DIR}/done"
        exit 1
      fi
    fi

    if [[ -z "${PLAN_FOUND}" ]]; then
      emit_event "plan:failed" "Plan file not created"
      echo "Error: Plan file was not created at ${V0_PLANS_DIR}/${NAME}.md"
      rm -f "${STATE_DIR}/done"
      exit 1
    fi

    if [[ "${PLAN_FOUND}" != "${PLANS_DIR}/${NAME}.md" ]]; then
      /bin/cp "${PLAN_FOUND}" "${PLANS_DIR}/${NAME}.md"
      emit_event "plan:copied" "Copied from ${PLAN_FOUND} to main repo"
    fi

    # Auto-commit the plan file (unless already committed or worktree is dirty with other changes)
    if git -C "${V0_ROOT}" diff --quiet -- "${V0_PLANS_DIR}/${NAME}.md" 2>/dev/null && \
       git -C "${V0_ROOT}" ls-files --error-unmatch "${V0_PLANS_DIR}/${NAME}.md" &>/dev/null; then
      emit_event "plan:commit" "Already committed"
    elif git -C "${V0_ROOT}" check-ignore -q "${V0_PLANS_DIR}/${NAME}.md" 2>/dev/null; then
      emit_event "plan:commit" "Skipped (gitignored)"
    elif git -C "${V0_ROOT}" add "${V0_PLANS_DIR}/${NAME}.md" && \
         git -C "${V0_ROOT}" commit -m "Add plan: ${NAME}" -m "Auto-committed by v0 feature"; then
      emit_event "plan:commit" "Committed ${V0_PLANS_DIR}/${NAME}.md"
    else
      emit_event "plan:commit" "Failed to commit (worktree may have other changes)"
    fi
  fi

  rm -f "${STATE_DIR}/done"

  update_state "plan_file" "\"${V0_PLANS_DIR}/${NAME}.md\""
  update_state "phase" '"planned"'
  emit_event "plan:created" "${V0_PLANS_DIR}/${NAME}.md"
  PHASE="planned"
fi

# Phase 2: Decompose
if [[ "${PHASE}" = "planned" ]]; then
  mkdir -p "${STATE_DIR}/logs"

  emit_event "decompose:starting" "Converting plan to issues"

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  TREE_DIR="${V0_STATE_DIR}/tree/${FEATURE_BRANCH}"
  mkdir -p "${TREE_DIR}/.claude"
  if [[ -f "${V0_ROOT}/.claude/settings.json" ]]; then
    cp -f "${V0_ROOT}/.claude/settings.json" "${TREE_DIR}/.claude/settings.local.json"
  fi

  PLAN_FILE="${PLANS_DIR}/${NAME}.md"
  if [[ ! -f "${PLAN_FILE}" ]]; then
    echo "Error: Plan file not found: ${PLAN_FILE}"
    exit 1
  fi

  FEATURE_SESSION=$(v0_session_name "${NAME}" "decompose")

  if [[ -n "${DRY_RUN}" ]]; then
    echo "[DRY-RUN] Would run: v0 decompose ${PLAN_FILE} in tmux session ${FEATURE_SESSION}"
  else
    if tmux has-session -t "${FEATURE_SESSION}" 2>/dev/null; then
      echo "Feature session '${FEATURE_SESSION}' already running, waiting for completion..."
      echo "Attach with: v0 attach feature ${NAME}"
    else
      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Starting decompose step ===${C_RESET}"
      echo -e "Session: ${C_DIM}${FEATURE_SESSION}${C_RESET}"
      echo ""
      echo "Attach to watch decompose:"
      echo -e "  ${C_BOLD}v0 attach feature ${NAME}${C_RESET}"
      echo -e "  ${C_DIM}(Ctrl-B D to detach)${C_RESET}"
      echo ""

      [[ ! -f "${TREE_DIR}/done" ]] && create_done_script "${TREE_DIR}" "${STATE_DIR}/logs/feature.exit"

      V0_SAFE_EXPORT=""
      [[ -n "${SAFE}" ]] && V0_SAFE_EXPORT="export V0_SAFE=1"

      cat > "${STATE_DIR}/run-feature.sh" <<EOF
#!/bin/bash
cd '${V0_ROOT}'
${V0_SAFE_EXPORT}
script -q '${STATE_DIR}/logs/feature.log' '${V0_DIR}/bin/v0-decompose' '${PLAN_FILE}'
EXIT_CODE=\$?
[[ ! -f '${STATE_DIR}/logs/feature.exit' ]] && echo \${EXIT_CODE} > '${STATE_DIR}/logs/feature.exit'
EOF
      chmod +x "${STATE_DIR}/run-feature.sh"
      tmux new-session -d -s "${FEATURE_SESSION}" -c "${TREE_DIR}" "${STATE_DIR}/run-feature.sh"
    fi

    update_state "tmux_session" "\"${FEATURE_SESSION}\""

    PLAN_MTIME_BEFORE=$(stat -f %m "${PLAN_FILE}" 2>/dev/null || stat -c %Y "${PLAN_FILE}" 2>/dev/null)

    IDLE_COUNT=0
    IDLE_THRESHOLD=6
    LAST_OUTPUT=""
    ISSUE_PATTERN=$(v0_issue_pattern)
    PLAN_HAS_FEATURE=""
    grep -qE "\`${ISSUE_PATTERN}\`" "${PLAN_FILE}" 2>/dev/null && PLAN_HAS_FEATURE=1
    while tmux has-session -t "${FEATURE_SESSION}" 2>/dev/null; do
      if [[ -f "${STATE_DIR}/logs/feature.exit" ]]; then
        tmux kill-session -t "${FEATURE_SESSION}" 2>/dev/null || true
        break
      fi
      sleep 2
      PLAN_MTIME_NOW=$(stat -f %m "${PLAN_FILE}" 2>/dev/null || stat -c %Y "${PLAN_FILE}" 2>/dev/null)
      if [[ "${PLAN_MTIME_NOW}" != "${PLAN_MTIME_BEFORE}" ]] || [[ -n "${PLAN_HAS_FEATURE}" ]]; then
        if grep -qE "\`${ISSUE_PATTERN}\`" "${PLAN_FILE}" 2>/dev/null; then
          CURRENT_OUTPUT=$(tmux capture-pane -t "${FEATURE_SESSION}" -p 2>/dev/null | tail -5 | md5sum)
          if [[ "${CURRENT_OUTPUT}" = "${LAST_OUTPUT}" ]]; then
            IDLE_COUNT=$((IDLE_COUNT + 1))
            if [[ ${IDLE_COUNT} -ge ${IDLE_THRESHOLD} ]]; then
              emit_event "feature:idle_complete" "Plan has feature ID and agent idle, terminating session"
              tmux kill-session -t "${FEATURE_SESSION}" 2>/dev/null || true
              echo "0" > "${STATE_DIR}/logs/feature.exit"
              break
            fi
          else
            IDLE_COUNT=0
          fi
          LAST_OUTPUT="${CURRENT_OUTPUT}"
        fi
      fi
    done

    if [[ -f "${STATE_DIR}/logs/feature.exit" ]]; then
      FEATURE_EXIT=$(cat "${STATE_DIR}/logs/feature.exit")
      rm -f "${STATE_DIR}/logs/feature.exit"
    else
      FEATURE_EXIT=1
    fi

    ISSUE_PATTERN=$(v0_issue_pattern)
    FEATURE_ID=$(grep -oE "\`${ISSUE_PATTERN}\`" "${PLAN_FILE}" | head -1 | tr -d '`' || true)
    ISSUES_CREATED=$(wk list --label "plan:${NAME}" 2>/dev/null | wc -l | tr -d ' ')

    if [[ ${FEATURE_EXIT} -ne 0 ]]; then
      if [[ -n "${FEATURE_ID}" ]] || [[ "${ISSUES_CREATED}" -gt 0 ]]; then
        emit_event "decompose:recovered" "Exit code ${FEATURE_EXIT} but work completed (feature: ${FEATURE_ID:-none}, issues: ${ISSUES_CREATED})"
        echo "Note: Process exited with code ${FEATURE_EXIT} but issue creation appears successful"
      else
        emit_event "decompose:failed" "Exit code ${FEATURE_EXIT}"
        echo "Error: Decomposition failed. Check ${STATE_DIR}/logs/feature.log for details."
        rm -f "${STATE_DIR}/done"
        exit 1
      fi
    fi

    if [[ -n "${FEATURE_ID}" ]]; then
      update_state "epic_id" "\"${FEATURE_ID}\""
    else
      emit_event "decompose:warning" "No feature ID found in plan file"
      echo "Warning: Could not extract feature ID from plan file"
    fi

    if [[ ${#LABELS[@]} -gt 0 ]]; then
      for issue_id in $(wk list --label "plan:${NAME}" 2>/dev/null || true); do
        for label in "${LABELS[@]}"; do
          wk label "${issue_id}" "${label}" 2>/dev/null || true
        done
      done
    fi

    rm -f "${STATE_DIR}/done"
  fi

  update_state "phase" '"queued"'
  emit_event "work:queued" "Issues created with label plan:${NAME}"
  PHASE="queued"
fi

# Phase 3: Execute (unless --enqueue)
if [[ "${PHASE}" = "queued" ]] && [[ -z "${ENQUEUE_ONLY}" ]]; then
  mkdir -p "${STATE_DIR}/logs"

  if [[ -n "${EAGER}" ]] && [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
    if ! is_after_op_merged "${AFTER}"; then
      emit_event "blocked:waiting" "Waiting for ${AFTER} to merge (eager)"
      update_state "phase" '"blocked"'
      update_state "blocked_phase" '"queued"'
      echo ""
      echo -e "${C_BOLD}${C_YELLOW}=== Waiting for '${AFTER}' (eager mode) ===${C_RESET}"
      echo "Planning complete. Will execute after '${AFTER}' merges."
      echo -e "Current phase: ${C_DIM}$(get_blocker_phase "${AFTER}")${C_RESET}"
      echo -e "Feature: ${C_DIM}$(get_state epic_id)${C_RESET}"
      echo ""
      echo -e "Issues created with label ${C_DIM}plan:${NAME}${C_RESET}"
      echo ""
      echo "Resume manually with:"
      echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
      exit 0
    fi
  fi

  emit_event "execute:starting" "Launching agent in tmux"

  SESSION=$(v0_session_name "${NAME}" "feature")

  if [[ -n "${DRY_RUN}" ]]; then
    echo "[DRY-RUN] Would run: tmux new-session -d -s ${SESSION} ... claude ..."
  else
    if tmux has-session -t "${SESSION}" 2>/dev/null; then
      echo "Error: tmux session '${SESSION}' already exists"
      echo "Attach with: v0 attach feature ${NAME}"
      echo "Or kill it:  v0 shutdown"
      exit 1
    fi

    tree_output=""
    FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
    if ! tree_output=$("${V0_DIR}/bin/v0-tree" "${FEATURE_BRANCH}"); then
      echo "Error: Failed to create worktree for ${FEATURE_BRANCH}"
      exit 1
    fi
    { read -r TREE_DIR; read -r _WORKTREE; } <<< "${tree_output}"

    FEATURE_ID=$(get_state epic_id)

    M4_ARGS="-D EPIC_ID=${FEATURE_ID} -D PLAN_LABEL=plan:${NAME} -D HAS_PLAN=1"
    # shellcheck disable=SC2086
    m4 ${M4_ARGS} "${V0_DIR}/lib/templates/claude.feature.m4" > "${TREE_DIR}/CLAUDE.md"
    emit_event "claude.md:created" "${TREE_DIR}/CLAUDE.md"

    HOOK_SCRIPT="${V0_DIR}/lib/hooks/stop-feature.sh"
    cat > "${TREE_DIR}/.claude/settings.local.json" <<SETTINGS_EOF
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "${HOOK_SCRIPT}"
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wk prime"
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "wk prime"
          }
        ]
      }
    ]
  }
}
SETTINGS_EOF

    PLAN_FILE="${PLANS_DIR}/${NAME}.md"
    if [[ -f "${PLAN_FILE}" ]]; then
      /bin/cp "${PLAN_FILE}" "${TREE_DIR}/PLAN.md"
      emit_event "plan:copied" "PLAN.md"
    fi

    create_done_script "${TREE_DIR}"

    SAFE_FROM_STATE=$(get_state safe)
    [[ "${SAFE_FROM_STATE}" = "true" ]] && SAFE=1
    CLAUDE_ARGS="--model opus --dangerously-skip-permissions"
    [[ -n "${SAFE}" ]] && CLAUDE_ARGS="--model opus --permission-mode acceptEdits"

    cat > "${TREE_DIR}/.claude/on-complete.sh" <<WRAPPER
#!/bin/bash
STATE_FILE="${STATE_FILE}"
BUILD_ROOT="${V0_ROOT}"
OP_NAME="${NAME}"
V0_DIR="${V0_DIR}"
PROJECT="${PROJECT}"

COMPLETED_JSON=\$(wk list --format json --label "plan:\${OP_NAME}" --status done 2>/dev/null | jq '[.[].id]' || echo '[]')
if [[ "\${COMPLETED_JSON}" != "[]" ]]; then
  tmp=\$(mktemp)
  jq ".completed = \${COMPLETED_JSON}" "\${STATE_FILE}" > "\${tmp}" && mv "\${tmp}" "\${STATE_FILE}"
fi

tmp=\$(mktemp)
jq '.phase = "completed" | .completed_at = "'\$(date -u +%Y-%m-%dT%H:%M:%SZ)'"' "\${STATE_FILE}" > "\${tmp}" && mv "\${tmp}" "\${STATE_FILE}"

if [[ "\$(jq -r '.merge_queued // false' "\${STATE_FILE}")" = "true" ]]; then
  echo "=== Merge queued, preparing for merge ==="
  tmp=\$(mktemp)
  jq '.phase = "pending_merge"' "\${STATE_FILE}" > "\${tmp}" && mv "\${tmp}" "\${STATE_FILE}"

  if "\${V0_DIR}/bin/v0-mergeq" --enqueue "\${OP_NAME}"; then
    echo "Operation '\${OP_NAME}' added to merge queue"
  else
    echo "Warning: Failed to enqueue for merge"
    echo "Run manually: v0 startup mergeq"
  fi
fi
WRAPPER
    chmod +x "${TREE_DIR}/.claude/on-complete.sh"

    # Ensure nudge worker is running and write session marker
    ensure_nudge_running
    write_session_marker "${TREE_DIR}" "${SESSION}"

    tmux new-session -d -s "${SESSION}" -c "${TREE_DIR}" \
      "V0_OP='${NAME}' V0_PLAN_LABEL='plan:${NAME}' V0_WORKTREE='${TREE_DIR}/${REPO_NAME}' V0_ROOT='${V0_ROOT}' claude ${CLAUDE_ARGS} 'Implement the plan. See CLAUDE.md and PLAN.md for details.'; \
       '${TREE_DIR}/.claude/on-complete.sh'; \
       echo ''; echo 'Session complete. Closing in 5 seconds...'; sleep 5"

    update_state "tmux_session" "\"${SESSION}\""
    update_state "worktree" "\"${TREE_DIR}/${REPO_NAME}\""
    update_state "phase" '"executing"'
    emit_event "agent:launched" "tmux session ${SESSION}"

    echo ""
    echo -e "${C_BOLD}${C_CYAN}=== Build step started ===${C_RESET}"
    echo -e "Operation: ${C_DIM}${NAME}${C_RESET}"
    echo -e "Session:   ${C_DIM}${SESSION}${C_RESET}"
    if [[ -z "${NO_MERGE}" ]]; then
      echo -e "Merge:     ${C_GREEN}Auto-merge when complete${C_RESET}"
    else
      echo -e "Merge:     ${C_DIM}Disabled (--no-merge)${C_RESET}"
    fi
    echo ""
    echo "Watch live:"
    echo -e "  ${C_BOLD}v0 attach feature ${NAME}${C_RESET}"
    echo -e "  ${C_DIM}(Ctrl-B D to detach)${C_RESET}"
    echo ""
    echo "Check status:"
    echo -e "  ${C_BOLD}v0 status ${NAME}${C_RESET}"
    echo ""
    echo "Stop:"
    echo -e "  ${C_BOLD}v0 cancel ${NAME}${C_RESET}${C_DIM}   # stop and cancel operation${C_RESET}"
    echo -e "  ${C_BOLD}v0 hold ${NAME}${C_RESET}${C_DIM}     # pause after current work completes${C_RESET}"
  fi
elif [[ "${PHASE}" = "queued" ]]; then
  echo ""
  echo -e "${C_BOLD}${C_CYAN}=== Work queued (--enqueue mode) ===${C_RESET}"
  echo -e "Operation: ${C_DIM}${NAME}${C_RESET}"
  echo -e "Feature: ${C_DIM}$(get_state epic_id)${C_RESET}"
  echo ""
  echo "Start execution with:"
  echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
elif [[ "${PHASE}" = "executing" ]]; then
  SESSION=$(get_state tmux_session)
  echo "Operation '${NAME}' is already executing"
  echo "Attach with: v0 attach feature ${NAME}"
fi
