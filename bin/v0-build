#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

# Source nudge functions for idle session monitoring
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"

# Source worker utilities for done/incomplete scripts
source "${V0_DIR}/packages/worker/lib/worker-common.sh"

# Source build utilities (init, session monitoring, on-complete)
source "${V0_DIR}/packages/cli/lib/build/build.sh"

# Source issue filing functions
source "${V0_DIR}/packages/cli/lib/build/issue.sh"

usage() {
  v0_help <<'EOF'
Usage: v0 build <name> <prompt> [options]
       v0 build <name> --resume [phase] [options]

Transform a prompt into an autonomous development pipeline.

Options:
  --resume [p]   Resume an existing operation, optionally from phase p
                 Valid phases: init, planned, queued
  --no-merge     Don't auto-merge when work completes (default: auto-merge)
  --label <l>    Add label to created issue (can repeat)
  --dry-run      Show what would happen without executing
  --after <op>   Wait for operation to merge before executing
  --plan <file>  Use existing plan (skips planning if feature ID present)
  --attach       Follow worker logs after queuing

Modes:
  Default: Queue build and run in background (exits immediately)
  --resume: Check state and continue from last phase
  --no-merge: Skip automatic merge after completion
  --after: Wait for another operation to merge before executing
  --plan: Use existing plan file
    If plan has feature ID (\$ISSUE_PREFIX-xxx): Skip planning, go to execute
    If no feature ID: Skip planning, file issue, then execute

Examples:
  v0 build auth "Add JWT authentication"          # Queue and run in background
  v0 build api "Build REST API"                   # Queue and run in background
  v0 build auth --resume                          # Resume from current phase
  v0 build auth --resume --attach                 # Resume and follow logs
  v0 build auth --resume init                     # Restart from planning phase
  v0 build addx "Add X" --no-merge                # Don't auto-merge
  v0 build api "Build API" --after auth           # Wait for auth before starting
  v0 build refactor --plan plans/refactor.md      # Use existing plan
EOF
  exit 1
}

NAME=""
PROMPT=""
RESUME=""
RESUME_PHASE=""
NO_MERGE=""
LABELS=()
DRY_RUN=""
AFTER=""
PLAN_FILE_ARG=""
ATTACH=""
HOLD=""

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --resume)
      RESUME=1
      shift
      if [[ $# -gt 0 ]] && [[ "$1" =~ ^(init|planned|queued)$ ]]; then
        RESUME_PHASE="$1"
        shift
      fi
      ;;
    --no-merge) NO_MERGE=1; shift ;;
    --label) LABELS+=("$2"); shift 2 ;;
    --dry-run) DRY_RUN=1; shift ;;
    --after) AFTER="$2"; shift 2 ;;
    --blocked-by) AFTER="$2"; shift 2 ;;  # Undocumented alias for --after
    --plan) PLAN_FILE_ARG="$2"; shift 2 ;;
    --hold) HOLD=1; shift ;;
    --attach) ATTACH=1; shift ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *)
      if [[ -z "${NAME}" ]]; then
        NAME="$1"
      elif [[ -z "${PROMPT}" ]]; then
        PROMPT="$1"
      else
        echo "Unexpected argument: $1"; usage
      fi
      shift
      ;;
  esac
done

[[ -z "${NAME}" ]] && usage

# Handle direct markdown file path: v0 feature plans/foo.md -> v0 feature foo --plan plans/foo.md
if [[ "${NAME}" == *.md ]] && [[ -f "${NAME}" ]]; then
  PLAN_FILE_ARG="${NAME}"
  NAME=$(basename "${NAME}" .md)
fi

[[ -z "${PROMPT}" ]] && [[ -z "${RESUME}" ]] && [[ -z "${PLAN_FILE_ARG}" ]] && usage

# Validate --plan flag
if [[ -n "${PLAN_FILE_ARG}" ]]; then
  if [[ -n "${RESUME}" ]]; then
    echo "Error: --plan and --resume are mutually exclusive"
    exit 1
  fi
  if [[ ! -f "${PLAN_FILE_ARG}" ]]; then
    echo "Error: Plan file not found: ${PLAN_FILE_ARG}"
    exit 1
  fi
fi

# Validate --after and --eager flags
if [[ -n "${AFTER}" ]]; then
  if [[ -z "${RESUME}" ]]; then
    if [[ ! -f "${BUILD_DIR}/operations/${AFTER}/state.json" ]]; then
      echo "Error: Operation '${AFTER}' does not exist"
      echo "Create it first with: v0 feature ${AFTER} \"...\""
      exit 1
    fi
    check_circular_dep() {
      local checking="$1"
      local visited="$2"

      if [[ "${visited}" == *":${checking}:"* ]]; then
        return 1
      fi

      local check_state="${BUILD_DIR}/operations/${checking}/state.json"
      [[ ! -f "${check_state}" ]] && return 1

      local check_after
      check_after=$(jq -r '.after // empty' "${check_state}")
      [[ -z "${check_after}" ]] || [[ "${check_after}" = "null" ]] && return 1

      if [[ "${check_after}" = "${NAME}" ]]; then
        return 0
      fi

      check_circular_dep "${check_after}" "${visited}:${checking}:"
    }

    if check_circular_dep "${AFTER}" ":"; then
      echo "Error: Circular dependency detected"
      echo "  '${NAME}' would wait for '${AFTER}'"
      echo "  but '${AFTER}' is (transitively) waiting for '${NAME}'"
      exit 1
    fi
  fi
fi

# Require dependencies
v0_check_deps tmux jq claude m4

# Validate name format
if [[ ! "${NAME}" =~ ^[a-zA-Z][a-zA-Z0-9-]*$ ]]; then
  echo "Error: Name must start with a letter and contain only alphanumeric characters and hyphens"
  exit 1
fi

# State management
STATE_DIR="${BUILD_DIR}/operations/${NAME}"
STATE_FILE="${STATE_DIR}/state.json"

init_state() {
  mkdir -p "${STATE_DIR}/logs"
  local machine
  machine=$(hostname -s)

  local labels_json
  if [[ ${#LABELS[@]} -eq 0 ]]; then
    labels_json="[]"
  else
    labels_json=$(printf '%s\n' "${LABELS[@]}" | jq -R . | jq -s .)
  fi

  local merge_queued="true"
  [[ -n "${NO_MERGE}" ]] && merge_queued="false"

  local after="null"
  local blocked_phase="null"
  if [[ -n "${AFTER}" ]]; then
    after="\"${AFTER}\""
  fi

  cat > "${STATE_FILE}" <<EOF
{
  "name": "${NAME}",
  "machine": "${machine}",
  "prompt": $(printf '%s' "${PROMPT}" | jq -Rs .),
  "phase": "init",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "labels": ${labels_json},
  "plan_file": null,
  "epic_id": null,
  "tmux_session": null,
  "worktree": null,
  "current_issue": null,
  "completed": [],
  "merge_queued": ${merge_queued},
  "merge_status": null,
  "merged_at": null,
  "merge_error": null,
  "after": ${after},
  "blocked_phase": ${blocked_phase},
  "worker_pid": null,
  "worker_log": null,
  "worker_started_at": null
}
EOF
}

# Thin wrappers over sm_* functions (use centralized state machine)
update_state() { sm_update_state "${NAME}" "$@"; }
get_state() { sm_read_state "${NAME}" "$@"; }
emit_event() {
  echo "[$(date +%H:%M:%S)] $1: ${2:-}"
  sm_emit_event "${NAME}" "$@"
}

is_after_op_merged() {
  local op="$1"
  local phase
  phase=$(sm_get_phase "${op}")
  [[ "${phase}" = "merged" ]]
}

get_blocker_phase() {
  local op="$1"
  local phase
  phase=$(sm_get_phase "${op}")
  echo "${phase:-unknown}"
}

# Get blocker operation's issue ID for wk dep
get_blocker_issue_id() {
  local op="$1"
  local blocker_state="${BUILD_DIR}/operations/${op}/state.json"
  if [[ -f "${blocker_state}" ]]; then
    jq -r '.epic_id // empty' "${blocker_state}"
  fi
}

# Resume logic
if [[ -n "${RESUME}" ]]; then
  if [[ ! -f "${STATE_FILE}" ]]; then
    echo "Error: No operation found for '${NAME}'"
    exit 1
  fi
  PHASE=$(get_state phase)
  PROMPT=$(get_state prompt)
  if [[ -n "${RESUME_PHASE}" ]]; then
    PHASE="${RESUME_PHASE}"
    update_state "phase" "\"${PHASE}\""
  fi
  LABELS=()
  while IFS= read -r label; do
    [[ -n "${label}" ]] && LABELS+=("${label}")
  done < <(jq -r '.labels[]' "${STATE_FILE}" 2>/dev/null || true)
  AFTER=$(get_state after)

  # Add merge_queued field if missing (for operations created by v0 plan)
  MERGE_QUEUED_STATE=$(get_state merge_queued)
  if [[ -z "${MERGE_QUEUED_STATE}" ]] || [[ "${MERGE_QUEUED_STATE}" = "null" ]]; then
    if [[ -n "${NO_MERGE}" ]]; then
      update_state "merge_queued" 'false'
    else
      update_state "merge_queued" 'true'
    fi
    emit_event "state:upgraded" "Added missing merge_queued field"
  fi

  # Clear hold on resume (but remember if it was held for blocked operations)
  WAS_HELD=""
  if sm_is_held "${NAME}"; then
    WAS_HELD=1
    echo "Clearing hold on '${NAME}'..."
    sm_clear_hold "${NAME}"
  fi

  echo "Resuming '${NAME}' from phase: ${PHASE}"

  # Handle --attach flag for resume mode
  if [[ -n "${ATTACH}" ]]; then
    WORKER_PID=$(get_state worker_pid)
    WORKER_LOG=$(get_state worker_log)
    if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
      echo "Worker is running (PID: ${WORKER_PID})"
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
      exit 0
    elif [[ -n "${WORKER_LOG}" ]] && [[ "${WORKER_LOG}" != "null" ]] && [[ -f "${WORKER_LOG}" ]]; then
      echo "Worker is not running. Showing recent log:"
      echo ""
      tail -50 "${WORKER_LOG}"
      exit 0
    else
      echo "No worker log found"
      exit 1
    fi
  fi

  # Check if background worker is already running
  WORKER_PID=$(get_state worker_pid)
  WORKER_LOG=$(get_state worker_log)
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
    echo "Background worker already running (PID: ${WORKER_PID})"
    echo ""
    echo "Check:     v0 status ${NAME}"
    echo "View logs: tail -f ${WORKER_LOG}"
    echo ""
    echo "To force restart, first kill the worker:"
    echo "  kill ${WORKER_PID}"
    echo "  v0 feature ${NAME} --resume"
    exit 0
  fi

  # Clear stale worker_pid if process is dead
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]]; then
    update_state "worker_pid" "null"
  fi

  # Background execution for resume (like new operations)
  # Spawn a worker to continue from current phase unless --dry-run
  if [[ -z "${DRY_RUN}" ]]; then
    # Don't spawn worker for phases that don't need it
    if [[ "${PHASE}" != "completed" ]] && [[ "${PHASE}" != "merged" ]] && [[ "${PHASE}" != "pending_merge" ]] && [[ "${PHASE}" != "blocked" ]] && [[ "${PHASE}" != "executing" ]]; then
      WORKER_LOG="${STATE_DIR}/logs/worker.log"
      mkdir -p "${STATE_DIR}/logs"

      nohup "${V0_DIR}/bin/v0-build-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
      WORKER_PID=$!

      update_state "worker_pid" "${WORKER_PID}"
      update_state "worker_log" "\"${WORKER_LOG}\""

      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Resuming '${NAME}' at phase: ${PHASE} ===${C_RESET}"
      echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
      echo ""
      echo -e "Check:     ${C_BOLD}v0 status ${NAME}${C_RESET}"
      echo -e "Attach:    ${C_BOLD}v0 attach ${NAME}${C_RESET}"
      echo -e "View logs: ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
      echo ""

      if [[ -n "${ATTACH}" ]]; then
        echo "Following worker log (Ctrl+C to detach)..."
        echo ""
        tail -f "${WORKER_LOG}"
      fi
      exit 0
    fi
  fi

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  TREE_DIR="${V0_STATE_DIR}/tree/${FEATURE_BRANCH}"
  if [[ -d "${TREE_DIR}" ]] && [[ -f "${V0_ROOT}/.claude/settings.json" ]]; then
    mkdir -p "${TREE_DIR}/.claude"
    if [[ ! -f "${TREE_DIR}/.claude/settings.local.json" ]]; then
      cp -f "${V0_ROOT}/.claude/settings.json" "${TREE_DIR}/.claude/settings.local.json"
    fi
  fi

  if [[ "${PHASE}" = "pending_merge" ]]; then
    MERGE_STATUS=$(get_state merge_status)
    if [[ "${MERGE_STATUS}" = "conflict" ]]; then
      echo "Retrying merge after conflict..."
      emit_event "merge:retry" "Retrying merge from pending_merge with conflict"
      if "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null; then
        echo "Operation '${NAME}' re-added to merge queue"
      else
        echo "Warning: Failed to enqueue for merge"
        echo "Run manually: v0 startup mergeq"
      fi
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      echo "  v0 attach mergeq"
      exit 0
    else
      if "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null; then
        echo "Operation '${NAME}' is pending merge (status: ${MERGE_STATUS})"
      else
        echo "Warning: Failed to enqueue for merge"
        echo "Run manually: v0 startup mergeq"
      fi
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      exit 0
    fi
  fi

  if [[ "${PHASE}" = "blocked" ]]; then
    if [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
      after_state_file="${BUILD_DIR}/operations/${AFTER}/state.json"
      if [[ ! -f "${after_state_file}" ]]; then
        echo "Operation '${AFTER}' no longer exists, proceeding..."
        PHASE=$(get_state blocked_phase)
        [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
        update_state "after" 'null'
        emit_event "unblock:resumed" "After op ${AFTER} deleted"

        # If this resume was just clearing a hold, don't start the operation
        if [[ -n "${WAS_HELD}" ]]; then
          update_state "phase" "\"${PHASE}\""
          echo ""
          echo "Hold cleared. Operation unblocked and ready at phase: ${PHASE}"
          echo ""
          echo "Start with:"
          echo "  v0 feature ${NAME} --resume"
          exit 0
        fi
      elif is_after_op_merged "${AFTER}"; then
        echo "Operation '${AFTER}' has merged, proceeding..."
        PHASE=$(get_state blocked_phase)
        if [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]]; then
          PHASE="init"
        fi
        update_state "after" 'null'
        emit_event "unblock:resumed" "Unblocked by ${AFTER} merge"

        # If this resume was just clearing a hold, don't start the operation
        # Let the user run resume again to actually start it
        if [[ -n "${WAS_HELD}" ]]; then
          update_state "phase" "\"${PHASE}\""
          echo ""
          echo "Hold cleared. Operation unblocked and ready at phase: ${PHASE}"
          echo ""
          echo "Start with:"
          echo "  v0 feature ${NAME} --resume"
          exit 0
        fi
      else
        after_phase=$(get_blocker_phase "${AFTER}")
        if [[ "${after_phase}" = "failed" ]] || [[ "${after_phase}" = "conflict" ]]; then
          echo "Warning: Operation '${AFTER}' has ${after_phase} status"
          echo "It needs to be resolved before this operation can proceed."
          echo ""
          echo "To manually unblock, clear the after field:"
          echo "  jq '.after = null | .phase = .blocked_phase' ${STATE_FILE} > tmp && mv tmp ${STATE_FILE}"
          echo "  v0 feature ${NAME} --resume"
        else
          echo "Still waiting for '${AFTER}' (phase: ${after_phase})"
        fi
        exit 0
      fi
    else
      PHASE=$(get_state blocked_phase)
      [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
    fi
  fi

  if [[ "${PHASE}" = "executing" ]]; then
    SESSION=$(get_state tmux_session)
    if [[ -z "${SESSION}" ]] || ! tmux has-session -t "${SESSION}" 2>/dev/null; then
      echo "Previous session is no longer active, restarting..."
      update_state "phase" '"queued"'
      update_state "tmux_session" 'null'
      PHASE="queued"
    fi
  fi

  # Handle failed/interrupted/cancelled phases - reset to last known good phase
  if [[ "${PHASE}" = "failed" ]] || [[ "${PHASE}" = "interrupted" ]] || [[ "${PHASE}" = "cancelled" ]]; then
    echo "Clearing ${PHASE} state and resuming..."
    # Use state machine functions for resume phase determination
    PHASE=$(sm_get_resume_phase "${NAME}")
    sm_clear_error_state "${NAME}"
    echo "Resuming from ${PHASE}"
  fi
else
  init_state
  PHASE="init"

  # Set hold if requested
  if [[ -n "${HOLD}" ]]; then
    sm_set_hold "${NAME}"
  fi

  # Check if operation is held (for new operations with existing state)
  if [[ -f "${STATE_FILE}" ]]; then
    sm_exit_if_held "${NAME}" "feature"
  fi

  if [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
    if ! is_after_op_merged "${AFTER}"; then
      # Use state machine transition to blocked phase
      sm_transition_to_blocked "${NAME}" "${AFTER}" "init"
      echo ""
      echo -e "${C_BOLD}${C_YELLOW}=== Waiting for '${AFTER}' ===${C_RESET}"
      echo "Will start after '${AFTER}' merges."
      echo -e "Current phase: ${C_DIM}$(get_blocker_phase "${AFTER}")${C_RESET}"
      echo ""
      echo "Resume manually with:"
      echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
      exit 0
    fi
  fi

  if [[ -n "${PLAN_FILE_ARG}" ]]; then
    mkdir -p "${PLANS_DIR}"
    DEST_PLAN="${PLANS_DIR}/${NAME}.md"
    if [[ "$(realpath "${PLAN_FILE_ARG}")" != "$(realpath "${DEST_PLAN}" 2>/dev/null)" ]]; then
      /bin/cp "${PLAN_FILE_ARG}" "${DEST_PLAN}"
    fi
    update_state "plan_file" "\"${V0_PLANS_DIR}/${NAME}.md\""

    if [[ -z "${PROMPT}" ]]; then
      PROMPT="Implement $(basename "${PLAN_FILE_ARG}" .md)"
      update_state "prompt" "$(printf '%s' "${PROMPT}" | jq -Rs .)"
    fi

    ISSUE_PATTERN=$(v0_issue_pattern)
    EXISTING_FEATURE=$(v0_grep_extract "\`${ISSUE_PATTERN}\`" "${PLAN_FILE_ARG}" | head -1 | tr -d '`' || true)
    if [[ -n "${EXISTING_FEATURE}" ]]; then
      FEATURE_STATUS=$(wk show "${EXISTING_FEATURE}" --output json 2>/dev/null | jq -r '.status // "unknown"' || echo "unknown")
      if [[ "${FEATURE_STATUS}" = "open" ]] || [[ "${FEATURE_STATUS}" = "in_progress" ]]; then
        update_state "epic_id" "\"${EXISTING_FEATURE}\""
        update_state "phase" '"queued"'
        emit_event "plan:provided" "Using existing feature ${EXISTING_FEATURE} from ${PLAN_FILE_ARG}"
        PHASE="queued"
        # Add blocked-by dependency in wk if --after was specified
        if [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
          BLOCKER_ISSUE_ID=$(get_blocker_issue_id "${AFTER}")
          if [[ -n "${BLOCKER_ISSUE_ID}" ]] && [[ "${BLOCKER_ISSUE_ID}" != "null" ]]; then
            if wk dep "${EXISTING_FEATURE}" blocked-by "${BLOCKER_ISSUE_ID}" 2>/dev/null; then
              emit_event "dep:added" "Added blocked-by: ${BLOCKER_ISSUE_ID}"
            else
              emit_event "dep:failed" "Failed to add blocked-by: ${BLOCKER_ISSUE_ID}"
            fi
          fi
        fi
      else
        echo "Warning: Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, will file new issue"
        update_state "phase" '"planned"'
        emit_event "plan:provided" "Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, needs new issue"
        PHASE="planned"
      fi
    else
      update_state "phase" '"planned"'
      emit_event "plan:provided" "Copied from ${PLAN_FILE_ARG}"
      PHASE="planned"
    fi
  fi

  # Create feature issue immediately (before planning)
  # This allows showing the issue ID to the user right away
  FEATURE_ID=$(get_state epic_id)
  if [[ -z "${FEATURE_ID}" ]] || [[ "${FEATURE_ID}" = "null" ]]; then
    FEATURE_ID=$(create_feature_issue "${NAME}")
    if [[ -n "${FEATURE_ID}" ]]; then
      update_state "epic_id" "\"${FEATURE_ID}\""
      emit_event "issue:created" "Created feature ${FEATURE_ID}"
    else
      emit_event "issue:warning" "Failed to create feature issue"
    fi
  fi

  # Background execution (default for new operations)
  # The worker (v0-build-worker) runs plan -> build in background.
  # This allows the user to queue features and continue with other work.
  if [[ -z "${DRY_RUN}" ]]; then
    WORKER_LOG="${STATE_DIR}/logs/worker.log"
    mkdir -p "${STATE_DIR}/logs"

    nohup "${V0_DIR}/bin/v0-build-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
    WORKER_PID=$!

    update_state "worker_pid" "${WORKER_PID}"
    update_state "worker_log" "\"${WORKER_LOG}\""

    echo ""
    if [[ -n "${FEATURE_ID}" ]]; then
      echo -e "${C_GREEN}Created feature:${C_RESET} ${C_CYAN}${FEATURE_ID}${C_RESET}"
      echo ""
    fi
    echo -e "${C_BOLD}${C_CYAN}=== Feature '${NAME}' queued for planning ===${C_RESET}"
    echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
    echo ""
    echo -e "Check:     ${C_BOLD}v0 status ${NAME}${C_RESET}"
    echo -e "Attach:    ${C_BOLD}v0 attach ${NAME}${C_RESET}"
    echo -e "View logs: ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
    echo ""

    if [[ -n "${ATTACH}" ]]; then
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
    fi
    exit 0
  fi
fi

# Phase 1: Plan (dry-run only - actual execution happens in background worker)
if [[ "${PHASE}" = "init" ]] && [[ -n "${DRY_RUN}" ]]; then
  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  PLAN_SESSION=$(v0_session_name "${NAME}" "plan")
  echo "[DRY-RUN] Would run: v0 plan ${NAME} \"${PROMPT}\" in tmux session ${PLAN_SESSION}"
  PHASE="queued"
fi

# Phase 2: Execute (dry-run only - actual execution happens in background worker)
if [[ "${PHASE}" = "queued" ]] && [[ -n "${DRY_RUN}" ]]; then
  SESSION=$(v0_session_name "${NAME}" "feature")
  echo "[DRY-RUN] Would run: tmux new-session -d -s ${SESSION} ... claude ..."
elif [[ "${PHASE}" = "executing" ]]; then
  SESSION=$(get_state tmux_session)
  echo "Operation '${NAME}' is already executing"
  echo "Attach with: v0 attach ${NAME}"
fi
