#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

# Source nudge functions for idle session monitoring
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"

# Source worker utilities for done/incomplete scripts
source "${V0_DIR}/packages/worker/lib/worker-common.sh"

# Source build utilities (init, session monitoring, on-complete)
source "${V0_DIR}/packages/cli/lib/build/build.sh"

usage() {
  v0_help <<'EOF'
Usage: v0 build <name> <prompt> [options]
       v0 build <name> --resume [phase] [options]

Transform a prompt into an autonomous development pipeline.

Options:
  --enqueue      Plan and create issue but don't launch worker
  --resume [p]   Resume an existing operation, optionally from phase p
                 Valid phases: init, planned, queued
  --no-merge     Don't auto-merge when work completes (default: auto-merge)
  --label <l>    Add label to created issue (can repeat)
  --safe         Require permission prompts in worker (default: skip prompts)
  --dry-run      Show what would happen without executing
  --after <op>       Wait for operation to merge before executing
  --eager            With --after: run planning before waiting (default: wait first)
  --plan <file>      Use existing plan (skips planning if feature ID present)
  --foreground       Run plan/build in foreground (blocking)
  --attach           Follow worker logs after queuing

Modes:
  Default: Queue build and run in background (exits immediately)
  --foreground: Plan -> Launch worker -> Auto-merge (blocking)
  --enqueue: Plan only, don't execute (work available via resume)
  --resume: Check state and continue from last phase
  --no-merge: Skip automatic merge after completion
  --after: Wait for another operation to merge before executing
    Default: Block immediately, don't start any work until unblocked
    --eager: Run planning first, then block before execution
  --plan: Use existing plan file
    If plan has feature ID (\$ISSUE_PREFIX-xxx): Skip planning, go to execute
    If no feature ID: Skip planning, file issue, then execute

Examples:
  v0 build auth "Add JWT authentication"          # Queue and run in background
  v0 build auth "Add JWT auth" --foreground       # Run in foreground (blocking)
  v0 build api "Build REST API" --enqueue         # Plan only, no worker
  v0 build auth --resume                          # Resume from current phase
  v0 build auth --resume --attach                 # Resume and follow logs
  v0 build auth --resume init                     # Restart from planning phase
  v0 build addx "Add X" --no-merge                # Don't auto-merge
  v0 build api "Build API" --after auth           # Wait for auth before starting
  v0 build api "Build API" --after auth --eager   # Plan first, then wait
  v0 build refactor --plan plans/refactor.md      # Use existing plan
EOF
  exit 1
}

NAME=""
PROMPT=""
ENQUEUE_ONLY=""
RESUME=""
RESUME_PHASE=""
NO_MERGE=""
LABELS=()
SAFE=""
DRY_RUN=""
AFTER=""
EAGER=""
PLAN_FILE_ARG=""
FOREGROUND=""
ATTACH=""

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --enqueue) ENQUEUE_ONLY=1; shift ;;
    --resume)
      RESUME=1
      shift
      if [[ $# -gt 0 ]] && [[ "$1" =~ ^(init|planned|queued)$ ]]; then
        RESUME_PHASE="$1"
        shift
      fi
      ;;
    --no-merge) NO_MERGE=1; shift ;;
    --label) LABELS+=("$2"); shift 2 ;;
    --safe) SAFE=1; shift ;;
    --dry-run) DRY_RUN=1; shift ;;
    --after) AFTER="$2"; shift 2 ;;
    --eager) EAGER=1; shift ;;
    --plan) PLAN_FILE_ARG="$2"; shift 2 ;;
    --foreground) FOREGROUND=1; shift ;;
    --attach) ATTACH=1; shift ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *)
      if [[ -z "${NAME}" ]]; then
        NAME="$1"
      elif [[ -z "${PROMPT}" ]]; then
        PROMPT="$1"
      else
        echo "Unexpected argument: $1"; usage
      fi
      shift
      ;;
  esac
done

[[ -z "${NAME}" ]] && usage

# Handle direct markdown file path: v0 feature plans/foo.md -> v0 feature foo --plan plans/foo.md
if [[ "${NAME}" == *.md ]] && [[ -f "${NAME}" ]]; then
  PLAN_FILE_ARG="${NAME}"
  NAME=$(basename "${NAME}" .md)
fi

[[ -z "${PROMPT}" ]] && [[ -z "${RESUME}" ]] && [[ -z "${PLAN_FILE_ARG}" ]] && usage

# Validate --plan flag
if [[ -n "${PLAN_FILE_ARG}" ]]; then
  if [[ -n "${RESUME}" ]]; then
    echo "Error: --plan and --resume are mutually exclusive"
    exit 1
  fi
  if [[ ! -f "${PLAN_FILE_ARG}" ]]; then
    echo "Error: Plan file not found: ${PLAN_FILE_ARG}"
    exit 1
  fi
fi

# Validate --after and --eager flags
if [[ -n "${AFTER}" ]]; then
  if [[ -z "${RESUME}" ]]; then
    if [[ ! -f "${BUILD_DIR}/operations/${AFTER}/state.json" ]]; then
      echo "Error: Operation '${AFTER}' does not exist"
      echo "Create it first with: v0 feature ${AFTER} \"...\""
      exit 1
    fi
    check_circular_dep() {
      local checking="$1"
      local visited="$2"

      if [[ "${visited}" == *":${checking}:"* ]]; then
        return 1
      fi

      local check_state="${BUILD_DIR}/operations/${checking}/state.json"
      [[ ! -f "${check_state}" ]] && return 1

      local check_after
      check_after=$(jq -r '.after // empty' "${check_state}")
      [[ -z "${check_after}" ]] || [[ "${check_after}" = "null" ]] && return 1

      if [[ "${check_after}" = "${NAME}" ]]; then
        return 0
      fi

      check_circular_dep "${check_after}" "${visited}:${checking}:"
    }

    if check_circular_dep "${AFTER}" ":"; then
      echo "Error: Circular dependency detected"
      echo "  '${NAME}' would wait for '${AFTER}'"
      echo "  but '${AFTER}' is (transitively) waiting for '${NAME}'"
      exit 1
    fi
  fi
elif [[ -n "${EAGER}" ]]; then
  echo "Error: --eager requires --after"
  exit 1
fi

# Require dependencies
v0_check_deps tmux jq claude m4

# Validate name format
if [[ ! "${NAME}" =~ ^[a-zA-Z][a-zA-Z0-9-]*$ ]]; then
  echo "Error: Name must start with a letter and contain only alphanumeric characters and hyphens"
  exit 1
fi

# State management
STATE_DIR="${BUILD_DIR}/operations/${NAME}"
STATE_FILE="${STATE_DIR}/state.json"

init_state() {
  mkdir -p "${STATE_DIR}/logs"
  local machine
  machine=$(hostname -s)

  local labels_json
  if [[ ${#LABELS[@]} -eq 0 ]]; then
    labels_json="[]"
  else
    labels_json=$(printf '%s\n' "${LABELS[@]}" | jq -R . | jq -s .)
  fi

  local merge_queued="true"
  [[ -n "${NO_MERGE}" ]] && merge_queued="false"

  local after="null"
  local eager="false"
  local safe="false"
  local blocked_phase="null"
  if [[ -n "${AFTER}" ]]; then
    after="\"${AFTER}\""
    [[ -n "${EAGER}" ]] && eager="true"
  fi
  [[ -n "${SAFE}" ]] && safe="true"

  cat > "${STATE_FILE}" <<EOF
{
  "name": "${NAME}",
  "machine": "${machine}",
  "prompt": $(printf '%s' "${PROMPT}" | jq -Rs .),
  "phase": "init",
  "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "labels": ${labels_json},
  "plan_file": null,
  "epic_id": null,
  "tmux_session": null,
  "worktree": null,
  "current_issue": null,
  "completed": [],
  "merge_queued": ${merge_queued},
  "merge_status": null,
  "merged_at": null,
  "merge_error": null,
  "after": ${after},
  "eager": ${eager},
  "safe": ${safe},
  "blocked_phase": ${blocked_phase},
  "worker_pid": null,
  "worker_log": null,
  "worker_started_at": null
}
EOF
}

# Thin wrappers over sm_* functions (use centralized state machine)
update_state() { sm_update_state "${NAME}" "$@"; }
get_state() { sm_read_state "${NAME}" "$@"; }
emit_event() {
  echo "[$(date +%H:%M:%S)] $1: ${2:-}"
  sm_emit_event "${NAME}" "$@"
}

is_after_op_merged() {
  local op="$1"
  local phase
  phase=$(sm_get_phase "${op}")
  [[ "${phase}" = "merged" ]]
}

get_blocker_phase() {
  local op="$1"
  local phase
  phase=$(sm_get_phase "${op}")
  echo "${phase:-unknown}"
}

# Resume logic
if [[ -n "${RESUME}" ]]; then
  if [[ ! -f "${STATE_FILE}" ]]; then
    echo "Error: No operation found for '${NAME}'"
    exit 1
  fi
  PHASE=$(get_state phase)
  PROMPT=$(get_state prompt)
  if [[ -n "${RESUME_PHASE}" ]]; then
    PHASE="${RESUME_PHASE}"
    update_state "phase" "\"${PHASE}\""
  fi
  LABELS=()
  while IFS= read -r label; do
    [[ -n "${label}" ]] && LABELS+=("${label}")
  done < <(jq -r '.labels[]' "${STATE_FILE}" 2>/dev/null || true)
  AFTER=$(get_state after)
  EAGER=$(get_state eager)
  [[ "${EAGER}" = "true" ]] && EAGER=1 || EAGER=""
  SAFE_CHANGED=""
  if [[ -n "${SAFE}" ]]; then
    SAFE_STATE=$(get_state safe)
    if [[ "${SAFE_STATE}" != "true" ]]; then
      SAFE_CHANGED=1
    fi
    update_state "safe" 'true'
  else
    SAFE_STATE=$(get_state safe)
    [[ "${SAFE_STATE}" = "true" ]] && SAFE=1
  fi

  # Add merge_queued field if missing (for operations created by v0 plan)
  MERGE_QUEUED_STATE=$(get_state merge_queued)
  if [[ -z "${MERGE_QUEUED_STATE}" ]] || [[ "${MERGE_QUEUED_STATE}" = "null" ]]; then
    if [[ -n "${NO_MERGE}" ]]; then
      update_state "merge_queued" 'false'
    else
      update_state "merge_queued" 'true'
    fi
    emit_event "state:upgraded" "Added missing merge_queued field"
  fi

  # Clear hold on resume (but remember if it was held for blocked operations)
  WAS_HELD=""
  if sm_is_held "${NAME}"; then
    WAS_HELD=1
    echo "Clearing hold on '${NAME}'..."
    sm_clear_hold "${NAME}"
  fi

  echo "Resuming '${NAME}' from phase: ${PHASE}"

  # Handle --attach flag for resume mode
  if [[ -n "${ATTACH}" ]]; then
    WORKER_PID=$(get_state worker_pid)
    WORKER_LOG=$(get_state worker_log)
    if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
      echo "Worker is running (PID: ${WORKER_PID})"
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
      exit 0
    elif [[ -n "${WORKER_LOG}" ]] && [[ "${WORKER_LOG}" != "null" ]] && [[ -f "${WORKER_LOG}" ]]; then
      echo "Worker is not running. Showing recent log:"
      echo ""
      tail -50 "${WORKER_LOG}"
      exit 0
    else
      echo "No worker log found"
      exit 1
    fi
  fi

  # Check if background worker is already running
  WORKER_PID=$(get_state worker_pid)
  WORKER_LOG=$(get_state worker_log)
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]] && kill -0 "${WORKER_PID}" 2>/dev/null; then
    echo "Background worker already running (PID: ${WORKER_PID})"
    echo ""
    echo "View logs:    tail -f ${WORKER_LOG}"
    echo "Check status: v0 status ${NAME}"
    echo ""
    echo "To force restart, first kill the worker:"
    echo "  kill ${WORKER_PID}"
    echo "  v0 feature ${NAME} --resume"
    exit 0
  fi

  # Clear stale worker_pid if process is dead
  if [[ -n "${WORKER_PID}" ]] && [[ "${WORKER_PID}" != "null" ]]; then
    update_state "worker_pid" "null"
  fi

  # Background execution for resume (like new operations)
  # Spawn a worker to continue from current phase unless --foreground or --dry-run
  if [[ -z "${FOREGROUND}" ]] && [[ -z "${DRY_RUN}" ]]; then
    # Don't spawn worker for phases that don't need it
    if [[ "${PHASE}" != "completed" ]] && [[ "${PHASE}" != "merged" ]] && [[ "${PHASE}" != "pending_merge" ]] && [[ "${PHASE}" != "blocked" ]] && [[ "${PHASE}" != "executing" ]]; then
      WORKER_LOG="${STATE_DIR}/logs/worker.log"
      mkdir -p "${STATE_DIR}/logs"

      nohup "${V0_DIR}/bin/v0-build-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
      WORKER_PID=$!

      update_state "worker_pid" "${WORKER_PID}"
      update_state "worker_log" "\"${WORKER_LOG}\""

      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Resuming '${NAME}' at phase: ${PHASE} ===${C_RESET}"
      echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
      echo ""
      echo -e "Check status: ${C_BOLD}v0 status ${NAME}${C_RESET}"
      echo -e "View logs:    ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
      echo -e "Attach:       ${C_BOLD}v0 attach ${NAME}${C_RESET}"
      echo ""

      if [[ -n "${ATTACH}" ]]; then
        echo "Following worker log (Ctrl+C to detach)..."
        echo ""
        tail -f "${WORKER_LOG}"
      fi
      exit 0
    fi
  fi

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  TREE_DIR="${V0_STATE_DIR}/tree/${FEATURE_BRANCH}"
  if [[ -d "${TREE_DIR}" ]] && [[ -f "${V0_ROOT}/.claude/settings.json" ]]; then
    mkdir -p "${TREE_DIR}/.claude"
    if [[ ! -f "${TREE_DIR}/.claude/settings.local.json" ]]; then
      cp -f "${V0_ROOT}/.claude/settings.json" "${TREE_DIR}/.claude/settings.local.json"
    fi
  fi

  if [[ "${PHASE}" = "pending_merge" ]]; then
    MERGE_STATUS=$(get_state merge_status)
    if [[ "${MERGE_STATUS}" = "conflict" ]]; then
      echo "Retrying merge after conflict..."
      emit_event "merge:retry" "Retrying merge from pending_merge with conflict"
      if "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null; then
        echo "Operation '${NAME}' re-added to merge queue"
      else
        echo "Warning: Failed to enqueue for merge"
        echo "Run manually: v0 startup mergeq"
      fi
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      echo "  v0 attach mergeq"
      exit 0
    else
      if "${V0_DIR}/bin/v0-mergeq" --enqueue "${NAME}" 2>/dev/null; then
        echo "Operation '${NAME}' is pending merge (status: ${MERGE_STATUS})"
      else
        echo "Warning: Failed to enqueue for merge"
        echo "Run manually: v0 startup mergeq"
      fi
      echo ""
      echo "Monitor merge queue:"
      echo "  v0 mergeq --status"
      exit 0
    fi
  fi

  if [[ "${PHASE}" = "blocked" ]]; then
    if [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
      after_state_file="${BUILD_DIR}/operations/${AFTER}/state.json"
      if [[ ! -f "${after_state_file}" ]]; then
        echo "Operation '${AFTER}' no longer exists, proceeding..."
        PHASE=$(get_state blocked_phase)
        [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
        update_state "after" 'null'
        emit_event "unblock:resumed" "After op ${AFTER} deleted"

        # If this resume was just clearing a hold, don't start the operation
        if [[ -n "${WAS_HELD}" ]]; then
          update_state "phase" "\"${PHASE}\""
          echo ""
          echo "Hold cleared. Operation unblocked and ready at phase: ${PHASE}"
          echo ""
          echo "Start with:"
          echo "  v0 feature ${NAME} --resume"
          exit 0
        fi
      elif is_after_op_merged "${AFTER}"; then
        echo "Operation '${AFTER}' has merged, proceeding..."
        PHASE=$(get_state blocked_phase)
        if [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]]; then
          PHASE="init"
        fi
        update_state "after" 'null'
        emit_event "unblock:resumed" "Unblocked by ${AFTER} merge"

        # If this resume was just clearing a hold, don't start the operation
        # Let the user run resume again to actually start it
        if [[ -n "${WAS_HELD}" ]]; then
          update_state "phase" "\"${PHASE}\""
          echo ""
          echo "Hold cleared. Operation unblocked and ready at phase: ${PHASE}"
          echo ""
          echo "Start with:"
          echo "  v0 feature ${NAME} --resume"
          exit 0
        fi
      else
        after_phase=$(get_blocker_phase "${AFTER}")
        if [[ "${after_phase}" = "failed" ]] || [[ "${after_phase}" = "conflict" ]]; then
          echo "Warning: Operation '${AFTER}' has ${after_phase} status"
          echo "It needs to be resolved before this operation can proceed."
          echo ""
          echo "To manually unblock, clear the after field:"
          echo "  jq '.after = null | .phase = .blocked_phase' ${STATE_FILE} > tmp && mv tmp ${STATE_FILE}"
          echo "  v0 feature ${NAME} --resume"
        else
          echo "Still waiting for '${AFTER}' (phase: ${after_phase})"
        fi
        exit 0
      fi
    else
      PHASE=$(get_state blocked_phase)
      [[ -z "${PHASE}" ]] || [[ "${PHASE}" = "null" ]] && PHASE="init"
    fi
  fi

  if [[ "${PHASE}" = "executing" ]]; then
    SESSION=$(get_state tmux_session)
    if [[ -z "${SESSION}" ]] || ! tmux has-session -t "${SESSION}" 2>/dev/null; then
      echo "Previous session is no longer active, restarting..."
      update_state "phase" '"queued"'
      update_state "tmux_session" 'null'
      PHASE="queued"
    elif [[ -n "${SAFE_CHANGED}" ]]; then
      echo "Restarting session to apply --safe flag..."
      tmux kill-session -t "${SESSION}" 2>/dev/null || true
      update_state "phase" '"queued"'
      update_state "tmux_session" 'null'
      PHASE="queued"
    fi
  fi

  # Handle failed/interrupted/cancelled phases - reset to last known good phase
  if [[ "${PHASE}" = "failed" ]] || [[ "${PHASE}" = "interrupted" ]] || [[ "${PHASE}" = "cancelled" ]]; then
    echo "Clearing ${PHASE} state and resuming..."
    # Use state machine functions for resume phase determination
    PHASE=$(sm_get_resume_phase "${NAME}")
    sm_clear_error_state "${NAME}"
    echo "Resuming from ${PHASE}"
  fi
else
  init_state
  PHASE="init"

  # Check if operation is held (for new operations with existing state)
  if [[ -f "${STATE_FILE}" ]]; then
    sm_exit_if_held "${NAME}" "feature"
  fi

  if [[ -z "${EAGER}" ]] && [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
    if ! is_after_op_merged "${AFTER}"; then
      # Use state machine transition to blocked phase
      sm_transition_to_blocked "${NAME}" "${AFTER}" "init"
      echo ""
      echo -e "${C_BOLD}${C_YELLOW}=== Waiting for '${AFTER}' ===${C_RESET}"
      echo "Will start after '${AFTER}' merges."
      echo -e "Current phase: ${C_DIM}$(get_blocker_phase "${AFTER}")${C_RESET}"
      echo ""
      echo "Resume manually with:"
      echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
      exit 0
    fi
  fi

  if [[ -n "${PLAN_FILE_ARG}" ]]; then
    mkdir -p "${PLANS_DIR}"
    DEST_PLAN="${PLANS_DIR}/${NAME}.md"
    if [[ "$(realpath "${PLAN_FILE_ARG}")" != "$(realpath "${DEST_PLAN}" 2>/dev/null)" ]]; then
      /bin/cp "${PLAN_FILE_ARG}" "${DEST_PLAN}"
    fi
    update_state "plan_file" "\"${V0_PLANS_DIR}/${NAME}.md\""

    if [[ -z "${PROMPT}" ]]; then
      PROMPT="Implement $(basename "${PLAN_FILE_ARG}" .md)"
      update_state "prompt" "$(printf '%s' "${PROMPT}" | jq -Rs .)"
    fi

    ISSUE_PATTERN=$(v0_issue_pattern)
    EXISTING_FEATURE=$(v0_grep_extract "\`${ISSUE_PATTERN}\`" "${PLAN_FILE_ARG}" | head -1 | tr -d '`' || true)
    if [[ -n "${EXISTING_FEATURE}" ]]; then
      FEATURE_STATUS=$(wk show "${EXISTING_FEATURE}" --output json 2>/dev/null | jq -r '.status // "unknown"' || echo "unknown")
      if [[ "${FEATURE_STATUS}" = "open" ]] || [[ "${FEATURE_STATUS}" = "in_progress" ]]; then
        update_state "epic_id" "\"${EXISTING_FEATURE}\""
        update_state "phase" '"queued"'
        emit_event "plan:provided" "Using existing feature ${EXISTING_FEATURE} from ${PLAN_FILE_ARG}"
        PHASE="queued"
      else
        echo "Warning: Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, will file new issue"
        update_state "phase" '"planned"'
        emit_event "plan:provided" "Feature ${EXISTING_FEATURE} is ${FEATURE_STATUS}, needs new issue"
        PHASE="planned"
      fi
    else
      update_state "phase" '"planned"'
      emit_event "plan:provided" "Copied from ${PLAN_FILE_ARG}"
      PHASE="planned"
    fi
  fi

  # Background execution (default for new operations)
  # The worker (v0-build-worker) runs plan -> build in background.
  # This allows the user to queue features and continue with other work.
  # Use --foreground to preserve the old blocking behavior.
  if [[ -z "${FOREGROUND}" ]] && [[ -z "${DRY_RUN}" ]]; then
    WORKER_LOG="${STATE_DIR}/logs/worker.log"
    mkdir -p "${STATE_DIR}/logs"

    nohup "${V0_DIR}/bin/v0-build-worker" "${NAME}" > "${WORKER_LOG}" 2>&1 &
    WORKER_PID=$!

    update_state "worker_pid" "${WORKER_PID}"
    update_state "worker_log" "\"${WORKER_LOG}\""

    echo ""
    echo -e "${C_BOLD}${C_CYAN}=== Feature '${NAME}' queued for planning ===${C_RESET}"
    echo -e "Worker PID: ${C_DIM}${WORKER_PID}${C_RESET}"
    echo ""
    echo -e "Check status: ${C_BOLD}v0 status ${NAME}${C_RESET}"
    echo -e "View logs:    ${C_BOLD}tail -f ${WORKER_LOG}${C_RESET}"
    echo -e "Attach:       ${C_BOLD}v0 attach ${NAME}${C_RESET}"
    echo ""

    if [[ -n "${ATTACH}" ]]; then
      echo "Following worker log (Ctrl+C to detach)..."
      echo ""
      tail -f "${WORKER_LOG}"
    fi
    exit 0
  fi
fi

# Phase 1: Plan
if [[ "${PHASE}" = "init" ]]; then
  mkdir -p "${STATE_DIR}/logs"

  emit_event "plan:starting" "Creating implementation plan"

  FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
  if ! tree_output=$("${V0_DIR}/bin/v0-tree" "${FEATURE_BRANCH}"); then
    echo "Error: Failed to create worktree for ${FEATURE_BRANCH}"
    exit 1
  fi
  { read -r TREE_DIR; read -r WORKTREE; } <<< "${tree_output}"

  # Link worktree to main repo's shared workspace
  wk init --workspace "${V0_ROOT}/.wok" --path "${TREE_DIR}" 2>/dev/null || true

  PLAN_SESSION=$(v0_session_name "${NAME}" "plan")

  if [[ -n "${DRY_RUN}" ]]; then
    echo "[DRY-RUN] Would run: v0 plan ${NAME} \"${PROMPT}\" in tmux session ${PLAN_SESSION}"
  else
    if tmux has-session -t "${PLAN_SESSION}" 2>/dev/null; then
      echo "Plan session '${PLAN_SESSION}' already running, waiting for completion..."
      echo "Attach with: v0 attach ${NAME}"
    else
      echo ""
      echo -e "${C_BOLD}${C_CYAN}=== Starting planning step ===${C_RESET}"
      echo -e "Session: ${C_DIM}${PLAN_SESSION}${C_RESET}"
      echo ""
      echo "Attach to watch planning:"
      echo -e "  ${C_BOLD}v0 attach ${NAME}${C_RESET}"
      echo -e "  ${C_DIM}(Ctrl-B D to detach)${C_RESET}"
      echo ""

      printf '%s' "${PROMPT}" > "${STATE_DIR}/prompt.txt"
      create_feature_done_script "${STATE_DIR}" "${STATE_DIR}/logs/plan.exit"

      V0_SAFE_EXPORT=""
      [[ -n "${SAFE}" ]] && V0_SAFE_EXPORT="export V0_SAFE=1"

      cat > "${STATE_DIR}/run-plan.sh" <<EOF
#!/bin/bash
cd '${TREE_DIR}'
export V0_ROOT='${V0_ROOT}'
${V0_SAFE_EXPORT}
PROMPT="\$(cat '${STATE_DIR}/prompt.txt')"
script -q '${STATE_DIR}/logs/plan.log' '${V0_DIR}/bin/v0-plan' '${NAME}' "\${PROMPT}" --direct
EXIT_CODE=\$?
[[ ! -f '${STATE_DIR}/logs/plan.exit' ]] && echo \${EXIT_CODE} > '${STATE_DIR}/logs/plan.exit'
EOF
      chmod +x "${STATE_DIR}/run-plan.sh"
      tmux new-session -d -s "${PLAN_SESSION}" -c "${TREE_DIR}" "${STATE_DIR}/run-plan.sh"
    fi

    update_state "tmux_session" "\"${PLAN_SESSION}\""
    update_state "working_dir" "\"${V0_ROOT}\""

    # Monitor session until plan file created and agent idle
    PLAN_LOCATIONS="${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md:${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md:${PLANS_DIR}/${NAME}.md"
    monitor_plan_session "${PLAN_SESSION}" "${STATE_DIR}/logs/plan.exit" "${PLAN_LOCATIONS}" "plan:idle_complete"
    PLAN_FOUND="${FOUND_FILE}"

    # Clean ANSI escape sequences from plan.log
    v0_clean_log_file "${STATE_DIR}/logs/plan.log"

    PLAN_EXIT=$(get_session_exit_code "${STATE_DIR}/logs/plan.exit")
    set -e

    # Check all locations if FOUND_FILE wasn't set
    mkdir -p "${PLANS_DIR}"
    if [[ -z "${PLAN_FOUND}" ]]; then
      if [[ -f "${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md" ]]; then
        PLAN_FOUND="${TREE_DIR}/${V0_PLANS_DIR}/${NAME}.md"
      elif [[ -f "${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md" ]]; then
        PLAN_FOUND="${WORKTREE}/${V0_PLANS_DIR}/${NAME}.md"
      elif [[ -f "${PLANS_DIR}/${NAME}.md" ]]; then
        PLAN_FOUND="${PLANS_DIR}/${NAME}.md"
      fi
    fi

    if [[ ${PLAN_EXIT} -ne 0 ]]; then
      if [[ -n "${PLAN_FOUND}" ]]; then
        emit_event "plan:recovered" "Exit code ${PLAN_EXIT} but plan file exists at ${PLAN_FOUND}"
        echo "Note: Process exited with code ${PLAN_EXIT} but plan file was created successfully"
      else
        emit_event "plan:failed" "Exit code ${PLAN_EXIT}"
        echo "Error: Plan creation failed. Check ${STATE_DIR}/logs/plan.log for details."
        rm -f "${STATE_DIR}/done"
        exit 1
      fi
    fi

    if [[ -z "${PLAN_FOUND}" ]]; then
      emit_event "plan:failed" "Plan file not created"
      echo "Error: Plan file was not created at ${V0_PLANS_DIR}/${NAME}.md"
      rm -f "${STATE_DIR}/done"
      exit 1
    fi

    if [[ "${PLAN_FOUND}" != "${PLANS_DIR}/${NAME}.md" ]]; then
      /bin/cp "${PLAN_FOUND}" "${PLANS_DIR}/${NAME}.md"
      emit_event "plan:copied" "Copied from ${PLAN_FOUND} to main repo"
    fi

    # Auto-commit the plan file (unless already committed or worktree is dirty with other changes)
    if git -C "${V0_ROOT}" diff --quiet -- "${V0_PLANS_DIR}/${NAME}.md" 2>/dev/null && \
       git -C "${V0_ROOT}" ls-files --error-unmatch "${V0_PLANS_DIR}/${NAME}.md" &>/dev/null; then
      emit_event "plan:commit" "Already committed"
    elif git -C "${V0_ROOT}" check-ignore -q "${V0_PLANS_DIR}/${NAME}.md" 2>/dev/null; then
      emit_event "plan:commit" "Skipped (gitignored)"
    elif git -C "${V0_ROOT}" add "${V0_PLANS_DIR}/${NAME}.md" && \
         git -C "${V0_ROOT}" commit -m "Add plan: ${NAME}" -m "Auto-committed by v0 feature"; then
      emit_event "plan:commit" "Committed ${V0_PLANS_DIR}/${NAME}.md"
    else
      emit_event "plan:commit" "Failed to commit (worktree may have other changes)"
    fi
  fi

  rm -f "${STATE_DIR}/done"

  # Use state machine transition to planned phase
  sm_transition_to_planned "${NAME}" "${V0_PLANS_DIR}/${NAME}.md"

  # File single feature issue
  PLAN_FILE="${PLANS_DIR}/${NAME}.md"
  FEATURE_ID=$(file_plan_issue "${NAME}" "${PLAN_FILE}")
  if [[ -n "${FEATURE_ID}" ]]; then
    update_state "epic_id" "\"${FEATURE_ID}\""
    emit_event "issue:created" "Created feature ${FEATURE_ID}"
  else
    emit_event "issue:warning" "Failed to create feature issue"
  fi

  # Add labels to the issue
  if [[ -n "${FEATURE_ID}" ]] && [[ ${#LABELS[@]} -gt 0 ]]; then
    for label in "${LABELS[@]}"; do
      wk label "${FEATURE_ID}" "${label}" 2>/dev/null || true
    done
  fi

  # Transition to queued
  sm_transition_to_queued "${NAME}" "${FEATURE_ID}"
  PHASE="queued"
fi

# Phase 2: Execute (unless --enqueue)
if [[ "${PHASE}" = "queued" ]] && [[ -z "${ENQUEUE_ONLY}" ]]; then
  mkdir -p "${STATE_DIR}/logs"

  if [[ -n "${EAGER}" ]] && [[ -n "${AFTER}" ]] && [[ "${AFTER}" != "null" ]]; then
    if ! is_after_op_merged "${AFTER}"; then
      # Use state machine transition to blocked phase (eager mode)
      sm_transition_to_blocked "${NAME}" "${AFTER}" "queued"
      echo ""
      echo -e "${C_BOLD}${C_YELLOW}=== Waiting for '${AFTER}' (eager mode) ===${C_RESET}"
      echo "Planning complete. Will execute after '${AFTER}' merges."
      echo -e "Current phase: ${C_DIM}$(get_blocker_phase "${AFTER}")${C_RESET}"
      echo -e "Feature: ${C_DIM}$(get_state epic_id)${C_RESET}"
      echo ""
      echo "Resume manually with:"
      echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
      exit 0
    fi
  fi

  emit_event "execute:starting" "Launching agent in tmux"

  SESSION=$(v0_session_name "${NAME}" "feature")

  if [[ -n "${DRY_RUN}" ]]; then
    echo "[DRY-RUN] Would run: tmux new-session -d -s ${SESSION} ... claude ..."
  else
    if tmux has-session -t "${SESSION}" 2>/dev/null; then
      echo "Error: tmux session '${SESSION}' already exists"
      echo "Attach with: v0 attach ${NAME}"
      echo "Or kill it:  v0 shutdown"
      exit 1
    fi

    tree_output=""
    FEATURE_BRANCH=$(v0_expand_branch "${V0_FEATURE_BRANCH}" "${NAME}")
    if ! tree_output=$("${V0_DIR}/bin/v0-tree" "${FEATURE_BRANCH}"); then
      echo "Error: Failed to create worktree for ${FEATURE_BRANCH}"
      exit 1
    fi
    { read -r TREE_DIR; read -r _WORKTREE; } <<< "${tree_output}"

    # Link worktree to main repo's shared workspace
    wk init --workspace "${V0_ROOT}/.wok" --path "${TREE_DIR}" 2>/dev/null || true

    FEATURE_ID=$(get_state epic_id)

    M4_ARGS="-D HAS_PLAN=1 -D V0_GIT_REMOTE=${V0_GIT_REMOTE}"
    m4 ${M4_ARGS} "${V0_DIR}/packages/cli/lib/templates/claude.build.m4" > "${TREE_DIR}/CLAUDE.md"
    emit_event "claude.md:created" "${TREE_DIR}/CLAUDE.md"

    feature_create_settings "${TREE_DIR}" "${V0_DIR}"

    PLAN_FILE="${PLANS_DIR}/${NAME}.md"
    if [[ -f "${PLAN_FILE}" ]]; then
      /bin/cp "${PLAN_FILE}" "${TREE_DIR}/PLAN.md"
      emit_event "plan:copied" "PLAN.md"
    fi

    create_feature_done_script "${TREE_DIR}"
    create_incomplete_script "${TREE_DIR}" "${NAME}" "${V0_DIR}"

    SAFE_FROM_STATE=$(get_state safe)
    [[ "${SAFE_FROM_STATE}" = "true" ]] && SAFE=1
    CLAUDE_ARGS="--model opus --dangerously-skip-permissions --allow-dangerously-skip-permissions"
    [[ -n "${SAFE}" ]] && CLAUDE_ARGS="--model opus --permission-mode acceptEdits"

    feature_create_on_complete "${TREE_DIR}" "${STATE_FILE}" "${NAME}" "${V0_DIR}" "${V0_ROOT}"

    # Ensure nudge worker is running and write session marker
    ensure_nudge_running
    write_session_marker "${TREE_DIR}" "${SESSION}"

    tmux new-session -d -s "${SESSION}" -c "${TREE_DIR}" \
      "export V0_OP='${NAME}'; export V0_PLAN_LABEL='plan:${NAME}'; export V0_WORKTREE='${TREE_DIR}/${REPO_NAME}'; export V0_ROOT='${V0_ROOT}'; \
       claude ${CLAUDE_ARGS} 'Implement the plan. See CLAUDE.md and PLAN.md for details.'; \
       '${TREE_DIR}/.claude/on-complete.sh'; \
       echo ''; echo 'Session complete. Closing in 5 seconds...'; sleep 5"

    # Store worktree first (needed by sm_is_merge_ready later)
    update_state "worktree" "\"${TREE_DIR}/${REPO_NAME}\""
    # Use state machine transition to executing phase
    sm_transition_to_executing "${NAME}" "${SESSION}"

    echo ""
    echo -e "${C_BOLD}${C_CYAN}=== Build step started ===${C_RESET}"
    echo -e "Operation: ${C_DIM}${NAME}${C_RESET}"
    echo -e "Session:   ${C_DIM}${SESSION}${C_RESET}"
    if [[ -z "${NO_MERGE}" ]]; then
      echo -e "Merge:     ${C_GREEN}Auto-merge when complete${C_RESET}"
    else
      echo -e "Merge:     ${C_DIM}Disabled (--no-merge)${C_RESET}"
    fi
    echo ""
    echo "Watch live:"
    echo -e "  ${C_BOLD}v0 attach ${NAME}${C_RESET}"
    echo -e "  ${C_DIM}(Ctrl-B D to detach)${C_RESET}"
    echo ""
    echo "Check status:"
    echo -e "  ${C_BOLD}v0 status ${NAME}${C_RESET}"
    echo ""
    echo "Stop:"
    echo -e "  ${C_BOLD}v0 cancel ${NAME}${C_RESET}${C_DIM}   # stop and cancel operation${C_RESET}"
    echo -e "  ${C_BOLD}v0 hold ${NAME}${C_RESET}${C_DIM}     # pause after current work completes${C_RESET}"
  fi
elif [[ "${PHASE}" = "queued" ]]; then
  echo ""
  echo -e "${C_BOLD}${C_CYAN}=== Work queued (--enqueue mode) ===${C_RESET}"
  echo -e "Operation: ${C_DIM}${NAME}${C_RESET}"
  echo -e "Feature: ${C_DIM}$(get_state epic_id)${C_RESET}"
  echo ""
  echo "Start execution with:"
  echo -e "  ${C_BOLD}v0 feature ${NAME} --resume${C_RESET}"
elif [[ "${PHASE}" = "executing" ]]; then
  SESSION=$(get_state tmux_session)
  echo "Operation '${NAME}' is already executing"
  echo "Attach with: v0 attach ${NAME}"
fi
