#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
# v0 mergeq - Merge queue daemon for build operations
#
# This script provides the CLI interface for the merge queue.
# All functionality is implemented in lib/mergeq/ modules.
set -eo pipefail

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"
v0_load_config

# Merge queue state must always be in the main repo's build directory, not
# in a worktree's build directory. This ensures there's a single daemon and
# a single queue shared across all worktrees.
#
# If MERGEQ_DIR is already set (e.g., inherited from parent process that
# started the daemon), use it. Otherwise compute it. This is important because
# v0_find_main_repo() doesn't work correctly when running from a clone workspace
# (it returns the clone path instead of the actual main repo).
if [[ -z "${MERGEQ_DIR:-}" ]]; then
    MAIN_REPO=$(v0_find_main_repo)
    export MERGEQ_DIR="${MAIN_REPO}/${V0_BUILD_DIR}/mergeq"
fi
export QUEUE_FILE="${MERGEQ_DIR}/queue.json"
export QUEUE_LOCK="${MERGEQ_DIR}/.queue.lock"
export DAEMON_PID_FILE="${MERGEQ_DIR}/.daemon.pid"
export DAEMON_LOG_FILE="${MERGEQ_DIR}/logs/daemon.log"

# Source the merge queue modules
source "${V0_DIR}/packages/mergeq/lib/queue.sh"

usage() {
    v0_help <<'EOF'
Usage: v0 mergeq [options]

Merge queue daemon for build operations.

Options:
  --status         Show queue status
  --list           List queued operations
  --add <op>       Manually add operation to queue
  --enqueue <op>   Alias for --add
  --once           Process one merge and exit
  --watch          Continuous mode (runs in foreground)

Helper functions (for internal use):
  --dequeue        Get next pending merge (outputs operation name)
  --update <op> <status>  Update entry status

Examples:
  v0 mergeq --status
  v0 mergeq --add auth
  v0 mergeq --once
  v0 mergeq --watch
EOF
    exit 1
}

# Main argument parsing
ACTION=""
OPERATION=""
STATUS=""
ISSUE_ID=""

while [[ $# -gt 0 ]]; do
    case "$1" in
        --start) ACTION="start"; shift ;;
        --once) ACTION="once"; shift ;;
        --watch) ACTION="watch"; shift ;;
        --status) ACTION="status"; shift ;;
        --list) ACTION="list"; shift ;;
        --stop) ACTION="stop"; shift ;;
        --add|--enqueue)
            ACTION="enqueue"
            OPERATION="$2"
            shift 2
            ;;
        --issue-id)
            ISSUE_ID="$2"
            shift 2
            ;;
        --dequeue) ACTION="dequeue"; shift ;;
        --update)
            ACTION="update"
            OPERATION="$2"
            STATUS="$3"
            shift 3
            ;;
        -h|--help) usage ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Default action
[[ -z "${ACTION}" ]] && ACTION="status"

# Execute action
case "${ACTION}" in
    start) mq_start_daemon ;;
    status) mq_show_status ;;
    list) mq_list_entries ;;
    enqueue) mq_enqueue "${OPERATION}" 0 "${ISSUE_ID}" ;;
    dequeue) mq_dequeue_merge ;;
    update)
        mq_ensure_queue_exists
        mq_acquire_lock
        mq_update_entry_status "${OPERATION}" "${STATUS}"
        mq_release_lock
        mq_log_event "update: ${OPERATION} -> ${STATUS}"
        ;;
    once) mq_process_once ;;
    watch) mq_process_watch ;;
    stop) mq_stop_daemon ;;
    *) echo "Unknown action: ${ACTION}"; usage ;;
esac
