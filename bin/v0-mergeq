#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
# v0 mergeq - Merge queue daemon for build operations
#
# This script provides the CLI interface for the merge queue.
# All functionality is implemented in lib/mergeq/ modules.
set -eo pipefail

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
source "${V0_DIR}/packages/cli/lib/history-format.sh"
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"

# Save inherited variables before v0_load_config potentially overwrites them.
# When the daemon starts in the workspace, v0_load_config may load wrong values:
# - BUILD_DIR/MERGEQ_DIR: workspace's .v0.rc sets these to workspace paths
# - V0_DEVELOP_BRANCH: workspace lacks .v0.profile.rc (gitignored), so defaults to "main"
_INHERITED_BUILD_DIR="${BUILD_DIR:-}"
_INHERITED_MERGEQ_DIR="${MERGEQ_DIR:-}"
_INHERITED_DEVELOP_BRANCH="${V0_DEVELOP_BRANCH:-}"

v0_load_config

# Merge queue state must always be in the main repo's build directory, not
# in a worktree's build directory. This ensures there's a single daemon and
# a single queue shared across all worktrees.
#
# If MERGEQ_DIR was inherited from parent process (e.g., daemon started via
# mq_start_daemon), use the inherited values. Otherwise compute from scratch.
# This is important because v0_find_main_repo() doesn't work correctly when
# running from an invalid workspace (returns workspace path instead of main repo).
#
# Similarly, V0_DEVELOP_BRANCH must be inherited because the workspace lacks
# .v0.profile.rc (gitignored), causing v0_load_config to default to "main".
if [[ -n "${_INHERITED_MERGEQ_DIR}" ]]; then
    # Restore inherited values (they point to main repo, not workspace)
    export MERGEQ_DIR="${_INHERITED_MERGEQ_DIR}"
    export BUILD_DIR="${_INHERITED_BUILD_DIR}"
    [[ -n "${_INHERITED_DEVELOP_BRANCH}" ]] && export V0_DEVELOP_BRANCH="${_INHERITED_DEVELOP_BRANCH}"
else
    MAIN_REPO=$(v0_find_main_repo)
    export MERGEQ_DIR="${MAIN_REPO}/${V0_BUILD_DIR}/mergeq"
    # BUILD_DIR must also point to main repo, not workspace, so state files are found
    export BUILD_DIR="${MAIN_REPO}/${V0_BUILD_DIR}"
    # Load V0_DEVELOP_BRANCH from main repo's .v0.profile.rc if not already set correctly.
    # When called from a worktree that lacks .v0.profile.rc, V0_DEVELOP_BRANCH defaults
    # to "main" which causes workspace mismatch and daemon startup failures.
    if [[ -f "${MAIN_REPO}/.v0.profile.rc" ]]; then
        source "${MAIN_REPO}/.v0.profile.rc"
    fi
fi
export QUEUE_FILE="${MERGEQ_DIR}/queue.json"
export QUEUE_LOCK="${MERGEQ_DIR}/.queue.lock"
export DAEMON_PID_FILE="${MERGEQ_DIR}/.daemon.pid"
export DAEMON_LOG_FILE="${MERGEQ_DIR}/logs/daemon.log"

# Source the merge queue modules
source "${V0_DIR}/packages/mergeq/lib/queue.sh"

usage() {
    v0_help <<'EOF'
Usage: v0 mergeq [options]

Merge queue daemon for build operations.

Options:
  --status         Show queue status
  --list           List queued operations
  --add <op>       Manually add operation to queue
  --enqueue <op>   Alias for --add
  --once           Process one merge and exit
  --watch          Continuous mode (runs in foreground)
  --restart        Restart the merge queue daemon

Helper functions (for internal use):
  --dequeue        Get next pending merge (outputs operation name)
  --update <op> <status>  Update entry status

Examples:
  v0 mergeq --status
  v0 mergeq --add auth
  v0 mergeq --once
  v0 mergeq --watch
EOF
    exit 1
}

# Main argument parsing
ACTION=""
OPERATION=""
STATUS=""
ISSUE_ID=""
HISTORY_LIMIT=10

while [[ $# -gt 0 ]]; do
    case "$1" in
        --start) ACTION="start"; shift ;;
        --once) ACTION="once"; shift ;;
        --watch) ACTION="watch"; shift ;;
        --status) ACTION="status"; shift ;;
        --list) ACTION="list"; shift ;;
        --stop) ACTION="stop"; shift ;;
        --restart) ACTION="restart"; shift ;;
        --history)
            ACTION="history"
            HISTORY_LIMIT=10
            shift
            ;;
        --history=*)
            ACTION="history"
            arg="${1#--history=}"
            if [[ "${arg}" = "all" ]]; then
                HISTORY_LIMIT=999999
            else
                HISTORY_LIMIT="${arg}"
            fi
            shift
            ;;
        --add|--enqueue)
            ACTION="enqueue"
            OPERATION="$2"
            shift 2
            ;;
        --issue-id)
            ISSUE_ID="$2"
            shift 2
            ;;
        --dequeue) ACTION="dequeue"; shift ;;
        --update)
            ACTION="update"
            OPERATION="$2"
            STATUS="$3"
            shift 3
            ;;
        -h|--help) usage ;;
        restart)
            # Hidden subcommand: 'v0 mergeq restart' -> 'v0 mergeq --restart'
            ACTION="restart"
            shift
            ;;
        status)
            # Hidden subcommand: 'v0 mergeq status' -> 'v0 mergeq --status'
            ACTION="status"
            shift
            ;;
        *)
            echo "Unknown option: $1"
            usage
            ;;
    esac
done

# Default action
[[ -z "${ACTION}" ]] && ACTION="status"

# Execute action
case "${ACTION}" in
    start) mq_start_daemon ;;
    status) mq_show_status ;;
    list) mq_list_entries ;;
    history) mq_show_history "${HISTORY_LIMIT}" ;;
    enqueue) mq_enqueue "${OPERATION}" 0 "${ISSUE_ID}" ;;
    dequeue) mq_dequeue_merge ;;
    update)
        mq_ensure_queue_exists
        mq_acquire_lock
        mq_update_entry_status "${OPERATION}" "${STATUS}"
        mq_release_lock
        mq_log_event "update: ${OPERATION} -> ${STATUS}"
        ;;
    once) mq_process_once ;;
    watch) mq_process_watch ;;
    stop) mq_stop_daemon ;;
    restart)
        mq_stop_daemon
        mq_start_daemon
        ;;
    *) echo "Unknown action: ${ACTION}"; usage ;;
esac
