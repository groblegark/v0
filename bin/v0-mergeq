#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -eo pipefail

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/lib/v0-common.sh"
source "${V0_DIR}/lib/nudge-common.sh"
v0_load_config

# Merge queue state must always be in the main repo's build directory, not
# in a worktree's build directory. This ensures there's a single daemon and
# a single queue shared across all worktrees.
MAIN_REPO=$(v0_find_main_repo)
MERGEQ_DIR="${MAIN_REPO}/${V0_BUILD_DIR}/mergeq"
QUEUE_FILE="${MERGEQ_DIR}/queue.json"
QUEUE_LOCK="${MERGEQ_DIR}/.queue.lock"
DAEMON_LOG_FILE="${MERGEQ_DIR}/logs/daemon.log"

usage() {
  cat <<EOF
Usage: v0 mergeq [options]

Merge queue daemon for build operations.

Options:
  --start          Start daemon in background (if not running)
  --stop           Stop the daemon if running
  --status         Show queue status
  --list           List queued operations
  --add <op>       Manually add operation to queue
  --enqueue <op>   Alias for --add
  --once           Process one merge and exit
  --watch          Continuous mode (runs in foreground)

Helper functions (for internal use):
  --dequeue        Get next pending merge (outputs operation name)
  --update <op> <status>  Update entry status

Examples:
  v0 mergeq --status
  v0 mergeq --add auth
  v0 mergeq --once
  v0 mergeq --watch
EOF
  exit 1
}

# PID file for daemon process
DAEMON_PID_FILE="${MERGEQ_DIR}/.daemon.pid"

# Check if daemon is running (background process)
daemon_running() {
  if [[ -f "${DAEMON_PID_FILE}" ]]; then
    local pid
    pid=$(cat "${DAEMON_PID_FILE}")
    if [[ -n "${pid}" ]] && kill -0 "${pid}" 2>/dev/null; then
      return 0
    fi
    # Stale PID file
    rm -f "${DAEMON_PID_FILE}"
  fi
  return 1
}

# Ensure daemon is running, start if not
ensure_daemon_running() {
  if daemon_running; then
    return 0
  fi
  start_daemon
}

# Start the daemon as background process
start_daemon() {
  if daemon_running; then
    echo "Worker already running (pid: $(cat "${DAEMON_PID_FILE}"))"
    return 0
  fi

  ensure_queue_exists
  echo "Starting merge queue worker..."

  # Start the daemon from the main repo (not a worktree)
  # The daemon must be able to checkout the main branch, which is only
  # possible from the main repo (worktrees can't checkout branches that are
  # already checked out elsewhere)
  local old_pwd="${PWD}"
  cd "${MAIN_REPO}"
  nohup "${V0_DIR}/bin/v0-mergeq" --watch >> "${DAEMON_LOG_FILE}" 2>&1 &
  local daemon_pid=$!
  cd "${old_pwd}"

  # Write PID file
  echo "${daemon_pid}" > "${DAEMON_PID_FILE}"

  # Wait briefly to ensure daemon started
  sleep 0.5
  if ! daemon_running; then
    echo "Error: Daemon failed to start"
    rm -f "${DAEMON_PID_FILE}"
    return 1
  fi

  echo -e "${C_GREEN}Worker started${C_RESET} ${C_DIM}(pid: ${daemon_pid})${C_RESET}"
  echo ""
  echo -e "Check status: ${C_BOLD}v0 mergeq --status${C_RESET}"
  echo -e "View logs:    ${C_BOLD}tail -f ${DAEMON_LOG_FILE}${C_RESET}"
}

# Stop the daemon
stop_daemon() {
  if ! daemon_running; then
    echo "Worker not running"
    return 0
  fi

  local pid
  pid=$(cat "${DAEMON_PID_FILE}")
  echo "Stopping merge queue worker (pid: ${pid})..."
  kill "${pid}" 2>/dev/null || true
  rm -f "${DAEMON_PID_FILE}"
  echo "Worker stopped"
}

# Ensure directory and queue file exist
ensure_queue_exists() {
  mkdir -p "${MERGEQ_DIR}/logs"
  if [[ ! -f "${QUEUE_FILE}" ]]; then
    echo '{"version":1,"entries":[]}' > "${QUEUE_FILE}"
  fi
}

# Emit event to notification hook
emit_event() {
  local event="$1"
  local operation="$2"
  local hook="${BUILD_DIR}/hooks/on-event.sh"
  local template="${V0_DIR}/lib/templates/on-event.sh"

  # Install hook from template if missing
  if [[ ! -f "${hook}" ]] && [[ -f "${template}" ]]; then
    mkdir -p "$(dirname "${hook}")"
    cp "${template}" "${hook}"
    chmod +x "${hook}"
  fi

  if [[ -x "${hook}" ]]; then
    echo "{\"event\":\"${event}\",\"operation\":\"${operation}\"}" | "${hook}" 2>/dev/null || true
  fi
}

# Atomic file operations for queue modifications
# Uses write-to-temp + rename pattern for atomicity
atomic_queue_update() {
  local jq_filter="$1"
  local tmp
  tmp=$(mktemp)

  if ! jq "${jq_filter}" "${QUEUE_FILE}" > "${tmp}" 2>/dev/null; then
    rm -f "${tmp}"
    echo "Error: Failed to update queue" >&2
    return 1
  fi

  mv "${tmp}" "${QUEUE_FILE}"
}

# Queue lock management
acquire_queue_lock() {
  if [[ -f "${QUEUE_LOCK}" ]]; then
    # Stale check: if PID in lock is dead, remove it
    local holder_pid
    holder_pid=$(grep -oE 'pid [0-9]+' "${QUEUE_LOCK}" 2>/dev/null | grep -oE '[0-9]+' || true)
    if [[ -n "${holder_pid}" ]] && ! kill -0 "${holder_pid}" 2>/dev/null; then
      rm -f "${QUEUE_LOCK}"
    else
      local holder
      holder=$(cat "${QUEUE_LOCK}" 2>/dev/null || echo "unknown")
      echo "Error: Queue lock held by: ${holder}" >&2
      return 1
    fi
  fi
  echo "mergeq (pid $$)" > "${QUEUE_LOCK}"
  trap 'rm -f "${QUEUE_LOCK}"' EXIT
}

release_queue_lock() {
  rm -f "${QUEUE_LOCK}"
  trap - EXIT
}

# enqueue_merge <operation> [priority] [issue_id]
# Add an operation to the merge queue
# issue_id is optional - if provided, the merge queue will call 'wk done <issue_id>' on success
enqueue_merge() {
  local operation="$1"
  local priority="${2:-0}"
  local issue_id="${3:-}"

  if [[ -z "${operation}" ]]; then
    echo "Error: Operation name required" >&2
    return 1
  fi

  ensure_queue_exists

  # Retry lock acquisition with backoff to handle contention
  local lock_acquired=false
  local max_retries=5
  local retry_delay=1
  for i in $(seq 1 "${max_retries}"); do
    if acquire_queue_lock 2>/dev/null; then
      lock_acquired=true
      break
    fi
    if [[ ${i} -lt ${max_retries} ]]; then
      sleep "${retry_delay}"
      retry_delay=$((retry_delay * 2))
    fi
  done

  if [[ "${lock_acquired}" = false ]]; then
    echo "Error: Could not acquire queue lock after ${max_retries} attempts" >&2
    return 1
  fi

  # Check if already in queue
  local existing_status
  existing_status=$(jq -r ".entries[] | select(.operation == \"${operation}\") | .status" "${QUEUE_FILE}")
  if [[ "${existing_status}" = "pending" ]] || [[ "${existing_status}" = "processing" ]]; then
    echo "Operation '${operation}' already in queue" >&2
    release_queue_lock
    ensure_daemon_running
    return 0
  fi

  # If there's an existing entry with inactive status (resumed/completed/failed/conflict),
  # update it to pending instead of adding a duplicate
  if [[ -n "${existing_status}" ]]; then
    local enqueued_at
    enqueued_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    atomic_queue_update "(.entries[] | select(.operation == \"${operation}\")) |= . + {
      \"status\": \"pending\",
      \"enqueued_at\": \"${enqueued_at}\",
      \"priority\": ${priority}
    }"
    release_queue_lock

    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] re-enqueue: ${operation} (was ${existing_status}, priority: ${priority})" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:queued" "${operation}"
    echo "Re-enqueued: ${operation} (was ${existing_status})"

    ensure_nudge_running
    ensure_daemon_running
    return 0
  fi

  # Get worktree path and detect merge type
  local worktree=""
  local merge_type="operation"

  # Check for build operation
  local state_file="${BUILD_DIR}/operations/${operation}/state.json"
  if [[ -f "${state_file}" ]]; then
    worktree=$(jq -r '.worktree // empty' "${state_file}")
  elif [[ "${operation}" == */* ]]; then
    # Looks like a branch name (e.g., fix/xxx, feature/foo)
    merge_type="branch"
  fi

  # Add to queue
  local enqueued_at
  enqueued_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  # Build the entry with optional issue_id
  local issue_id_field=""
  if [[ -n "${issue_id}" ]]; then
    issue_id_field="\"issue_id\": \"${issue_id}\","
  fi

  atomic_queue_update ".entries += [{
    \"operation\": \"${operation}\",
    \"worktree\": \"${worktree}\",
    \"priority\": ${priority},
    \"enqueued_at\": \"${enqueued_at}\",
    \"status\": \"pending\",
    \"merge_type\": \"${merge_type}\",
    ${issue_id_field}
    \"_\": null
  }] | .entries[-1] |= del(._)"

  release_queue_lock

  # Log the event
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] enqueue: ${operation} (priority: ${priority}, type: ${merge_type})" >> "${MERGEQ_DIR}/logs/merges.log"
  emit_event "merge:queued" "${operation}"
  echo "Enqueued: ${operation}"

  # Ensure nudge worker is running to monitor sessions
  ensure_nudge_running

  # Auto-start daemon if not running
  ensure_daemon_running
}

# dequeue_merge
# Get the next pending merge (by priority, then by enqueue time)
# Outputs the operation name if found, empty if queue is empty
dequeue_merge() {
  ensure_queue_exists

  # Get next pending entry (lowest priority first, then oldest)
  local next
  next=$(jq -r '[.entries[] | select(.status == "pending")] | sort_by(.priority, .enqueued_at) | .[0].operation // empty' "${QUEUE_FILE}")

  if [[ -z "${next}" ]]; then
    return 1
  fi

  echo "${next}"
}

# get_issue_id <operation>
# Get the issue_id associated with a queue entry (if any)
get_issue_id() {
  local operation="$1"
  ensure_queue_exists
  jq -r ".entries[] | select(.operation == \"${operation}\") | .issue_id // empty" "${QUEUE_FILE}"
}

# update_entry <operation> <status>
# Update the status of a queue entry
# Valid statuses: pending, processing, completed, failed, conflict
update_entry() {
  local operation="$1"
  local status="$2"

  if [[ -z "${operation}" ]] || [[ -z "${status}" ]]; then
    echo "Error: Operation and status required" >&2
    return 1
  fi

  ensure_queue_exists
  acquire_queue_lock

  # Check if entry exists
  local exists
  exists=$(jq -r ".entries[] | select(.operation == \"${operation}\") | .operation" "${QUEUE_FILE}")
  if [[ -z "${exists}" ]]; then
    echo "Error: Operation '${operation}' not found in queue" >&2
    release_queue_lock
    return 1
  fi

  # Update the entry
  local updated_at
  updated_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)

  atomic_queue_update "(.entries[] | select(.operation == \"${operation}\")) |= . + {
    \"status\": \"${status}\",
    \"updated_at\": \"${updated_at}\"
  }"

  release_queue_lock

  # Log the event
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] update: ${operation} -> ${status}" >> "${MERGEQ_DIR}/logs/merges.log"
}

# Show queue status
show_status() {
  ensure_queue_exists

  # Daemon status - consistent labels with fix/chore
  local pending processing completed failed
  pending=$(jq '[.entries[] | select(.status == "pending")] | length' "${QUEUE_FILE}")
  processing=$(jq '[.entries[] | select(.status == "processing")] | length' "${QUEUE_FILE}")
  completed=$(jq '[.entries[] | select(.status == "completed")] | length' "${QUEUE_FILE}")
  failed=$(jq '[.entries[] | select(.status == "failed" or .status == "conflict")] | length' "${QUEUE_FILE}")

  if daemon_running; then
    local pid
    pid=$(cat "${DAEMON_PID_FILE}")
    if [[ "${processing}" -gt 0 ]]; then
      echo "Merge Worker: Active (merging) [pid: ${pid}]"
    elif [[ "${pending}" -gt 0 ]]; then
      echo "Merge Worker: Active (pending) [pid: ${pid}]"
    else
      echo "Merge Worker: Polling [pid: ${pid}]"
    fi
  else
    echo "Merge Worker: Stopped"
  fi
  echo ""

  echo "Pending:    ${pending}"
  echo "Processing: ${processing}"
  echo "Completed:  ${completed}"
  echo "Failed:     ${failed}"

  if [[ -f "${QUEUE_LOCK}" ]]; then
    echo ""
    echo "Lock held by: $(cat "${QUEUE_LOCK}")"
  fi
}

# List queue entries
list_entries() {
  ensure_queue_exists

  local entries
  entries=$(jq -r '.entries[] | "\(.status)\t\(.operation)\t\(.priority)\t\(.enqueued_at)"' "${QUEUE_FILE}")

  if [[ -z "${entries}" ]]; then
    echo "Queue is empty"
    return 0
  fi

  echo "STATUS       OPERATION    PRIORITY  ENQUEUED"
  echo "------       ---------    --------  --------"
  echo "${entries}" | while IFS=$'\t' read -r status op priority enqueued; do
    printf "%-12s %-12s %-9s %s\n" "${status}" "${op}" "${priority}" "${enqueued}"
  done
}

# is_branch_merge <operation>
# Check if operation is actually a branch on remote
# Uses git to verify, not just pattern matching
is_branch_merge() {
  local op="$1"
  # Check if it exists as a branch on remote
  git ls-remote --heads "${V0_GIT_REMOTE}" "${op}" 2>/dev/null | grep -q .
}

# is_branch_ready <branch>
# Check if a bare branch is ready to merge
# Returns 0 if ready (branch exists on remote), 1 if not
is_branch_ready() {
  local branch="$1"

  # Check if branch exists on remote (already verified by is_branch_merge)
  if ! git ls-remote --heads "${V0_GIT_REMOTE}" "${branch}" 2>/dev/null | grep -q .; then
    echo "Branch '${V0_GIT_REMOTE}/${branch}' does not exist" >&2
    return 1
  fi

  return 0
}

# is_stale <operation>
# Check if a queue entry is stale and should be auto-cleaned
# Returns 0 if stale, 1 if not stale
is_stale() {
  local op="$1"
  local state_file="${BUILD_DIR}/operations/${op}/state.json"

  # Check for build operation state
  if [[ -f "${state_file}" ]]; then
    # Check for merged_at - indicates operation claims to be merged
    local merged_at
    merged_at=$(jq -r '.merged_at // empty' "${state_file}")
    if [[ -n "${merged_at}" ]]; then
      # Verify the merge is real using merge_commit
      if v0_verify_merge_by_op "${op}"; then
        echo "already merged at ${merged_at}"
        return 0
      else
        # Claims merged but verification failed - still stale, needs attention
        echo "claims merged but verification failed"
        return 0
      fi
    fi

    # Check if operation was recreated (queue entry older than state)
    # This catches stale queue entries from previously merged operations with same name
    local queue_time state_time
    queue_time=$(jq -r ".entries[] | select(.operation == \"${op}\") | .enqueued_at // empty" "${QUEUE_FILE}" 2>/dev/null)
    state_time=$(jq -r '.created_at // empty' "${state_file}")
    if [[ -n "${queue_time}" ]] && [[ -n "${state_time}" ]]; then
      # String comparison works for ISO 8601 timestamps
      if [[ "${state_time}" > "${queue_time}" ]]; then
        echo "stale queue entry (operation recreated)"
        return 0
      fi
    fi

    return 1
  fi

  # No state file - check if it looks like a branch
  if [[ "${op}" == */* ]]; then
    # Branch name pattern - check if branch exists on remote
    # IMPORTANT: Must distinguish between "branch doesn't exist" and "git command failed"
    local ls_output ls_exit
    ls_output=$(git -C "${V0_ROOT}" ls-remote --heads "${V0_GIT_REMOTE}" "${op}" 2>&1)
    ls_exit=$?

    if [[ ${ls_exit} -ne 0 ]]; then
      # git command failed - don't assume stale, could be network/directory issue
      echo "git ls-remote failed (exit ${ls_exit}): ${ls_output}" >&2
      return 1
    fi

    if [[ -z "${ls_output}" ]]; then
      echo "branch no longer exists on remote"
      return 0
    fi
  else
    # Not a branch pattern and no state file = stale
    echo "no state file and not a branch"
    return 0
  fi

  return 1
}

# is_merge_ready <operation>
# Check if an operation is ready to be merged
# Returns 0 if ready, 1 if not ready
is_merge_ready() {
  local op="$1"
  local state_file="${BUILD_DIR}/operations/${op}/state.json"

  # Check for build operation state
  if [[ -f "${state_file}" ]]; then
    # Must have merge_queued set (not checked by sm_is_merge_ready)
    if [[ "$(jq -r '.merge_queued // false' "${state_file}")" != "true" ]]; then
      echo "merge_queued not set for '${op}'" >&2
      return 1
    fi

    # Use state machine function for remaining checks
    if ! sm_is_merge_ready "${op}"; then
      local reason
      reason=$(sm_merge_ready_reason "${op}")
      echo "${reason}" >&2
      return 1
    fi

    return 0
  fi

  # No state file - check if it's a bare branch merge
  if is_branch_merge "${op}"; then
    is_branch_ready "${op}"
    return $?
  fi

  echo "No state file for '${op}' and not a branch name" >&2
  return 1
}

# update_operation_state <operation> <key> <value>
# Update a field in the operation's state.json
update_operation_state() {
  local op="$1"
  local key="$2"
  local value="$3"

  # Use state machine function
  sm_update_state "${op}" "${key}" "${value}"
}

# find_dependent_operations <merged_operation>
# Find operations waiting for the given operation
find_dependent_operations() {
  local merged_op="$1"
  # Use state machine function
  sm_find_dependents "${merged_op}"
}

# resume_waiting_operation <operation>
# Resume an operation that was waiting and is now unblocked
resume_waiting_operation() {
  local op="$1"

  if ! sm_state_exists "${op}"; then
    echo "Warning: No state file for dependent operation '${op}'" >&2
    return 1
  fi

  # Check if held before resuming
  if sm_is_held "${op}"; then
    sm_emit_event "${op}" "unblock:held" "Dependency merged but operation held"
    echo "[$(date +%H:%M:%S)] Operation '${op}' remains held"
    return 0
  fi

  # Get the phase to resume from (for logging)
  local blocked_phase
  blocked_phase=$(sm_read_state "${op}" "blocked_phase")
  [[ -z "${blocked_phase}" ]] || [[ "${blocked_phase}" = "null" ]] && blocked_phase="init"

  # Use state machine to unblock
  sm_unblock_operation "${op}"

  echo "[$(date +%H:%M:%S)] Resuming operation: ${op} (from phase: ${blocked_phase})"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] unblock:resumed: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
  emit_event "unblock:triggered" "${op}"

  # Resume the operation in background
  "${V0_DIR}/bin/v0-feature" "${op}" --resume &
}

# process_branch_merge <branch>
# Process a simple branch merge (no state file, just merge from remote)
# Returns 0 on success, 1 on failure
process_branch_merge() {
  local branch="$1"

  # Get issue_id if this branch is associated with a bug/chore fix
  local issue_id
  issue_id=$(get_issue_id "${branch}")

  echo "[$(date +%H:%M:%S)] Processing branch merge: ${branch}"
  if [[ -n "${issue_id}" ]]; then
    echo "[$(date +%H:%M:%S)] Associated issue: ${issue_id}"
  fi
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:started: ${branch} (branch)" >> "${MERGEQ_DIR}/logs/merges.log"
  emit_event "merge:started" "${branch}"

  # Ensure we're in the project root
  cd "${V0_ROOT}"

  # Ensure we're on the main branch
  local current_branch
  current_branch=$(git rev-parse --abbrev-ref HEAD)
  if [[ "${current_branch}" != "${V0_DEVELOP_BRANCH}" ]]; then
    echo "[$(date +%H:%M:%S)] Switching to ${V0_DEVELOP_BRANCH} (was on ${current_branch})"
    git checkout "${V0_DEVELOP_BRANCH}" 2>&1 | tee -a "${MERGEQ_DIR}/logs/merges.log"
    local checkout_exit=${PIPESTATUS[0]}
    if [[ ${checkout_exit} -ne 0 ]]; then
      echo "[$(date +%H:%M:%S)] Failed to checkout ${V0_DEVELOP_BRANCH} (exit ${checkout_exit})" >&2
      update_entry "${branch}" "failed"
      echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:failed: ${branch} (checkout failed)" >> "${MERGEQ_DIR}/logs/merges.log"
      emit_event "merge:failed" "${branch}"
      return 1
    fi
  fi

  # Pull latest develop branch to stay current
  git pull --ff-only "${V0_GIT_REMOTE}" "${V0_DEVELOP_BRANCH}" 2>&1 | tee -a "${MERGEQ_DIR}/logs/merges.log" || true

  # Clean up any incomplete merge/rebase state from previous failed attempts
  if [[ -d ".git/rebase-merge" ]] || [[ -d ".git/rebase-apply" ]]; then
    echo "[$(date +%H:%M:%S)] Aborting incomplete rebase..."
    git rebase --abort 2>/dev/null || true
  fi
  if [[ -f ".git/MERGE_HEAD" ]]; then
    echo "[$(date +%H:%M:%S)] Aborting incomplete merge..."
    git merge --abort 2>/dev/null || true
  fi

  # Fetch latest
  git fetch "${V0_GIT_REMOTE}" "${branch}" 2>&1 | tee -a "${MERGEQ_DIR}/logs/merges.log"
  local fetch_exit=${PIPESTATUS[0]}
  if [[ ${fetch_exit} -ne 0 ]]; then
    echo "[$(date +%H:%M:%S)] Failed to fetch ${branch} (exit ${fetch_exit})" >&2
    update_entry "${branch}" "failed"
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:failed: ${branch} (fetch failed)" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:failed" "${branch}"
    return 1
  fi

  # Try to merge - capture exit code correctly with PIPESTATUS
  set +e
  local merge_output
  merge_output=$(git merge --no-edit "${V0_GIT_REMOTE}/${branch}" 2>&1)
  local merge_exit=$?
  set -e

  # Log the output
  echo "${merge_output}" | tee -a "${MERGEQ_DIR}/logs/merges.log"

  if [[ ${merge_exit} -eq 0 ]]; then
    # Success - push to remote (capture exit code with PIPESTATUS)
    echo "Pushing merged changes..."
    git push "${V0_GIT_REMOTE}" "${V0_DEVELOP_BRANCH}" 2>&1 | tee -a "${MERGEQ_DIR}/logs/merges.log"
    local push_exit=${PIPESTATUS[0]}

    if [[ ${push_exit} -ne 0 ]]; then
      echo "[$(date +%H:%M:%S)] Push failed for ${branch}" >&2
      update_entry "${branch}" "failed"
      echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:failed: ${branch} (push failed)" >> "${MERGEQ_DIR}/logs/merges.log"
      emit_event "merge:failed" "${branch}"
      return 1
    fi

    # Delete the merged branch
    echo "Deleting merged branch ${V0_GIT_REMOTE}/${branch}..."
    git push "${V0_GIT_REMOTE}" --delete "${branch}" 2>&1 | tee -a "${MERGEQ_DIR}/logs/merges.log" || true

    update_entry "${branch}" "completed"
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:completed: ${branch} (branch)" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:completed" "${branch}"
    echo "[$(date +%H:%M:%S)] Merge completed: ${branch}"

    return 0
  else
    # Conflict detected - attempt automatic resolution with AI
    echo "[$(date +%H:%M:%S)] Merge has conflicts, attempting automatic resolution..."
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:resolving: ${branch} (branch)" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:resolving" "${branch}"

    # Don't abort - we have the conflicts in the working tree
    # Launch claude in tmux session to resolve conflicts
    local resolve_session
    resolve_session=$(v0_session_name "$(echo "${branch}" | tr '/' '-')" "mergeq-resolve")

    # Kill existing session if any
    tmux kill-session -t "${resolve_session}" 2>/dev/null || true

    # Create resolve script
    local resolve_script="${MERGEQ_DIR}/resolve-${branch}.sh"
    cat > "${resolve_script}" <<RESOLVE_EOF
#!/bin/bash
set -e
cd "${V0_ROOT}"

# Clean up any incomplete merge/rebase state from previous failed attempts
if [[ -d ".git/rebase-merge" ]] || [[ -d ".git/rebase-apply" ]]; then
  echo "Aborting incomplete rebase..."
  git rebase --abort 2>/dev/null || true
fi
if [[ -f ".git/MERGE_HEAD" ]]; then
  echo "Aborting incomplete merge..."
  git merge --abort 2>/dev/null || true
fi

# Re-attempt the merge to get conflict state
git fetch "${V0_GIT_REMOTE}" "${branch}"
git merge --no-edit "${V0_GIT_REMOTE}/${branch}" || true

# Run claude to resolve conflicts
claude --model opus --dangerously-skip-permissions --allow-dangerously-skip-permissions "\$(cat '${V0_DIR}/lib/prompts/merge.md')

Resolve the merge conflicts in the current directory.

This is a branch merge of '${branch}' into main.

Run: git status"

# Check if conflicts were resolved
if git status --porcelain | grep -q '^UU\|^AA\|^DD'; then
  echo "Conflicts still exist after resolution attempt"
  git merge --abort 2>/dev/null || true
  exit 1
fi

# Commit the merge
git commit --no-edit || true

# Push the result to develop branch explicitly (HEAD may track a worker branch)
git push "${V0_GIT_REMOTE}" HEAD:"${V0_DEVELOP_BRANCH}"

# Delete the merged branch
git push "${V0_GIT_REMOTE}" --delete "${branch}" 2>/dev/null || true

echo "0" > "${MERGEQ_DIR}/resolve-${branch}.exit"
RESOLVE_EOF
    chmod +x "${resolve_script}"

    # Launch in tmux
    echo "[$(date +%H:%M:%S)] Launching claude in tmux session: ${resolve_session}"
    tmux new-session -d -s "${resolve_session}" -c "${V0_ROOT}" "${resolve_script}; echo \$? > '${MERGEQ_DIR}/resolve-${branch}.exit'"

    # Wait for resolution (with timeout)
    local wait_count=0
    local max_wait=300  # 5 minutes max
    while tmux has-session -t "${resolve_session}" 2>/dev/null && [[ ${wait_count} -lt ${max_wait} ]]; do
      sleep 2
      wait_count=$((wait_count + 2))
      # Check if exit file exists
      if [[ -f "${MERGEQ_DIR}/resolve-${branch}.exit" ]]; then
        tmux kill-session -t "${resolve_session}" 2>/dev/null || true
        break
      fi
    done

    # Check result
    if [[ -f "${MERGEQ_DIR}/resolve-${branch}.exit" ]]; then
      local resolve_exit
      resolve_exit=$(cat "${MERGEQ_DIR}/resolve-${branch}.exit")
      rm -f "${MERGEQ_DIR}/resolve-${branch}.exit" "${resolve_script}"

      if [[ "${resolve_exit}" = "0" ]]; then
        update_entry "${branch}" "completed"
        echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:completed: ${branch} (branch, after resolution)" >> "${MERGEQ_DIR}/logs/merges.log"
        emit_event "merge:completed" "${branch}"
        echo "[$(date +%H:%M:%S)] Merge completed (after automatic resolution): ${branch}"

        return 0
      fi
    fi

    # Resolution failed or timed out
    git merge --abort 2>/dev/null || true
    rm -f "${MERGEQ_DIR}/resolve-${branch}.exit" "${resolve_script}"
    tmux kill-session -t "${resolve_session}" 2>/dev/null || true

    update_entry "${branch}" "conflict"
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:conflict: ${branch} (branch, resolution failed)" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:conflict" "${branch}"
    echo "[$(date +%H:%M:%S)] Automatic resolution failed: ${branch}"
    echo "  To resolve manually:"
    echo "    git fetch ${V0_GIT_REMOTE} ${branch}"
    echo "    git merge ${V0_GIT_REMOTE}/${branch}"
    echo "    # resolve conflicts"
    echo "    git push ${V0_GIT_REMOTE} HEAD:${V0_DEVELOP_BRANCH}"
    echo "  Or attach to resolve session:"
    echo "    tmux attach -t ${resolve_session}"
    return 1
  fi
}

# process_merge <operation>
# Process a single merge operation
# Returns 0 on success, 1 on failure
process_merge() {
  local op="$1"
  local state_file="${BUILD_DIR}/operations/${op}/state.json"

  # Check if it's a bare branch merge (no state file)
  if [[ ! -f "${state_file}" ]]; then
    if is_branch_merge "${op}"; then
      process_branch_merge "${op}"
      return $?
    else
      echo "Error: No state file for '${op}' and not a branch name" >&2
      update_entry "${op}" "failed"
      return 1
    fi
  fi

  echo "[$(date +%H:%M:%S)] Processing merge: ${op}"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:started: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
  emit_event "merge:started" "${op}"

  # Get worktree path
  local worktree
  worktree=$(jq -r '.worktree // empty' "${state_file}")

  if [[ -z "${worktree}" ]] || [[ ! -d "${worktree}" ]]; then
    echo "Error: Worktree not found: ${worktree}" >&2
    update_entry "${op}" "failed"
    update_operation_state "${op}" "merge_status" '"failed"'
    update_operation_state "${op}" "merge_error" '"Worktree not found"'
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:failed: ${op} (worktree not found)" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:failed" "${op}"
    return 1
  fi

  # Update state to show merge in progress
  update_operation_state "${op}" "merge_status" '"merging"'

  # Try to merge using v0 merge - capture exit code correctly
  # Set V0_MERGEQ_CALLER to prevent duplicate queue updates
  set +e
  local merge_output
  merge_output=$(V0_MERGEQ_CALLER=1 "${V0_DIR}/bin/v0-merge" "${worktree}" 2>&1)
  local merge_exit=$?
  set -e

  # Log the output
  echo "${merge_output}" | tee -a "${MERGEQ_DIR}/logs/merges.log"

  if [[ ${merge_exit} -eq 0 ]]; then
    # v0-merge exited 0 - verify the merge actually happened
    # Give state file a moment to be written
    sleep 1

    if ! v0_verify_merge_by_op "${op}" "true"; then
      # Check WHY verification failed for better error messages
      local merge_commit
      merge_commit=$(sm_read_state "${op}" "merge_commit")

      if [[ -z "${merge_commit}" ]] || [[ "${merge_commit}" = "null" ]]; then
        echo "[$(date +%H:%M:%S)] Warning: v0-merge exited 0 but no merge_commit recorded"
        update_operation_state "${op}" "merge_error" '"No merge_commit in state - possible v0-merge bug"'
      else
        echo "[$(date +%H:%M:%S)] Warning: v0-merge exited 0 but commit ${merge_commit:0:8} not on ${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}"
        update_operation_state "${op}" "merge_error" "\"Commit ${merge_commit} not found on ${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}\""
      fi

      update_operation_state "${op}" "merge_status" '"verification_failed"'
      update_entry "${op}" "failed"
      echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:verification_failed: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
      emit_event "merge:verification_failed" "${op}"
      return 1
    fi

    # Verified - now mark as merged
    # Update state.json FIRST, then queue (to prevent race conditions)
    local merged_at
    merged_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    update_operation_state "${op}" "merge_status" '"merged"'
    update_operation_state "${op}" "merged_at" "\"${merged_at}\""
    update_operation_state "${op}" "phase" '"merged"'
    update_entry "${op}" "completed"  # Queue last
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:completed: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:completed" "${op}"
    echo "[$(date +%H:%M:%S)] Merge completed: ${op}"

    # Archive the plan file
    local plan_file
    plan_file=$(jq -r '.plan_file // empty' "${state_file}")
    if [[ -n "${plan_file}" ]]; then
      if archive_plan "${plan_file}"; then
        local archive_date
        archive_date=$(date +%Y-%m-%d)
        local plan_name
        plan_name=$(basename "${plan_file}")
        update_operation_state "${op}" "archived_plan" "\"${V0_PLANS_DIR}/archive/${archive_date}/${plan_name}\""
        echo "[$(date +%H:%M:%S)] Archived plan: ${plan_file}"
      fi
    fi

    # Trigger dependent operations
    local dep_op
    for dep_op in $(find_dependent_operations "${op}"); do
      echo "[$(date +%H:%M:%S)] Unblocking dependent operation: ${dep_op}"
      resume_waiting_operation "${dep_op}"
    done

    return 0
  else
    # Conflict detected - attempt automatic resolution
    echo "[$(date +%H:%M:%S)] Merge has conflicts, attempting automatic resolution..."
    echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:resolving: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
    emit_event "merge:resolving" "${op}"
    update_operation_state "${op}" "merge_status" '"resolving"'

    # Try automatic resolution with v0 merge --resolve
    # Set V0_MERGEQ_CALLER to prevent duplicate queue updates
    set +e
    local resolve_output
    resolve_output=$(V0_MERGEQ_CALLER=1 "${V0_DIR}/bin/v0-merge" "${worktree}" --resolve 2>&1)
    local resolve_exit=$?
    set -e

    echo "${resolve_output}" | tee -a "${MERGEQ_DIR}/logs/merges.log"

    if [[ ${resolve_exit} -eq 0 ]]; then
      # v0-merge exited 0 - verify the merge actually happened
      sleep 1

      if ! v0_verify_merge_by_op "${op}" "true"; then
        local merge_commit
        merge_commit=$(sm_read_state "${op}" "merge_commit")

        if [[ -z "${merge_commit}" ]] || [[ "${merge_commit}" = "null" ]]; then
          echo "[$(date +%H:%M:%S)] Warning: Resolution succeeded but no merge_commit recorded"
          update_operation_state "${op}" "merge_error" '"No merge_commit in state after resolution"'
        else
          echo "[$(date +%H:%M:%S)] Warning: Resolution succeeded but commit ${merge_commit:0:8} not on ${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}"
          update_operation_state "${op}" "merge_error" "\"Commit ${merge_commit} not found on ${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH} after resolution\""
        fi

        update_operation_state "${op}" "merge_status" '"verification_failed"'
        update_entry "${op}" "failed"
        echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:verification_failed: ${op} (after resolution)" >> "${MERGEQ_DIR}/logs/merges.log"
        emit_event "merge:verification_failed" "${op}"
        return 1
      fi

      # Verified - now mark as merged
      # Update state.json FIRST, then queue (to prevent race conditions)
      local merged_at
      merged_at=$(date -u +%Y-%m-%dT%H:%M:%SZ)
      update_operation_state "${op}" "merge_status" '"merged"'
      update_operation_state "${op}" "merged_at" "\"${merged_at}\""
      update_operation_state "${op}" "phase" '"merged"'
      update_entry "${op}" "completed"  # Queue last
      echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:completed: ${op} (after resolution)" >> "${MERGEQ_DIR}/logs/merges.log"
      emit_event "merge:completed" "${op}"
      echo "[$(date +%H:%M:%S)] Merge completed (after automatic resolution): ${op}"

      # Archive the plan file
      local plan_file
      plan_file=$(jq -r '.plan_file // empty' "${state_file}")
      if [[ -n "${plan_file}" ]]; then
        if archive_plan "${plan_file}"; then
          local archive_date
          archive_date=$(date +%Y-%m-%d)
          local plan_name
          plan_name=$(basename "${plan_file}")
          update_operation_state "${op}" "archived_plan" "\"${V0_PLANS_DIR}/archive/${archive_date}/${plan_name}\""
          echo "[$(date +%H:%M:%S)] Archived plan: ${plan_file}"
        fi
      fi

      # Trigger dependent operations
      local dep_op
      for dep_op in $(find_dependent_operations "${op}"); do
        echo "[$(date +%H:%M:%S)] Unblocking dependent operation: ${dep_op}"
        resume_waiting_operation "${dep_op}"
      done

      return 0
    else
      # Resolution failed
      update_entry "${op}" "conflict"
      update_operation_state "${op}" "merge_status" '"conflict"'
      update_operation_state "${op}" "merge_error" '"Automatic resolution failed"'
      echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] merge:conflict: ${op} (resolution failed)" >> "${MERGEQ_DIR}/logs/merges.log"
      emit_event "merge:conflict" "${op}"
      echo "[$(date +%H:%M:%S)] Automatic resolution failed: ${op}"
      echo "  Manual resolution needed: v0 merge ${worktree} --resolve"
      return 1
    fi
  fi
}

# process_once
# Process a single pending merge and exit
process_once() {
  ensure_queue_exists

  # Get next pending operation
  local op
  op=$(dequeue_merge) || {
    echo "No pending merges in queue"
    return 0
  }

  echo "Found pending merge: ${op}"

  # Check if it's ready
  if ! is_merge_ready "${op}"; then
    echo "Operation '${op}' is not ready to merge"
    return 1
  fi

  # Mark as processing
  update_entry "${op}" "processing"

  # Process the merge
  process_merge "${op}"
}

# get_all_pending
# Get all pending operations sorted by priority, then enqueue time
get_all_pending() {
  ensure_queue_exists
  jq -r '[.entries[] | select(.status == "pending")] | sort_by(.priority, .enqueued_at) | .[].operation' "${QUEUE_FILE}"
}

# get_all_conflicts
# Get all conflict operations
get_all_conflicts() {
  ensure_queue_exists
  jq -r '[.entries[] | select(.status == "conflict")] | .[].operation' "${QUEUE_FILE}"
}

# process_watch
# Continuous mode - poll for ready operations every 30 seconds
process_watch() {
  ensure_queue_exists

  local poll_interval=30

  echo "[$(date +%H:%M:%S)] Starting merge queue daemon (poll interval: ${poll_interval}s)"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] daemon:started" >> "${MERGEQ_DIR}/logs/merges.log"

  # Log clean exit on termination
  cleanup_daemon() {
    echo "[$(date +%H:%M:%S)] Stopping daemon"
    exit 0
  }
  trap cleanup_daemon INT TERM

  while true; do
    # Check for conflict entries that can be retried
    local conflict_ops
    conflict_ops=$(get_all_conflicts)
    for op in ${conflict_ops}; do
      local state_file="${BUILD_DIR}/operations/${op}/state.json"
      if [[ -f "${state_file}" ]]; then
        local conflict_retried
        conflict_retried=$(jq -r '.conflict_retried // false' "${state_file}" 2>/dev/null)
        if [[ "${conflict_retried}" != "true" ]]; then
          echo "[$(date +%H:%M:%S)] Auto-retrying conflict resolution: ${op}"
          # Mark as retried so we don't loop forever
          update_operation_state "${op}" "conflict_retried" "true"
          # Reset merge status so it will be retried
          update_operation_state "${op}" "merge_status" "null"
          # Reset queue entry to pending
          update_entry "${op}" "pending"
          echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] conflict:retry: ${op}" >> "${MERGEQ_DIR}/logs/merges.log"
        fi
      fi
    done

    # Get all pending operations and find the first ready one
    local found_ready=false
    local op
    local pending_ops
    pending_ops=$(get_all_pending)
    local pending_count
    if [[ -z "${pending_ops}" ]]; then
      pending_count=0
    else
      pending_count=$(echo "${pending_ops}" | wc -l | tr -d ' \n')
    fi

    if [[ "${pending_count}" -eq 0 ]]; then
      echo "[$(date +%H:%M:%S)] Waiting... (no pending merges)"
      sleep "${poll_interval}"
      continue
    fi

    local not_ready_reasons=""
    for op in ${pending_ops}; do
      # Check if entry is stale (already merged, branch deleted, etc.)
      local stale_reason
      if stale_reason=$(is_stale "${op}"); then
        echo "[$(date +%H:%M:%S)] Cleaning stale entry: ${op} (${stale_reason})"
        update_entry "${op}" "completed"
        echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] stale:cleaned: ${op} (${stale_reason})" >> "${MERGEQ_DIR}/logs/merges.log"
        continue
      fi

      # Check if it's ready (capture reason if not)
      local ready_check
      if ready_check=$(is_merge_ready "${op}" 2>&1); then
        echo "[$(date +%H:%M:%S)] Processing: ${op}"
        found_ready=true

        # Mark as processing
        update_entry "${op}" "processing"

        # Process the merge
        if process_merge "${op}"; then
          echo "[$(date +%H:%M:%S)] Successfully merged: ${op}"
        else
          echo "[$(date +%H:%M:%S)] Failed to merge: ${op}"
        fi

        # Small delay between merges
        sleep 2
        break
      else
        # Check if open issues and we haven't tried auto-resume yet
        if [[ "${ready_check}" == open_issues:* ]]; then
          local state_file="${BUILD_DIR}/operations/${op}/state.json"
          local already_resumed
          already_resumed=$(jq -r '.merge_resumed // false' "${state_file}" 2>/dev/null)

          # Extract counts for display
          local open_count in_progress_count
          open_count=$(echo "${ready_check}" | cut -d: -f2)
          in_progress_count=$(echo "${ready_check}" | cut -d: -f3)

          if [[ "${already_resumed}" != "true" ]]; then
            echo "[$(date +%H:%M:%S)] Auto-resuming ${op} (${open_count} open, ${in_progress_count} in progress)"

            # Mark as resumed so we don't do this again
            update_operation_state "${op}" "merge_resumed" "true"
            # Clear merge_queued so build can re-queue when done
            update_operation_state "${op}" "merge_queued" "false"
            # Remove from queue
            update_entry "${op}" "resumed"

            echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] auto-resume: ${op} (${open_count} open)" >> "${MERGEQ_DIR}/logs/merges.log"

            # Kick back to v0 feature --resume queued to restart worker
            # Use nohup so process survives if daemon restarts
            nohup "${V0_DIR}/bin/v0-feature" "${op}" --resume queued >> "${BUILD_DIR}/operations/${op}/logs/resume.log" 2>&1 &

            found_ready=true  # Don't sleep, check next immediately
            continue
          else
            ready_check="open issues (${open_count} open, ${in_progress_count} in progress) - already resumed once"
          fi
        fi

        # Collect not-ready reasons for status display
        not_ready_reasons="${not_ready_reasons}  - ${op}: ${ready_check}"$'\n'
      fi
    done

    if [[ "${found_ready}" = false ]]; then
      # Show why operations aren't ready
      echo "[$(date +%H:%M:%S)] Waiting... (${pending_count} pending, none ready)"
      if [[ -n "${not_ready_reasons}" ]]; then
        echo "${not_ready_reasons}" | head -5
        if [[ "${pending_count}" -gt 5 ]]; then
          echo "  ... and $((pending_count - 5)) more"
        fi
      fi
      sleep "${poll_interval}"
    fi
  done
}

# Main argument parsing
ACTION=""
OPERATION=""
STATUS=""
ISSUE_ID=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --start) ACTION="start"; shift ;;
    --once) ACTION="once"; shift ;;
    --watch) ACTION="watch"; shift ;;
    --status) ACTION="status"; shift ;;
    --list) ACTION="list"; shift ;;
    --stop) ACTION="stop"; shift ;;
    --add|--enqueue)
      ACTION="enqueue"
      OPERATION="$2"
      shift 2
      ;;
    --issue-id)
      ISSUE_ID="$2"
      shift 2
      ;;
    --dequeue) ACTION="dequeue"; shift ;;
    --update)
      ACTION="update"
      OPERATION="$2"
      STATUS="$3"
      shift 3
      ;;
    -h|--help) usage ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
  esac
done

# Default action
[[ -z "${ACTION}" ]] && ACTION="status"

# Execute action
case "${ACTION}" in
  start) start_daemon ;;
  status) show_status ;;
  list) list_entries ;;
  enqueue) enqueue_merge "${OPERATION}" 0 "${ISSUE_ID}" ;;
  dequeue) dequeue_merge ;;
  update) update_entry "${OPERATION}" "${STATUS}" ;;
  once) process_once ;;
  watch) process_watch ;;
  stop) stop_daemon ;;
  *) echo "Unknown action: ${ACTION}"; usage ;;
esac
