#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/lib/v0-common.sh"
v0_load_config

# Source coffee functions for status display
source "${V0_DIR}/lib/coffee-common.sh"

# Source nudge functions for status display
source "${V0_DIR}/lib/nudge-common.sh"

usage() {
  cat <<EOF
Usage: v0 status [name] [options]

Check status of build operations.

Options:
  --list         List all operations (default)
  --blocked      List only waiting operations (using --after)
  --merge        Show merge queue status
  --fix          Show fix worker status
  --chore        Show chore worker status
  --recent       Show recently completed bugs/chores
  --watch        Watch for live updates
  --json         Output as JSON

Examples:
  v0 status                # List all operations (default)
  v0 status auth           # Check auth operation
  v0 status --merge        # Show merge queue
  v0 status --fix          # Show fix worker status
  v0 status --chore        # Show chore worker status
  v0 status auth --watch   # Live updates

See also:
  v0 prune                 # Remove completed/cancelled operations
EOF
  exit 1
}

# Helper function to show bugs with indentation
show_bugs_indented() {
  local limit="$1"
  local in_progress open

  in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
  open=$(wk list --type bug --status todo 2>/dev/null || true)

  if [[ -z "${in_progress}" ]] && [[ -z "${open}" ]]; then
    echo -e "  Bugs: ${C_DIM}none${C_RESET}"
    return
  fi

  if [[ -n "${in_progress}" ]]; then
    local count
    count=$(echo "${in_progress}" | wc -l | tr -d ' ')
    echo -e "  ${C_DIM}In progress:${C_RESET}"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${in_progress}" | sed 's/^/    /'
    else
      echo "${in_progress}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi

  if [[ -n "${open}" ]]; then
    local count
    count=$(echo "${open}" | wc -l | tr -d ' ')
    echo -e "  ${C_DIM}Queued:${C_RESET}"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${open}" | sed 's/^/    /'
    else
      echo "${open}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi
}

# Helper function to show merge queue with indentation
show_mergeq_indented() {
  local limit="$1"
  local queue_file="${BUILD_DIR}/mergeq/queue.json"

  if [[ ! -f "${queue_file}" ]]; then
    echo -e "  Merges: ${C_DIM}none${C_RESET}"
    return
  fi

  local entries total
  entries=$(jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${queue_file}" 2>/dev/null || true)

  if [[ -z "${entries}" ]]; then
    echo -e "  Merges: ${C_DIM}none${C_RESET}"
  else
    total=$(echo "${entries}" | wc -l | tr -d ' ')

    echo "  Merges:"
    if [[ "${total}" -le "${limit}" ]]; then
      echo "${entries}" | while IFS=$'\t' read -r status op; do
        local status_color="${C_CYAN}"
        [[ "${status}" = "pending" ]] && status_color=""
        printf "    ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
      done
    else
      echo "${entries}" | head -n "${limit}" | while IFS=$'\t' read -r status op; do
        local status_color="${C_CYAN}"
        [[ "${status}" = "pending" ]] && status_color=""
        printf "    ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
      done
      local remaining=$((total - limit))
      echo -e "    ${C_DIM}... and ${remaining} more in queue${C_RESET}"
    fi
  fi
}

# Helper function to show chores with indentation
show_chores_indented() {
  local limit="$1"
  local in_progress open

  in_progress=$(wk list --type chore --status in_progress 2>/dev/null || true)
  open=$(wk list --type chore --status todo 2>/dev/null || true)

  if [[ -z "${in_progress}" ]] && [[ -z "${open}" ]]; then
    echo -e "  Chores: ${C_DIM}none${C_RESET}"
    return
  fi

  if [[ -n "${in_progress}" ]]; then
    local count
    count=$(echo "${in_progress}" | wc -l | tr -d ' ')
    echo -e "  ${C_DIM}In progress:${C_RESET}"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${in_progress}" | sed 's/^/    /'
    else
      echo "${in_progress}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi

  if [[ -n "${open}" ]]; then
    local count
    count=$(echo "${open}" | wc -l | tr -d ' ')
    echo -e "  ${C_DIM}Queued:${C_RESET}"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${open}" | sed 's/^/    /'
    else
      echo "${open}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi
}

# Convert ISO 8601 timestamp to epoch (macOS compatible)
# Note: Timestamps with Z suffix are UTC, so we parse in UTC timezone
timestamp_to_epoch() {
  local ts="$1"
  local formatted
  formatted=$(echo "${ts}" | sed 's/T/ /; s/Z$//; s/\.[0-9]*//')
  TZ=UTC date -j -f "%Y-%m-%d %H:%M:%S" "${formatted}" +%s 2>/dev/null
}

# Format elapsed time as human-readable string
format_elapsed() {
  local seconds="$1"
  if [[ "${seconds}" -lt 60 ]]; then
    echo "just now"
  elif [[ "${seconds}" -lt 3600 ]]; then
    local mins=$((seconds / 60))
    echo "${mins} min ago"
  elif [[ "${seconds}" -lt 86400 ]]; then
    local hours=$((seconds / 3600))
    echo "${hours} hr ago"
  else
    local days=$((seconds / 86400))
    echo "${days} day ago"
  fi
}

# Format operation timestamp for display
# Shows relative time for recent operations (< 12 hours), date for older ones
# Args: $1 = ISO 8601 timestamp (UTC with Z suffix)
format_operation_time() {
  local ts="$1"
  local ts_epoch now_epoch elapsed

  ts_epoch=$(timestamp_to_epoch "${ts}")
  if [[ -z "${ts_epoch}" ]]; then
    # Fallback: return first 10 chars (YYYY-MM-DD) if parsing fails
    echo "${ts:0:10}"
    return
  fi

  now_epoch=$(date +%s)
  elapsed=$((now_epoch - ts_epoch))

  # 12 hours = 43200 seconds
  if [[ "${elapsed}" -lt 43200 ]]; then
    format_elapsed "${elapsed}"
  else
    # Convert UTC timestamp to local date
    # Use the epoch value to get local date
    date -r "${ts_epoch}" +%Y-%m-%d 2>/dev/null || echo "${ts:0:10}"
  fi
}

# Show active goals (only planning/orchestrating phases)
# Returns: 0 if goals were displayed, 1 if no active goals
show_active_goals() {
  local goal_dir="${BUILD_DIR}/goals"
  [[ ! -d "${goal_dir}" ]] && return 1

  local active_goals=()
  local local_machine
  local_machine=$(hostname -s)

  for state_file in "${goal_dir}"/*/state.json; do
    [[ ! -f "${state_file}" ]] && continue

    local phase name desc idea_id worker_pid machine session
    phase=$(jq -r '.phase // empty' "${state_file}")

    # Only show during planning/orchestrating phases
    if [[ "${phase}" = "planning" ]] || [[ "${phase}" = "orchestrating" ]] || [[ "${phase}" = "init" ]]; then
      name=$(jq -r '.name // empty' "${state_file}")
      desc=$(jq -r '.goal_description // empty' "${state_file}")
      idea_id=$(jq -r '.idea_id // empty' "${state_file}")
      worker_pid=$(jq -r '.worker_pid // empty' "${state_file}")
      machine=$(jq -r '.machine // empty' "${state_file}")
      session=$(jq -r '.planning_session // empty' "${state_file}")

      # Truncate description for display
      local desc_short="${desc:0:40}"
      [[ ${#desc} -gt 40 ]] && desc_short="${desc_short}..."

      # Check if session is running
      local status_icon=""
      if [[ -n "${session}" ]] && [[ "${session}" != "null" ]] && tmux has-session -t "${session}" 2>/dev/null; then
        status_icon=" ${C_CYAN}(active)${C_RESET}"
      elif [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
        if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
          status_icon=" ${C_CYAN}(bg-worker)${C_RESET}"
        fi
      fi

      active_goals+=("${name}|${phase}|${desc_short}|${idea_id}|${status_icon}")
    fi
  done

  if [[ ${#active_goals[@]} -eq 0 ]]; then
    return 1
  fi

  echo ""
  echo "Goals:"
  for goal_data in "${active_goals[@]}"; do
    IFS='|' read -r name phase desc idea_id status_icon <<< "${goal_data}"
    local phase_color=""
    case "${phase}" in
      planning) phase_color="${C_YELLOW}" ;;
      orchestrating) phase_color="${C_CYAN}" ;;
      init) phase_color="${C_DIM}" ;;
    esac
    printf "  %-20s ${phase_color}%-15s${C_RESET}%b  %s\n" "${name}:" "${phase}" "${status_icon}" "${C_DIM}(${desc})${C_RESET}"
    [[ -n "${idea_id}" ]] && [[ "${idea_id}" != "null" ]] && printf "  %-20s %s\n" "" "${C_DIM}[${idea_id}]${C_RESET}"
  done

  return 0
}

# Get the most relevant timestamp for display based on current state
# Arguments: phase, created_at, completed_at, merged_at, held_at
# Output: The most appropriate timestamp for display
get_last_updated_timestamp() {
  local phase="$1"
  local created_at="$2"
  local completed_at="$3"
  local merged_at="$4"
  local held_at="$5"

  case "${phase}" in
    merged)
      # Prefer merged_at, fall back to completed_at, then created_at
      if [[ -n "${merged_at}" && "${merged_at}" != "null" ]]; then
        echo "${merged_at}"
      elif [[ -n "${completed_at}" && "${completed_at}" != "null" ]]; then
        echo "${completed_at}"
      else
        echo "${created_at}"
      fi
      ;;
    completed|pending_merge)
      # Show when it was completed
      if [[ -n "${completed_at}" && "${completed_at}" != "null" ]]; then
        echo "${completed_at}"
      else
        echo "${created_at}"
      fi
      ;;
    held)
      # Show when it was put on hold
      if [[ -n "${held_at}" && "${held_at}" != "null" ]]; then
        echo "${held_at}"
      else
        echo "${created_at}"
      fi
      ;;
    *)
      # For init, planned, queued, executing, etc. - use created_at
      echo "${created_at}"
      ;;
  esac
}

# Get recently merged operations (features/builds)
# Args: $1 = hours to look back (default: 72)
# Output: name|merged_at (one per line, sorted most recent first)
get_merged_operations() {
  local since_hours="${1:-72}"
  local cutoff_time
  cutoff_time=$(date -v-"${since_hours}"H +%s 2>/dev/null || date -d "${since_hours} hours ago" +%s 2>/dev/null || echo 0)

  if [[ ! -d "${BUILD_DIR}/operations" ]]; then
    return
  fi

  # Phase 4 optimization: Single jq -s for all files instead of N separate calls
  # Use compgen to check for glob matches (bash 3.2 compatible)
  if compgen -G "${BUILD_DIR}/operations/*/state.json" > /dev/null 2>&1; then
    jq -rs '.[] | select(.merge_status == "merged" and .merged_at != null) | "\(.name)|\(.merged_at)"' \
      "${BUILD_DIR}"/operations/*/state.json 2>/dev/null | while IFS='|' read -r name merged_at; do
      [[ -z "${name}" ]] && continue
      # Timestamp filtering still in bash (macOS date compatibility)
      local merged_epoch
      merged_epoch=$(timestamp_to_epoch "${merged_at}")
      if [[ -n "${merged_epoch}" ]] && [[ "${merged_epoch}" -ge "${cutoff_time}" ]]; then
        echo "${name}|${merged_at}"
      fi
    done | sort -t'|' -k2 -r
  fi
}

# Get recently completed bugs
# Args: $1 = hours to look back (default: 72), $2 = max results (optional)
# Output: id|title|updated_at (one per line, filtered by recency)
get_completed_bugs() {
  local since_hours="${1:-72}"
  local limit="${2:-}"

  local json_output limit_arg=""
  [[ -n "${limit}" ]] && limit_arg="--limit ${limit}"
  # Use wk list filter to efficiently get only recently updated bugs
  json_output=$(wk list --type bug --status "done" --format json -q "updated < ${since_hours}h" ${limit_arg:+"${limit_arg}"} 2>/dev/null) || return
  [[ -z "${json_output}" ]] && return

  # wk list --format json doesn't include updated_at, so we fetch from wk show for display
  echo "${json_output}" | jq -r '.issues[] | .id' 2>/dev/null | while read -r id; do
    [[ -z "${id}" ]] && continue
    local issue_json title updated_at
    issue_json=$(wk show "${id}" --format json 2>/dev/null) || continue
    title=$(echo "${issue_json}" | jq -r '.title // .summary // "Untitled"' 2>/dev/null)
    updated_at=$(echo "${issue_json}" | jq -r '.updated_at // .closed_at // ""' 2>/dev/null)
    echo "${id}|${title}|${updated_at}"
  done
}

# Get recently completed chores
# Args: $1 = hours to look back (default: 72), $2 = max results (optional)
# Output: id|title|updated_at (one per line, filtered by recency)
get_completed_chores() {
  local since_hours="${1:-72}"
  local limit="${2:-}"

  local json_output limit_arg=""
  [[ -n "${limit}" ]] && limit_arg="--limit ${limit}"
  # Use wk list filter to efficiently get only recently updated chores
  json_output=$(wk list --type chore --status "done" --format json -q "updated < ${since_hours}h" ${limit_arg:+"${limit_arg}"} 2>/dev/null) || return
  [[ -z "${json_output}" ]] && return

  # wk list --format json doesn't include updated_at, so we fetch from wk show for display
  echo "${json_output}" | jq -r '.issues[] | .id' 2>/dev/null | while read -r id; do
    [[ -z "${id}" ]] && continue
    local issue_json title updated_at
    issue_json=$(wk show "${id}" --format json 2>/dev/null) || continue
    title=$(echo "${issue_json}" | jq -r '.title // .summary // "Untitled"' 2>/dev/null)
    updated_at=$(echo "${issue_json}" | jq -r '.updated_at // .closed_at // ""' 2>/dev/null)
    echo "${id}|${title}|${updated_at}"
  done
}

# Show recently completed section in status output
# Args: $1 = max items per category (default: 5)
show_recently_completed() {
  local max_items="${1:-5}"
  local completed_bugs completed_chores

  # Fetch data first to check if there's anything to show
  completed_bugs=$(get_completed_bugs 72 $((max_items + 1)))
  completed_chores=$(get_completed_chores 72 $((max_items + 1)))

  # If nothing to show, omit the entire section
  if [[ -z "${completed_bugs}" ]] && [[ -z "${completed_chores}" ]]; then
    return
  fi

  echo ""
  echo "Recently Completed:"

  # Show completed bugs
  if [[ -n "${completed_bugs}" ]]; then
    echo "  Bugs:"
    echo "${completed_bugs}" | head -n "${max_items}" | while IFS='|' read -r id title updated_at; do
      local display_title="${title:0:50}"
      [[ ${#title} -gt 50 ]] && display_title="${display_title}..."
      if [[ -n "${updated_at}" ]]; then
        local now_epoch updated_epoch elapsed_sec elapsed
        now_epoch=$(date +%s)
        updated_epoch=$(timestamp_to_epoch "${updated_at}")
        if [[ -n "${updated_epoch}" ]] && [[ "${updated_epoch}" -gt 0 ]]; then
          elapsed_sec=$((now_epoch - updated_epoch))
          elapsed=$(format_elapsed "${elapsed_sec}")
          echo "    - ${id}: ${display_title} (${elapsed})"
        else
          echo "    - ${id}: ${display_title}"
        fi
      else
        echo "    - ${id}: ${display_title}"
      fi
    done
    local total
    total=$(echo "${completed_bugs}" | wc -l | tr -d ' ')
    if [[ "${total}" -gt "${max_items}" ]]; then
      echo "    ... and more"
    fi
  fi

  # Show completed chores
  if [[ -n "${completed_chores}" ]]; then
    echo "  Chores:"
    echo "${completed_chores}" | head -n "${max_items}" | while IFS='|' read -r id title updated_at; do
      local display_title="${title:0:50}"
      [[ ${#title} -gt 50 ]] && display_title="${display_title}..."
      if [[ -n "${updated_at}" ]]; then
        local now_epoch updated_epoch elapsed_sec elapsed
        now_epoch=$(date +%s)
        updated_epoch=$(timestamp_to_epoch "${updated_at}")
        if [[ -n "${updated_epoch}" ]] && [[ "${updated_epoch}" -gt 0 ]]; then
          elapsed_sec=$((now_epoch - updated_epoch))
          elapsed=$(format_elapsed "${elapsed_sec}")
          echo "    - ${id}: ${display_title} (${elapsed})"
        else
          echo "    - ${id}: ${display_title}"
        fi
      else
        echo "    - ${id}: ${display_title}"
      fi
    done
    local total
    total=$(echo "${completed_chores}" | wc -l | tr -d ' ')
    if [[ "${total}" -gt "${max_items}" ]]; then
      echo "    ... and more"
    fi
  fi
}

NAME=""
LIST=""
BLOCKED=""
MERGE_QUEUE=""
BUGFIX=""
CHORE=""
WATCH=""
JSON=""
RECENT=""
NO_HINTS=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --list) LIST=1; shift ;;
    --blocked) BLOCKED=1; shift ;;
    --merge) MERGE_QUEUE=1; shift ;;
    --fix) FIX=1; shift ;;
    --bugfix) FIX=1; shift ;;  # Backwards compatibility
    --chore) CHORE=1; shift ;;
    --watch) WATCH=1; shift ;;
    --json) JSON=1; shift ;;
    --recent) RECENT=1; shift ;;
    --no-hints) NO_HINTS=1; shift ;;
    --prune|--prune-all)
      echo "Warning: $1 is deprecated. Use 'v0 prune' instead." >&2
      exec "${V0_DIR}/bin/v0-prune" "$@"
      ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *) NAME="$1"; shift ;;
  esac
done

# Show merge queue status
if [[ -n "${MERGE_QUEUE}" ]]; then
  echo "Merge Queue Status:"
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --status
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --list
  exit 0
fi

# Show fix status (condensed view)
if [[ -n "${FIX}" ]]; then
  # Use namespaced session names based on PROJECT
  fix_session="v0-${PROJECT}-worker-fix"
  fix_polling_log="/tmp/v0-${PROJECT}-fix-polling.log"

  # Check worker and polling daemon status
  fix_worker_running=false
  fix_polling_pid=""

  tmux has-session -t "${fix_session}" 2>/dev/null && fix_worker_running=true
  [[ -f "${fix_polling_log}" ]] && fix_polling_pid=$(pgrep -f "while true.*${fix_session}" 2>/dev/null || true)

  if [[ "${fix_worker_running}" = true ]]; then
    echo -e "Fix Worker: ${C_CYAN}Active${C_RESET} ${C_DIM}[tmux: ${fix_session}] Attach with: v0 attach fix${C_RESET}"
  elif [[ -n "${fix_polling_pid}" ]]; then
    echo -e "Fix Worker: ${C_YELLOW}Polling${C_RESET} ${C_DIM}[pid: ${fix_polling_pid}]${C_RESET}"
  else
    echo -e "Fix Worker: ${C_DIM}Stopped${C_RESET}"
  fi

  in_progress_bugs=$(wk list --type bug --status in_progress 2>/dev/null || true)
  open_bugs=$(wk list --type bug --status todo 2>/dev/null || true)

  if [[ -z "${in_progress_bugs}" ]] && [[ -z "${open_bugs}" ]]; then
    echo ""
    echo "No bugs available"
  else
    shown=3

    if [[ -n "${in_progress_bugs}" ]]; then
      echo ""
      echo -e "${C_DIM}In Progress:${C_RESET}"
      count=$(echo "${in_progress_bugs}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${in_progress_bugs}" | sed 's/^/  /'
      else
        echo "${in_progress_bugs}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi

    if [[ -n "${open_bugs}" ]]; then
      echo ""
      echo -e "${C_DIM}Queued:${C_RESET}"
      count=$(echo "${open_bugs}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${open_bugs}" | sed 's/^/  /'
      else
        echo "${open_bugs}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi
  fi
  exit 0
fi

# Show chore status (condensed view)
if [[ -n "${CHORE}" ]]; then
  # Use namespaced session names based on PROJECT
  chore_session="v0-${PROJECT}-worker-chore"
  chore_polling_log="/tmp/v0-${PROJECT}-chore-polling.log"

  # Check worker and polling daemon status
  chore_worker_running=false
  chore_polling_pid=""

  tmux has-session -t "${chore_session}" 2>/dev/null && chore_worker_running=true
  [[ -f "${chore_polling_log}" ]] && chore_polling_pid=$(pgrep -f "while true.*${chore_session}" 2>/dev/null || true)

  if [[ "${chore_worker_running}" = true ]]; then
    echo -e "Chore Worker: ${C_CYAN}Active${C_RESET} ${C_DIM}[tmux: ${chore_session}] Attach with: v0 attach chore${C_RESET}"
  elif [[ -n "${chore_polling_pid}" ]]; then
    echo -e "Chore Worker: ${C_YELLOW}Polling${C_RESET} ${C_DIM}[pid: ${chore_polling_pid}]${C_RESET}"
  else
    echo -e "Chore Worker: ${C_DIM}Stopped${C_RESET}"
  fi

  in_progress_chores=$(wk list --type chore --status in_progress 2>/dev/null || true)
  open_chores=$(wk list --type chore --status todo 2>/dev/null || true)

  if [[ -z "${in_progress_chores}" ]] && [[ -z "${open_chores}" ]]; then
    echo ""
    echo "No chores available"
  else
    shown=3

    if [[ -n "${in_progress_chores}" ]]; then
      echo ""
      echo -e "${C_DIM}In Progress:${C_RESET}"
      count=$(echo "${in_progress_chores}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${in_progress_chores}" | sed 's/^/  /'
      else
        echo "${in_progress_chores}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi

    if [[ -n "${open_chores}" ]]; then
      echo ""
      echo -e "${C_DIM}Queued:${C_RESET}"
      count=$(echo "${open_chores}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${open_chores}" | sed 's/^/  /'
      else
        echo "${open_chores}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi
  fi
  exit 0
fi

# Default to --list if no arguments
if [[ -z "${NAME}" ]]; then
  LIST=1
fi

# List all operations (default behavior)
if [[ -n "${LIST}" ]] || [[ -n "${BLOCKED}" ]]; then
  # Batch tmux session check - single call to list all sessions (used by operations loop and workers)
  all_sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

  # Pre-check if operations directory exists and has state files
  has_operations=false
  if [[ -d "${BUILD_DIR}/operations" ]]; then
    for f in "${BUILD_DIR}"/operations/*/state.json; do
      [[ -f "${f}" ]] && has_operations=true && break
    done
  fi

  # If no operations, show compact "None" format like other sections
  if [[ "${has_operations}" = false ]]; then
    if [[ -n "${BLOCKED}" ]]; then
      echo -e "Blocked Operations: ${C_DIM}None${C_RESET}"
    else
      echo -e "Operations: ${C_DIM}None${C_RESET}"
    fi
  else
    # Operations exist - show full format with header and details
    if [[ -n "${BLOCKED}" ]]; then
      echo "Blocked Operations:"
    else
      echo "Operations:"
    fi
    echo ""

  local_machine=$(hostname -s)

  # Collect all state files (bash 3.2 compatible)
  state_files=()
  for f in "${BUILD_DIR}"/operations/*/state.json; do
    [[ -f "${f}" ]] && state_files+=("${f}")
  done

  found_any=""
  # max_name_display is the truncation limit for long names
  max_name_display=40
  # max_name_len is calculated in jq below (Phase 3 optimization - single pass)

  # Merge queue file path for timestamp lookups (used in display loop)
  mergeq_file="${BUILD_DIR}/mergeq/queue.json"

  # Pre-fetch queue data for O(1) lookups in loop (Phase 1 optimization)
  # Format: operation\tstatus\tupdated_at
  queue_cache=$(mktemp)
  # shellcheck disable=SC2064  # Intentional: capture temp file path at trap time
  trap "rm -f '${queue_cache}'" EXIT
  if [[ -f "${mergeq_file}" ]]; then
    jq -r '.entries[] | [.operation, .status, (.updated_at // "")] | @tsv' "${mergeq_file}" > "${queue_cache}" 2>/dev/null || true
  fi

  # Process all state files in single jq -s invocation (one process instead of many)
  # Phase 3 optimization: also calculates max_name_len in same pass (META line first)
  max_name_len=8  # Default minimum
  if [[ ${#state_files[@]} -gt 0 ]]; then
    while IFS=$'\t' read -r name op_type phase created machine completed merge_queued merge_status merged_at completed_at after session worker_pid held held_at; do
      # Handle META line for max name length (Phase 3)
      if [[ "${name}" = "META" ]]; then
        max_name_len="${op_type}"  # op_type field contains max_name_len for META
        [[ ${max_name_len} -lt 8 ]] && max_name_len=8
        continue
      fi
      [[ -z "${name}" ]] && continue
    # If --blocked filter, skip non-blocked operations
    if [[ -n "${BLOCKED}" ]]; then
      if [[ -z "${after}" ]] || [[ "${after}" = "null" ]]; then
        continue
      fi
    fi

    found_any=1

    # Check if session is running - uses batched all_sessions
    # Note: all_sessions only contains LOCAL tmux sessions, so if we find a match,
    # it's definitely running locally regardless of the machine field in state.json
    status_icon=""
    if [[ -n "${session}" ]] && [[ "${session}" != "null" ]] && [[ "${all_sessions}" == *"${session}"* ]]; then
      status_icon=" ${C_CYAN}(active)${C_RESET}"
    fi
    # Check if background worker is running
    if [[ -z "${status_icon}" ]] && [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
      if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
        status_icon=" ${C_CYAN}(bg-worker)${C_RESET}"
      fi
    fi

    # Add after indicator (only show for phases where operation is still waiting)
    after_icon=""
    if [[ -n "${after}" ]] && [[ "${after}" != "null" ]]; then
      case "${phase}" in
        executing|completed|pending_merge|merged|cancelled)
          # Don't show [after] for these phases - operation is already past waiting
          ;;
        *)
          after_icon=" ${C_YELLOW}[after ${after}]${C_RESET}"
          ;;
      esac
    fi

    # Add hold indicator
    hold_icon=""
    if [[ "${held}" = "true" ]]; then
      hold_icon=" ${C_YELLOW}[HELD]${C_RESET}"
    fi

    # Get queue entry status for merge display (only needed when merge_queued)
    # Uses pre-fetched queue_cache for O(1) lookup instead of jq per operation
    queue_entry_status=""
    if [[ "${merge_queued}" = "true" ]] && [[ -s "${queue_cache}" ]]; then
      queue_entry_status=$(grep "^${name}"$'\t' "${queue_cache}" 2>/dev/null | cut -f2 || true)
    fi

    # Use shared helper for phase display formatting
    IFS='|' read -r raw_display raw_merge_icon <<< \
      "$(_sm_format_phase_display "${phase}" "${op_type}" "${merge_queued}" "${merge_status}" "${merged_at}" "${queue_entry_status}")"

    # Get colors for display
    phase_color=$(_sm_get_phase_color "${raw_display}" "${raw_merge_icon}")
    merge_color=$(_sm_get_merge_icon_color "${raw_merge_icon}")

    # Apply colors to display_phase
    if [[ -n "${phase_color}" ]]; then
      display_phase="$(sm_get_status_color "${phase_color}")${raw_display}${C_RESET}"
    else
      display_phase="${raw_display}"
    fi

    # Apply colors to merge_icon
    merge_icon=""
    if [[ -n "${raw_merge_icon}" ]]; then
      if [[ -n "${merge_color}" ]]; then
        # Special formatting for certain merge icons
        case "${raw_merge_icon}" in
          "[merged]")
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_DIM}${raw_merge_icon}${C_RESET}"
            ;;
          "(== MERGE FAILED =="*|"(== CONFLICT =="*|"(== NEEDS MERGE =="*)
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_BOLD}${raw_merge_icon}${C_RESET}"
            ;;
          *)
            merge_icon=" $(sm_get_status_color "${merge_color}")${raw_merge_icon}${C_RESET}"
            ;;
        esac
      else
        merge_icon=" ${raw_merge_icon}"
      fi
    fi

    # Update status_icon for specific phase/activity combinations
    # Use () for active status indicators, [] for conditions like [HELD] or [after ...]
    case "${phase}" in
      init)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(planning...)${C_RESET}"
        ;;
      planned)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(decomposing...)${C_RESET}"
        ;;
      queued|executing)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_CYAN}(building...)${C_RESET}"
        ;;
      blocked)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(waiting...)${C_RESET}"
        ;;
      failed)
        status_icon=" ${C_RED}${C_BOLD}(== ERROR ==)${C_RESET}"
        ;;
      interrupted)
        status_icon=" ${C_RED}${C_BOLD}(== INTERRUPTED ==)${C_RESET}"
        ;;
    esac

    # Truncate long names with "..." (max_name_display - 1 for ":" suffix, - 3 for "...")
    display_name="${name}:"
    if [[ ${#display_name} -gt ${max_name_display} ]]; then
      display_name="${name:0:$((max_name_display - 4))}...:"
    fi
    # Get the most relevant timestamp based on operation phase
    last_updated=$(get_last_updated_timestamp "${phase}" "${created}" "${completed_at}" "${merged_at}" "${held_at}")
    # Override with merge queue timestamp if available and operation is merged
    # Uses pre-fetched queue_cache for O(1) lookup instead of jq per operation
    if [[ "${phase}" == "merged" ]] && [[ -s "${queue_cache}" ]]; then
      mq_updated=$(grep "^${name}"$'\t'"completed"$'\t' "${queue_cache}" 2>/dev/null | cut -f3 || true)
      if [[ -n "${mq_updated}" ]]; then
        last_updated="${mq_updated}"
      fi
    fi
    display_time=$(format_operation_time "${last_updated}")
    printf "  %-${max_name_len}s %b%b%b%b%b ${C_DIM}(%s)${C_RESET}\n" "${display_name}" "${display_phase}" "${status_icon}" "${after_icon}" "${hold_icon}" "${merge_icon}" "${display_time}"
    done < <(jq -rs '
      # Phase 3: Calculate max name length in same pass (output META line first)
      # max_name_len = max of min(name_length + 1, 40) for all ops
      (reduce .[] as $op (0; [., ([($op.name | length) + 1, 40] | min)] | max)) as $max_len |
      # Output META line with max_name_len
      (["META", $max_len] | @tsv),
      # Then output all operation data
      (sort_by(.created_at) | .[] | [
        .name,
        (.type // "build"),
        .phase,
        .created_at,
        (.machine // "unknown"),
        (.completed | length),
        (.merge_queued // false),
        (.merge_status // "null"),
        (.merged_at // "null"),
        (.completed_at // "null"),
        (.after // "null"),
        (.tmux_session // "null"),
        (.worker_pid // "null"),
        (.held // false),
        (.held_at // "null")
      ] | @tsv)
    ' "${state_files[@]}")
  fi

  # For --blocked filter: show message if operations exist but none are blocked
  if [[ -z "${found_any}" ]] && [[ -n "${BLOCKED}" ]]; then
    echo -e "  ${C_DIM}(no waiting operations)${C_RESET}"
  fi
  fi  # end: has_operations = true

  # Show active goals (only during planning/orchestrating phases)
  if [[ -z "${BLOCKED}" ]]; then
    show_active_goals || true
  fi

  # Show fix, chore, and merge worker status in default list (not blocked view)
  if [[ -z "${BLOCKED}" ]]; then
    # Use namespaced session names based on PROJECT
    fix_session="v0-${PROJECT}-worker-fix"
    fix_polling_log="/tmp/v0-${PROJECT}-fix-polling.log"
    chore_session="v0-${PROJECT}-worker-chore"
    chore_polling_log="/tmp/v0-${PROJECT}-chore-polling.log"

    # Batch pgrep for all polling daemons - single call
    all_polling=$(pgrep -af "while true.*v0-${PROJECT}" 2>/dev/null || true)

    # Pre-check if all work queues are empty
    bugs_in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
    bugs_open=$(wk list --type bug --status todo 2>/dev/null || true)
    chores_in_progress=$(wk list --type chore --status in_progress 2>/dev/null || true)
    chores_open=$(wk list --type chore --status todo 2>/dev/null || true)
    mergeq_queue_file="${BUILD_DIR}/mergeq/queue.json"
    # Single read for all merge queue data (Phase 2 optimization)
    # Format: status\toperation - used for display and counts
    mergeq_entries=""
    merges_pending=""
    if [[ -f "${mergeq_queue_file}" ]]; then
      mergeq_entries=$(jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${mergeq_queue_file}" 2>/dev/null || true)
      # Derive operation list for backwards compatibility with merges_empty check
      merges_pending=$(echo "${mergeq_entries}" | cut -f2 | grep -v '^$' || true)
    fi

    bugs_empty=false
    chores_empty=false
    merges_empty=false
    [[ -z "${bugs_in_progress}" ]] && [[ -z "${bugs_open}" ]] && bugs_empty=true
    [[ -z "${chores_in_progress}" ]] && [[ -z "${chores_open}" ]] && chores_empty=true
    [[ -z "${merges_pending}" ]] && merges_empty=true

    # If all queues are empty, show each on its own line
    if [[ "${bugs_empty}" = true ]] && [[ "${chores_empty}" = true ]] && [[ "${merges_empty}" = true ]]; then
      [[ "${has_operations}" = true ]] && echo ""
      echo -e "Bugfix: ${C_DIM}None${C_RESET}"
      echo -e "Chores: ${C_DIM}None${C_RESET}"
      echo -e "Merges: ${C_DIM}None${C_RESET}"
    else
      # Show full sections for non-empty queues
      echo ""

      # Bugfix section
      fix_worker_running=false
      fix_polling_pid=""
      [[ "${all_sessions}" == *"${fix_session}"* ]] && fix_worker_running=true
      [[ -f "${fix_polling_log}" ]] && fix_polling_pid=$(echo "${all_polling}" | grep "worker-fix" | awk '{print $1}')
      if [[ "${fix_worker_running}" = true ]]; then
        echo -e "Bugfix: ${C_CYAN}Active${C_RESET}"
      elif [[ -n "${fix_polling_pid}" ]]; then
        echo -e "Bugfix: ${C_YELLOW}Polling${C_RESET}"
      elif [[ "${bugs_empty}" = true ]]; then
        echo -e "Bugfix: ${C_DIM}None${C_RESET}"
      else
        echo -e "Bugfix: ${C_RED}Stopped${C_RESET}"
      fi
      if [[ "${bugs_empty}" != true ]]; then
        if [[ -n "${bugs_in_progress}" ]]; then
          count=$(echo "${bugs_in_progress}" | wc -l | tr -d ' ')
          echo -e "  ${C_DIM}In progress:${C_RESET}"
          if [[ "${count}" -le 3 ]]; then
            echo "${bugs_in_progress}" | sed 's/^/    /'
          else
            echo "${bugs_in_progress}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
        if [[ -n "${bugs_open}" ]]; then
          count=$(echo "${bugs_open}" | wc -l | tr -d ' ')
          echo -e "  ${C_DIM}Queued:${C_RESET}"
          if [[ "${count}" -le 3 ]]; then
            echo "${bugs_open}" | sed 's/^/    /'
          else
            echo "${bugs_open}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
      fi
      [[ "${bugs_empty}" != true ]] && echo ""

      # Chores section
      chore_worker_running=false
      chore_polling_pid=""
      [[ "${all_sessions}" == *"${chore_session}"* ]] && chore_worker_running=true
      [[ -f "${chore_polling_log}" ]] && chore_polling_pid=$(echo "${all_polling}" | grep "worker-chore" | awk '{print $1}')
      if [[ "${chore_worker_running}" = true ]]; then
        echo -e "Chores: ${C_CYAN}Active${C_RESET}"
      elif [[ -n "${chore_polling_pid}" ]]; then
        echo -e "Chores: ${C_YELLOW}Polling${C_RESET}"
      elif [[ "${chores_empty}" = true ]]; then
        echo -e "Chores: ${C_DIM}None${C_RESET}"
      else
        echo -e "Chores: ${C_RED}Stopped${C_RESET}"
      fi
      if [[ "${chores_empty}" != true ]]; then
        if [[ -n "${chores_in_progress}" ]]; then
          count=$(echo "${chores_in_progress}" | wc -l | tr -d ' ')
          echo -e "  ${C_DIM}In progress:${C_RESET}"
          if [[ "${count}" -le 3 ]]; then
            echo "${chores_in_progress}" | sed 's/^/    /'
          else
            echo "${chores_in_progress}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
        if [[ -n "${chores_open}" ]]; then
          count=$(echo "${chores_open}" | wc -l | tr -d ' ')
          echo -e "  ${C_DIM}Queued:${C_RESET}"
          if [[ "${count}" -le 3 ]]; then
            echo "${chores_open}" | sed 's/^/    /'
          else
            echo "${chores_open}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
      fi
      [[ "${chores_empty}" != true ]] && echo ""

      # Merges section
      mergeq_pid_file="${BUILD_DIR}/mergeq/.daemon.pid"
      if [[ -f "${mergeq_pid_file}" ]] && kill -0 "$(cat "${mergeq_pid_file}" 2>/dev/null)" 2>/dev/null; then
        # Derive counts from pre-fetched mergeq_entries (Phase 2 optimization)
        processing=$(echo "${mergeq_entries}" | grep -c "^processing" 2>/dev/null || true)
        pending=$(echo "${mergeq_entries}" | grep -c "^pending" 2>/dev/null || true)
        if [[ "${processing}" -gt 0 ]]; then
          echo -e "Merges: ${C_CYAN}Active${C_RESET}"
        elif [[ "${pending}" -gt 0 ]]; then
          echo -e "Merges: ${C_CYAN}Active${C_RESET}"
        else
          echo -e "Merges: ${C_YELLOW}Polling${C_RESET}"
        fi
      elif [[ "${merges_empty}" = true ]]; then
        echo -e "Merges: ${C_DIM}None${C_RESET}"
      else
        echo -e "Merges: ${C_DIM}Stopped${C_RESET}"
      fi
      if [[ "${merges_empty}" != true ]]; then
        # Use pre-fetched mergeq_entries (Phase 2 optimization)
        total=$(echo "${mergeq_entries}" | grep -c '' 2>/dev/null || true)
        if [[ "${total}" -le 3 ]]; then
          echo "${mergeq_entries}" | while IFS=$'\t' read -r status op; do
            [[ -z "${status}" ]] && continue
            status_color="${C_CYAN}"
            [[ "${status}" = "pending" ]] && status_color=""
            printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
          done
        else
          echo "${mergeq_entries}" | head -n 3 | while IFS=$'\t' read -r status op; do
            [[ -z "${status}" ]] && continue
            status_color="${C_CYAN}"
            [[ "${status}" = "pending" ]] && status_color=""
            printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
          done
          remaining=$((total - 3))
          echo -e "  ${C_DIM}... and ${remaining} more in queue${C_RESET}"
        fi
      fi
    fi
    [[ "${merges_empty}" != true ]] && echo ""

    # Show coffee and nudge status on one line
    coffee_status=""
    nudge_status=""
    if coffee_is_running; then
      coffee_pid_val=$(coffee_pid)
      coffee_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${coffee_pid_val}]${C_RESET}"
    else
      coffee_status="${C_DIM}Stopped${C_RESET}"
    fi
    if nudge_running; then
      nudge_pid_val=$(nudge_pid)
      nudge_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${nudge_pid_val}]${C_RESET}"
    else
      nudge_status="${C_DIM}Stopped${C_RESET}"
    fi
    echo -e "Coffee: ${coffee_status}"
    echo -e "Nudge: ${nudge_status}"

    # Show recently completed items (opt-in to avoid N+1 queries)
    if [[ -n "${RECENT}" ]]; then
      show_recently_completed 3
    fi
  fi

  if [[ -z "${NO_HINTS}" ]]; then
    echo ""
    echo "Run with --help for more options"
  fi
  exit 0
fi

# Check operation exists using state machine
if ! sm_state_exists "${NAME}"; then
  echo "Error: No operation found for '${NAME}'"
  exit 1
fi

show_status() {
  # Batch read all state fields in single jq invocation (instead of 20+ separate calls)
  # Phase 5 optimization: added merge_commit and merge_error to batch read
  local phase op_type feature_id machine session current_issue last_activity \
        merge_queued merge_status merged_at after eager worker_pid worker_log \
        worker_started_at error_msg held held_at worktree merge_commit merge_error
  IFS=$'\t' read -r phase op_type feature_id machine session current_issue \
    last_activity merge_queued merge_status merged_at after eager worker_pid \
    worker_log worker_started_at error_msg held held_at worktree merge_commit merge_error <<< \
    "$(sm_read_state_fields "${NAME}" phase type epic_id machine tmux_session \
       current_issue last_activity merge_queued merge_status merged_at \
       after eager worker_pid worker_log worker_started_at error held held_at worktree \
       merge_commit merge_error)"

  # Handle defaults for fields that need them
  [[ -z "${op_type}" ]] && op_type="build"
  [[ -z "${merge_queued}" ]] && merge_queued="false"
  [[ -z "${eager}" ]] && eager="false"
  [[ -z "${held}" ]] && held="false"

  # Get completed count separately (requires array length calculation)
  local completed
  completed=$(sm_read_state "${NAME}" "completed | length")
  [[ -z "${completed}" ]] && completed=0

  local local_machine
  local_machine=$(hostname -s)

  if [[ -n "${JSON}" ]]; then
    cat "$(sm_get_state_file "${NAME}")"
    return
  fi

  echo "=== Operation: ${NAME} ==="
  echo "Type: ${op_type}"

  # Show user-friendly status
  # Helper to verify merged status using recorded merge_commit (read in batch above)
  local merge_verified=""
  if [[ -n "${merge_commit}" ]] && [[ "${merge_commit}" != "null" ]]; then
    if v0_verify_merge_by_op "${NAME}"; then
      merge_verified="yes"
    else
      merge_verified="no"
    fi
  fi

  case "${phase}" in
    merged)
      # Verify merged claims if merge_commit is recorded
      if [[ "${merge_verified}" = "no" ]]; then
        echo "Status: completed (== VERIFY FAILED ==)"
      else
        echo "Status: completed (merged)"
      fi
      ;;
    completed|pending_merge)
      # Plan-type operations don't merge, so show "plan completed" without merge indicators
      if [[ "${op_type}" = "plan" ]]; then
        echo "Status: plan completed"
      elif [[ "${merge_queued}" = "true" ]]; then
        # Always check queue status first - it's more authoritative than state.json
        # The queue reflects actual merge attempts, while state.json may be stale
        local queue_file="${BUILD_DIR}/mergeq/queue.json"
        local queue_entry_status=""
        if [[ -f "${queue_file}" ]]; then
          queue_entry_status=$(jq -r ".entries[] | select(.operation == \"${NAME}\") | .status" "${queue_file}" 2>/dev/null || true)
        fi
        case "${queue_entry_status}" in
          pending|processing)
            echo "Status: completed (merging...)"
            ;;
          completed)
            # Verify the merge if merge_commit is recorded
            if [[ "${merge_verified}" = "no" ]]; then
              echo "Status: completed (== VERIFY FAILED ==)"
            else
              echo "Status: completed (merged)"
            fi
            ;;
          failed)
            echo "Status: completed (== MERGE FAILED ==)"
            ;;
          conflict)
            echo "Status: completed (== CONFLICT ==)"
            ;;
          resumed)
            echo "Status: completed (== NEEDS MERGE ==)"
            ;;
          *)
            # No queue entry - fall back to state.json indicators
            if [[ "${merge_status}" = "merged" ]]; then
              # Verify the merge if merge_commit is recorded
              if [[ "${merge_verified}" = "no" ]]; then
                echo "Status: completed (== VERIFY FAILED ==)"
              else
                echo "Status: completed (merged)"
              fi
            elif [[ "${merge_status}" = "conflict" ]]; then
              echo "Status: completed (== CONFLICT ==)"
            elif [[ -n "${merged_at}" ]] && [[ "${merged_at}" != "null" ]]; then
              # Verify the merge if merge_commit is recorded
              if [[ "${merge_verified}" = "no" ]]; then
                echo "Status: completed (== VERIFY FAILED ==)"
              else
                echo "Status: completed (merged)"
              fi
            else
              echo "Status: completed (merge pending)"
            fi
            ;;
        esac
      else
        echo "Status: completed (== NEEDS MERGE ==)"
        # worktree already read in batch, branch is session (tmux_session)
        local branch="${session}"
        if [[ -n "${worktree}" ]] && [[ -d "${worktree}" ]]; then
          echo "  Merge: v0 merge ${worktree}"
        elif [[ -n "${branch}" ]] && git rev-parse --verify "${branch}" >/dev/null 2>&1; then
          echo "  Merge: git merge ${branch}  (worktree missing)"
        else
          echo "  (no branch or worktree found - may need cleanup)"
        fi
      fi
      ;;
    *)
      echo "Status: ${phase}"
      ;;
  esac

  echo "Machine: ${machine}"
  echo "Feature: ${feature_id:-N/A}"

  # Show hold status if held
  if [[ "${held}" = "true" ]]; then
    echo ""
    echo "Hold:"
    echo "  Status: HELD (since ${held_at})"
    echo "  Release: v0 resume ${NAME}"
  fi

  # Show after info if applicable
  if [[ -n "${after}" ]] && [[ "${after}" != "null" ]]; then
    echo ""
    echo "After: ${after}"
    [[ "${eager}" = "true" ]] && echo "Mode: eager (plan first)" || echo "Mode: wait first"

    # Use state machine to get after operation status
    local after_phase
    if sm_state_exists "${after}"; then
      after_phase=$(sm_get_phase "${after}")
      echo "Status: ${after_phase}"
    else
      echo "Status: unknown (operation not found)"
    fi
  fi

  # Show background worker info if applicable
  if [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
    echo ""
    echo "Background Worker:"
    if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
      echo "  Status: Running (pid: ${worker_pid})"
      if [[ -n "${worker_started_at}" ]] && [[ "${worker_started_at}" != "null" ]]; then
        local started_epoch now_epoch elapsed
        started_epoch=$(timestamp_to_epoch "${worker_started_at}")
        now_epoch=$(date +%s)
        if [[ -n "${started_epoch}" ]]; then
          elapsed=$((now_epoch - started_epoch))
          echo "  Started: $(format_elapsed "${elapsed}")"
        fi
      fi
    else
      echo "  Status: Stopped"
    fi
    if [[ -n "${worker_log}" ]] && [[ "${worker_log}" != "null" ]] && [[ -f "${worker_log}" ]]; then
      echo "  Log: ${worker_log}"
      echo ""
      echo "Recent activity:"
      tail -5 "${worker_log}" 2>/dev/null | sed 's/^/  /' || echo "  (no recent activity)"
    fi
  fi

  # Show error if phase is failed
  if [[ "${phase}" = "failed" ]] && [[ -n "${error_msg}" ]] && [[ "${error_msg}" != "null" ]]; then
    echo ""
    echo "Error: ${error_msg}"
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  # Show interrupted message
  if [[ "${phase}" = "interrupted" ]]; then
    echo ""
    echo "Worker was interrupted."
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  if [[ -n "${session}" ]]; then
    if [[ "${machine}" = "${local_machine}" ]]; then
      if tmux has-session -t "${session}" 2>/dev/null; then
        echo "Session: Running (${session})"
        echo "Attach:  v0 attach feature ${NAME}"
      else
        echo "Session: Stopped (was ${session})"
      fi
    else
      echo "Session: ${session} (on ${machine})"
      echo "Attach:  ssh ${machine} -t 'v0 attach feature ${NAME}'"
    fi
  fi

  if [[ -n "${current_issue}" ]]; then
    echo "Current: ${current_issue}"
  fi
  echo "Completed: ${completed} issues"

  if [[ -n "${last_activity}" ]]; then
    echo "Last Activity: ${last_activity}"
  fi

  # Show merge status if queued
  if [[ "${merge_queued}" = "true" ]]; then
    echo ""
    echo "Merge:"
    if [[ -n "${merge_status}" ]]; then
      case "${merge_status}" in
        merged)
          echo "  Status: Merged at ${merged_at}"
          ;;
        merging)
          echo "  Status: Merge in progress..."
          ;;
        conflict)
          # worktree already read in batch
          echo "  Status: CONFLICTS - needs resolution"
          echo "  Resolve: v0 merge ${worktree} --resolve"
          ;;
        failed)
          # merge_error already read in batch above (Phase 5 optimization)
          echo "  Status: FAILED - ${merge_error}"
          ;;
        *)
          echo "  Status: ${merge_status}"
          ;;
      esac
    else
      echo "  Status: Queued (waiting for completion)"
    fi
  fi

  echo ""
  if [[ -n "${feature_id}" ]]; then
    echo "Issue Status:"
    local total open closed in_progress
    total=$(wk list --label "plan:${NAME}" 2>/dev/null | wc -l | tr -d ' ')
    open=$(wk list --label "plan:${NAME}" --status todo 2>/dev/null | wc -l | tr -d ' ')
    in_progress=$(wk list --label "plan:${NAME}" --status in_progress 2>/dev/null | wc -l | tr -d ' ')
    closed=$(wk list --label "plan:${NAME}" --status "done" 2>/dev/null | wc -l | tr -d ' ')

    echo "  Total: ${total}  Open: ${open}  In Progress: ${in_progress}  Closed: ${closed}"
    echo ""
    echo "Commands:"
    echo "  wk list --label plan:${NAME}          # All issues"
    echo "  wk ready --label plan:${NAME}         # Ready to work"
    echo "  wk list --label plan:${NAME} --status in_progress  # Active"
  fi
}

if [[ -n "${WATCH}" ]]; then
  while true; do
    clear
    show_status
    echo ""
    echo "(Refreshing every 5s, Ctrl+C to stop)"
    sleep 5
  done
else
  show_status
fi
