#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

# Source coffee functions for status display
source "${V0_DIR}/packages/worker/lib/coffee-common.sh"

# Source nudge functions for status display
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"

# Source timestamp utilities
source "${V0_DIR}/packages/status/lib/timestamps.sh"

# Source queue display utilities
source "${V0_DIR}/packages/status/lib/queue-display.sh"

# Source worker status utilities
source "${V0_DIR}/packages/status/lib/worker-status.sh"

# Source recently completed display utilities
source "${V0_DIR}/packages/status/lib/recent-display.sh"

# Source branch status utilities
source "${V0_DIR}/packages/status/lib/branch-status.sh"

# Source blocker display utilities
source "${V0_DIR}/packages/status/lib/blocker-display.sh"

usage() {
  v0_help <<'EOF'
Usage: v0 status [name] [options]

Check status of build operations.

Options:
  --list         List all operations (default)
  --blocked      List only waiting operations (using --after)
  --merge        Show merge queue status
  --fix          Show fix worker status
  --chore        Show chore worker status
  --recent       Show recently completed bugs/chores
  --watch        Watch for live updates
  --json         Output as JSON
  --short        Compact output (hides inactive sections, coffee/nudge)

Examples:
  v0 status                # List all operations (default)
  v0 status auth           # Check auth operation
  v0 status --merge        # Show merge queue
  v0 status --fix          # Show fix worker status
  v0 status --chore        # Show chore worker status
  v0 status auth --watch   # Live updates

See also:
  v0 prune                 # Remove completed/cancelled operations
EOF
  exit 1
}

# Show active roadmaps (only planning/orchestrating phases)
# Returns: 0 if roadmaps were displayed, 1 if no active roadmaps
show_active_roadmaps() {
  local roadmap_dir="${BUILD_DIR}/roadmaps"
  [[ ! -d "${roadmap_dir}" ]] && return 1

  local active_roadmaps=()
  local local_machine
  local_machine=$(hostname -s)

  for state_file in "${roadmap_dir}"/*/state.json; do
    [[ ! -f "${state_file}" ]] && continue

    # Batch read all fields in single jq call (7 fields -> 1 subprocess)
    local phase name desc idea_id worker_pid machine session
    local _fields
    _fields=$(jq -r '[.phase, .name, .roadmap_description, .idea_id, .worker_pid, .machine, .planning_session] | map(. // "") | join("|")' "${state_file}")
    IFS='|' read -r phase name desc idea_id worker_pid machine session <<< "${_fields}"

    # Only show during active phases (init/planning)
    if [[ "${phase}" = "planning" ]] || [[ "${phase}" = "init" ]]; then

      # Truncate description for display
      local desc_short="${desc:0:40}"
      [[ ${#desc} -gt 40 ]] && desc_short="${desc_short}..."

      # Check if session is running
      local status_icon=""
      if [[ -n "${session}" ]] && [[ "${session}" != "null" ]] && tmux has-session -t "${session}" 2>/dev/null; then
        status_icon=" ${C_CYAN}(active)${C_RESET}"
      elif [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
        if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
          status_icon=" ${C_CYAN}(bg-worker)${C_RESET}"
        fi
      fi

      active_roadmaps+=("${name}|${phase}|${desc_short}|${idea_id}|${status_icon}")
    fi
  done

  if [[ ${#active_roadmaps[@]} -eq 0 ]]; then
    return 1
  fi

  echo ""
  echo "Roadmaps:"
  for roadmap_data in "${active_roadmaps[@]}"; do
    IFS='|' read -r name phase desc idea_id status_icon <<< "${roadmap_data}"
    local phase_color=""
    case "${phase}" in
      planning) phase_color="${C_YELLOW}" ;;
      init) phase_color="${C_DIM}" ;;
    esac
    printf "  %-20s ${phase_color}%-15s${C_RESET}%b  %s\n" "${name}:" "${phase}" "${status_icon}" "${C_DIM}(${desc})${C_RESET}"
    [[ -n "${idea_id}" ]] && [[ "${idea_id}" != "null" ]] && printf "  %-20s %s\n" "" "${C_DIM}[${idea_id}]${C_RESET}"
  done

  return 0
}


# Phase 3-4 optimization: Get queue entry status using bash string matching
# Args: $1 = operation name, $2 = queue_cache_data variable
# Output: status field or empty string
# Uses pure bash - no subprocess spawns
get_queue_entry_status() {
  local op_name="$1"
  local cache_data="$2"
  local line rest
  # Match line starting with operation name followed by tab
  while IFS= read -r line; do
    if [[ "${line}" == "${op_name}"$'\t'* ]]; then
      # Extract second field using bash parameter expansion
      rest="${line#*$'\t'}"      # Remove first field (operation)
      echo "${rest%%$'\t'*}"     # Return second field (status), remove rest
      return
    fi
  done <<< "${cache_data}"
}

# Phase 3-4 optimization: Get queue completed timestamp using bash string matching
# Args: $1 = operation name, $2 = queue_cache_data variable
# Output: updated_at field for completed entries, or empty string
# Uses pure bash - no subprocess spawns
get_queue_completed_timestamp() {
  local op_name="$1"
  local cache_data="$2"
  local line rest
  # Match line: operation<tab>completed<tab>timestamp
  while IFS= read -r line; do
    if [[ "${line}" == "${op_name}"$'\t'"completed"$'\t'* ]]; then
      # Extract third field using bash parameter expansion
      rest="${line#*$'\t'}"      # Remove first field
      rest="${rest#*$'\t'}"      # Remove second field
      echo "${rest}"             # Return third field (timestamp)
      return
    fi
  done <<< "${cache_data}"
}


NAME=""
LIST=""
BLOCKED=""
MERGE_QUEUE=""
BUGFIX=""
CHORE=""
WATCH=""
JSON=""
RECENT=""
NO_HINTS=""
MAX_OPS=""
SHORT=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --list) LIST=1; shift ;;
    --blocked) BLOCKED=1; shift ;;
    --merge) MERGE_QUEUE=1; shift ;;
    --fix) FIX=1; shift ;;
    --bugfix) FIX=1; shift ;;  # Backwards compatibility
    --chore) CHORE=1; shift ;;
    --watch) WATCH=1; shift ;;
    --json) JSON=1; shift ;;
    --recent) RECENT=1; shift ;;
    --no-hints) NO_HINTS=1; shift ;;
    --max-ops) MAX_OPS="$2"; shift 2 ;;
    --short) SHORT=1; shift ;;
    --prune|--prune-all)
      echo "Warning: $1 is deprecated. Use 'v0 prune' instead." >&2
      exec "${V0_DIR}/bin/v0-prune" "$@"
      ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *) NAME="$1"; shift ;;
  esac
done

# Show merge queue status
if [[ -n "${MERGE_QUEUE}" ]]; then
  echo "Merge Queue Status:"
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --status
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --list
  exit 0
fi

# Show fix status (condensed view)
if [[ -n "${FIX}" ]]; then
  show_standalone_worker_status "fix"
  exit 0
fi

# Show chore status (condensed view)
if [[ -n "${CHORE}" ]]; then
  show_standalone_worker_status "chore"
  exit 0
fi

# Default to --list if no arguments
if [[ -z "${NAME}" ]]; then
  LIST=1
fi

# List all operations (default behavior)
if [[ -n "${LIST}" ]] || [[ -n "${BLOCKED}" ]]; then
  # Show branch ahead/behind status at the top (blank line follows only if status shown)
  show_branch_status && echo ""

  # Batch tmux session check - single call to list all sessions (used by operations loop and workers)
  all_sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)

  # Pre-check if operations directory exists and has state files
  has_operations=false
  if [[ -d "${BUILD_DIR}/operations" ]]; then
    for f in "${BUILD_DIR}"/operations/*/state.json; do
      [[ -f "${f}" ]] && has_operations=true && break
    done
  fi

  # If no operations, show compact "None" format like other sections
  if [[ "${has_operations}" = false ]]; then
    if [[ -n "${BLOCKED}" ]]; then
      echo -e "Blocked Plans: ${C_DIM}None${C_RESET}"
    else
      echo -e "Plans: ${C_DIM}None${C_RESET}"
    fi
  else
    # Operations exist - show full format with header and details
    if [[ -n "${BLOCKED}" ]]; then
      echo "Blocked Plans:"
    else
      echo "Plans:"
    fi
    echo ""

  local_machine=$(hostname -s)

  # Collect all state files (bash 3.2 compatible)
  state_files=()
  for f in "${BUILD_DIR}"/operations/*/state.json; do
    [[ -f "${f}" ]] && state_files+=("${f}")
  done

  found_any=""
  # max_name_display is the truncation limit for long names
  max_name_display=40
  # max_name_len is calculated in jq below (Phase 3 optimization - single pass)

  # Merge queue file path for timestamp lookups (used in display loop)
  mergeq_file="${BUILD_DIR}/mergeq/queue.json"

  # Pre-fetch queue data for O(1) lookups in loop (Phase 1 optimization)
  # Format: operation\tstatus\tupdated_at (one per line)
  queue_cache=$(mktemp)
  # shellcheck disable=SC2064  # Intentional: capture temp file path at trap time
  trap "rm -f '${queue_cache}'" EXIT
  if [[ -f "${mergeq_file}" ]]; then
    jq -r '.entries[] | [.operation, .status, (.updated_at // "")] | @tsv' "${mergeq_file}" > "${queue_cache}" 2>/dev/null || true
  fi
  # Phase 3-4 optimization: Load queue cache into variable for bash string matching
  # This eliminates grep subprocess spawns per operation in the display loop
  queue_cache_data=""
  if [[ -s "${queue_cache}" ]]; then
    queue_cache_data=$(<"${queue_cache}")
  fi

  # Process all state files in single jq -s invocation (one process instead of many)
  # Phase 3 optimization: also calculates max_name_len in same pass (META line first)
  max_name_len=8  # Default minimum
  # Pruning statistics (set by META line from jq)
  pruned_open=0
  pruned_blocked=0
  pruned_completed=0
  total_ops=0
  # Phase 1 optimization: cache current timestamp once for all operations
  now_epoch=$(date +%s)
  # Determine effective limit: --max-ops overrides, otherwise show all (use very high number)
  effective_limit="${MAX_OPS:-99999}"
  if [[ ${#state_files[@]} -gt 0 ]]; then
    while IFS=$'\t' read -r name op_type phase created machine completed merge_queued merge_status merged_at completed_at epic_id session worker_pid held held_at merge_resumed worktree_missing merge_commit created_epoch completed_epoch merged_epoch held_epoch updated_epoch; do
      # Handle META line for max name length and pruning stats
      if [[ "${name}" = "META" ]]; then
        max_name_len="${op_type}"  # op_type field contains max_name_len for META
        [[ ${max_name_len} -lt 8 ]] && max_name_len=8
        # Pruning statistics: phase=pruned_open, created=pruned_blocked, machine=pruned_completed, completed=total
        pruned_open="${phase:-0}"
        pruned_blocked="${created:-0}"
        pruned_completed="${machine:-0}"
        total_ops="${completed:-0}"
        continue
      fi
      [[ -z "${name}" ]] && continue
    # If --blocked filter, skip non-blocked operations (check wok for blockers)
    if [[ -n "${BLOCKED}" ]]; then
      if [[ -z "${epic_id}" ]] || [[ "${epic_id}" = "null" ]]; then
        continue
      fi
      # Check wok for open blockers
      if ! v0_is_blocked "${epic_id}"; then
        continue
      fi
    fi

    found_any=1

    # Check if session is running - uses batched all_sessions
    # Note: all_sessions only contains LOCAL tmux sessions, so if we find a match,
    # it's definitely running locally regardless of the machine field in state.json
    status_icon=""
    if [[ -n "${session}" ]] && [[ "${session}" != "null" ]] && [[ "${all_sessions}" == *"${session}"* ]]; then
      status_icon=" ${C_CYAN}(active)${C_RESET}"
    fi
    # Check if background worker is running
    if [[ -z "${status_icon}" ]] && [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
      if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
        status_icon=" ${C_CYAN}(bg-worker)${C_RESET}"
      fi
    fi

    # Add blocker indicator (only show for phases where operation is still waiting)
    # Query wok for blockers using epic_id
    after_icon=""
    if [[ -n "${epic_id}" ]] && [[ "${epic_id}" != "null" ]]; then
      case "${phase}" in
        executing|completed|pending_merge|merged|cancelled)
          # Don't show [after] for these phases - operation is already past waiting
          ;;
        *)
          # Get first blocker from wok
          blocker_display=$(_status_get_blocker_display "${epic_id}")
          if [[ -n "${blocker_display}" ]]; then
            after_icon=" ${C_YELLOW}[after ${blocker_display}]${C_RESET}"
          fi
          ;;
      esac
    fi

    # Add hold indicator
    hold_icon=""
    if [[ "${held}" = "true" ]]; then
      hold_icon=" ${C_RED}[HELD]${C_RESET}"
    fi

    # Get queue entry status for merge display (only needed when merge_queued)
    # Phase 3-4 optimization: uses bash string matching instead of grep subprocess
    queue_entry_status=""
    if [[ "${merge_queued}" = "true" ]] && [[ -n "${queue_cache_data}" ]]; then
      queue_entry_status=$(get_queue_entry_status "${name}" "${queue_cache_data}")
    fi

    # Verify failed/conflict entries - the merge may have succeeded manually
    # Only verify if we have a merge_commit recorded (avoids unnecessary git calls)
    if [[ "${queue_entry_status}" = "failed" ]] || [[ "${queue_entry_status}" = "conflict" ]]; then
      if [[ -n "${merge_commit}" ]] && [[ "${merge_commit}" != "null" ]]; then
        if v0_verify_commit_on_branch "${merge_commit}" "main" 2>/dev/null; then
          queue_entry_status="completed"
        fi
      fi
    fi

    # Use shared helper for phase display formatting
    IFS='|' read -r raw_display raw_merge_icon <<< \
      "$(_sm_format_phase_display "${phase}" "${op_type}" "${merge_queued}" "${merge_status}" "${merged_at}" "${queue_entry_status}" "${merge_resumed}" "${worktree_missing}")"

    # Override display to "blocked" when there's an open blocker
    if [[ -n "${after_icon}" ]]; then
      raw_display="blocked"
    fi

    # Get colors for display
    phase_color=$(_sm_get_phase_color "${raw_display}" "${raw_merge_icon}")
    merge_color=$(_sm_get_merge_icon_color "${raw_merge_icon}")

    # Apply colors to display_phase
    if [[ -n "${phase_color}" ]]; then
      display_phase="$(sm_get_status_color "${phase_color}")${raw_display}${C_RESET}"
    else
      display_phase="${raw_display}"
    fi

    # Apply colors to merge_icon
    merge_icon=""
    if [[ -n "${raw_merge_icon}" ]]; then
      if [[ -n "${merge_color}" ]]; then
        # Special formatting for certain merge icons
        case "${raw_merge_icon}" in
          "[merged]")
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_DIM}${raw_merge_icon}${C_RESET}"
            ;;
          "(== MERGE FAILED =="*|"(== CONFLICT =="*|"(== NEEDS MERGE =="*)
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_BOLD}${raw_merge_icon}${C_RESET}"
            ;;
          *)
            merge_icon=" $(sm_get_status_color "${merge_color}")${raw_merge_icon}${C_RESET}"
            ;;
        esac
      else
        merge_icon=" ${raw_merge_icon}"
      fi
    fi

    # Update status_icon for specific phase/activity combinations
    # Use () for active status indicators, [] for conditions like [HELD] or [after ...]
    case "${phase}" in
      init)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(planning...)${C_RESET}"
        ;;
      planned)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(decomposing...)${C_RESET}"
        ;;
      queued|executing)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_CYAN}(building...)${C_RESET}"
        ;;
      blocked)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(waiting...)${C_RESET}"
        ;;
      failed)
        status_icon=" ${C_RED}${C_BOLD}(== ERROR ==)${C_RESET}"
        ;;
      interrupted)
        status_icon=" ${C_RED}${C_BOLD}(== INTERRUPTED ==)${C_RESET}"
        ;;
    esac

    # Truncate long names with "..." (max_name_display - 1 for ":" suffix, - 3 for "...")
    display_name="${name}:"
    if [[ ${#display_name} -gt ${max_name_display} ]]; then
      display_name="${name:0:$((max_name_display - 4))}...:"
    fi
    # Phase 2 optimization: Use pre-computed epochs instead of calling timestamp_to_epoch
    # Check for merge queue override first (rare case - only for merged ops)
    # Phase 3-4 optimization: uses bash string matching instead of grep subprocess
    mq_updated=""
    if [[ "${phase}" == "merged" ]] && [[ -n "${queue_cache_data}" ]]; then
      mq_updated=$(get_queue_completed_timestamp "${name}" "${queue_cache_data}")
    fi
    if [[ -n "${mq_updated}" ]]; then
      # Fallback to timestamp path for queue override (rare)
      display_time=$(format_operation_time "${mq_updated}" "${now_epoch}")
    else
      # Fast path: use pre-computed epoch values (eliminates N date -j calls)
      last_epoch=$(get_last_updated_epoch "${phase}" "${created_epoch}" "${completed_epoch}" "${merged_epoch}" "${held_epoch}" "${updated_epoch}")
      display_time=$(format_epoch_time "${last_epoch}" "${now_epoch}")
    fi
    printf "  %-${max_name_len}s %b%b%b%b%b ${C_DIM}(%s)${C_RESET}\n" "${display_name}" "${display_phase}" "${status_icon}" "${after_icon}" "${hold_icon}" "${merge_icon}" "${display_time}"
    done < <(jq -rs --argjson limit "${effective_limit}" '
      # Phase 2: Helper function to convert ISO 8601 timestamp to epoch
      # Handles timestamps like "2026-01-22T10:30:45.123Z"
      def to_epoch:
        if . == null or . == "" or . == "null" then 0
        else (sub("\\.[0-9]+"; "") | strptime("%Y-%m-%dT%H:%M:%SZ") | mktime) // 0
        end;

      # Priority classification for limit pruning
      # 0 = open (highest priority: needs attention, including merge issues)
      # 1 = reserved (blocking now checked via wok at display time)
      # 2 = truly completed (merged successfully or cancelled)
      def priority_class:
        if .phase == "cancelled"
        then 2  # cancelled
        elif .phase == "merged" or .phase == "completed" or .phase == "pending_merge"
        then
          # Plan-type operations do not need merge, so completed is truly done
          if .type == "plan" then 2
          # Successfully merged - truly done
          elif .merge_status == "merged" then 2
          # All other completed states (pending merge, failed, conflict, not queued) need attention
          else 0
          end
        # NOTE: blocked phase removed in v2, blocking tracked via wok
        else 0  # open (needs attention: init, planned, queued, executing, failed, conflict, interrupted)
        end;

      # Limit and pruning logic
      . as $all |
      ($all | length) as $total |
      # $limit is passed via --argjson from V0_STATUS_LIMIT

      # Add priority to each operation
      [$all[] | . + {_priority: priority_class}] |

      # Separate by priority
      (map(select(._priority == 0)) | sort_by(.created_at)) as $open |
      (map(select(._priority == 1)) | sort_by(.created_at)) as $blocked |
      (map(select(._priority == 2)) | sort_by(.created_at)) as $completed |

      # Build selection: open first, then blocked, then completed (up to limit)
      ([$open[], $blocked[], $completed[]] | .[:$limit]) as $selected |

      # Calculate pruning counts
      (($open | length) - ([$selected[] | select(._priority == 0)] | length)) as $pruned_open |
      (($blocked | length) - ([$selected[] | select(._priority == 1)] | length)) as $pruned_blocked |
      (($completed | length) - ([$selected[] | select(._priority == 2)] | length)) as $pruned_completed |

      # Calculate max name length for selected operations only
      (reduce $selected[] as $op (0; [., ([($op.name | length) + 1, 40] | min)] | max)) as $max_len |

      # Output META line with pruning statistics
      (["META", $max_len, $pruned_open, $pruned_blocked, $pruned_completed, $total] | @tsv),

      # Output selected operations in created_at order (with epoch timestamps)
      ($selected | sort_by(.created_at) | .[] | [
        .name,
        (.type // "build"),
        .phase,
        .created_at,
        (.machine // "unknown"),
        (.completed | length),
        (.merge_queued // false),
        (.merge_status // "null"),
        (.merged_at // "null"),
        (.completed_at // "null"),
        (.epic_id // "null"),
        (.tmux_session // "null"),
        (.worker_pid // "null"),
        (.held // false),
        (.held_at // "null"),
        (.merge_resumed // false),
        (.worktree_missing // false),
        (.merge_commit // "null"),
        # Phase 2: Pre-computed epoch values (eliminates N date -j calls)
        (.created_at | to_epoch),
        ((.completed_at // "") | to_epoch),
        ((.merged_at // "") | to_epoch),
        ((.held_at // "") | to_epoch),
        ((.updated_at // "") | to_epoch)
      ] | @tsv)
    ' "${state_files[@]}")

    # Show summary line for pruned operations
    if [[ ${total_ops} -gt ${effective_limit} ]]; then
      pruned=$((total_ops - effective_limit))
      summary_parts=()
      [[ ${pruned_blocked} -gt 0 ]] && summary_parts+=("${pruned_blocked} blocked")
      [[ ${pruned_completed} -gt 0 ]] && summary_parts+=("${pruned_completed} completed")

      if [[ ${#summary_parts[@]} -eq 0 ]]; then
        # Only open operations pruned (rare)
        echo -e "  ${C_DIM}... and ${pruned} more${C_RESET}"
      elif [[ ${#summary_parts[@]} -eq 1 ]] && [[ ${pruned_open} -eq 0 ]]; then
        # Only one category pruned and no open pruned - simpler message
        # Extract category name (second word from "N blocked" or "N completed")
        category="${summary_parts[0]#* }"
        echo -e "  ${C_DIM}... and ${pruned} more ${category}${C_RESET}"
      else
        summary=$(IFS=', '; echo "${summary_parts[*]}")
        echo -e "  ${C_DIM}... and ${pruned} more (${summary})${C_RESET}"
      fi
    fi
  fi

  # For --blocked filter: show message if operations exist but none are blocked
  if [[ -z "${found_any}" ]] && [[ -n "${BLOCKED}" ]]; then
    echo -e "  ${C_DIM}(no waiting operations)${C_RESET}"
  fi
  fi  # end: has_operations = true

  # Show active roadmaps (only during planning/orchestrating phases)
  showed_roadmaps=false
  if [[ -z "${BLOCKED}" ]]; then
    show_active_roadmaps && showed_roadmaps=true || true
  fi

  # Show fix, chore, and merge worker status in default list (not blocked view)
  if [[ -z "${BLOCKED}" ]]; then
    # Batch pgrep for all polling daemons - single call
    all_polling=$(pgrep -af "while true.*v0-${PROJECT}" 2>/dev/null || true)

    # Pre-check if all work queues are empty
    bugs_in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
    bugs_open=$(wk list --type bug --status todo 2>/dev/null || true)
    chores_in_progress=$(wk list --type chore --status in_progress 2>/dev/null || true)
    chores_open=$(wk list --type chore --status todo 2>/dev/null || true)
    mergeq_queue_file="${BUILD_DIR}/mergeq/queue.json"
    # Single read for all merge queue data (Phase 2 optimization)
    # Format: status\toperation - used for display and counts
    mergeq_entries=""
    merges_pending=""
    if [[ -f "${mergeq_queue_file}" ]]; then
      mergeq_entries=$(jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${mergeq_queue_file}" 2>/dev/null || true)
      # Derive operation list for backwards compatibility with merges_empty check
      merges_pending=$(echo "${mergeq_entries}" | cut -f2 | v0_grep_invert '^$' || true)
    fi

    bugs_empty=false
    chores_empty=false
    merges_empty=false
    [[ -z "${bugs_in_progress}" ]] && [[ -z "${bugs_open}" ]] && bugs_empty=true
    [[ -z "${chores_in_progress}" ]] && [[ -z "${chores_open}" ]] && chores_empty=true
    [[ -z "${merges_pending}" ]] && merges_empty=true

    # If all queues are empty, show each on its own line (skip in --short mode)
    if [[ "${bugs_empty}" = true ]] && [[ "${chores_empty}" = true ]] && [[ "${merges_empty}" = true ]]; then
      if [[ -z "${SHORT}" ]]; then
        # Only add blank line separator if there was content above (operations or roadmaps)
        [[ "${has_operations}" = true ]] || [[ "${showed_roadmaps}" = true ]] && echo ""
        echo -e "Bugs: ${C_DIM}None${C_RESET}"
        echo -e "Chores: ${C_DIM}None${C_RESET}"
        echo -e "Merges: ${C_DIM}None${C_RESET}"
      fi
    else
      # Show full sections for non-empty queues
      # Only add blank line separator if there was content above (operations or roadmaps)
      [[ "${has_operations}" = true ]] || [[ "${showed_roadmaps}" = true ]] && echo ""

      # Bugs section
      fix_status=$(get_worker_status "fix" "${all_sessions}" "${all_polling}")
      # In short mode, skip only if queue is empty (show "Stopped" if queue has items)
      if [[ -z "${SHORT}" ]] || [[ "${bugs_empty}" != true ]]; then
        show_worker_header_compact "Bugs" "${fix_status}" "${bugs_empty}"
        [[ "${bugs_empty}" != true ]] && show_worker_items_inline "${bugs_in_progress}" "${bugs_open}" 3
        [[ "${bugs_empty}" != true ]] && echo ""
      fi

      # Chores section
      chore_status=$(get_worker_status "chore" "${all_sessions}" "${all_polling}")
      # In short mode, skip only if queue is empty (show "Stopped" if queue has items)
      if [[ -z "${SHORT}" ]] || [[ "${chores_empty}" != true ]]; then
        show_worker_header_compact "Chores" "${chore_status}" "${chores_empty}"
        [[ "${chores_empty}" != true ]] && show_worker_items_inline "${chores_in_progress}" "${chores_open}" 3
        [[ "${chores_empty}" != true ]] && echo ""
      fi

      # Merges section
      mergeq_pid_file="${BUILD_DIR}/mergeq/.daemon.pid"
      # Check if a merge-resolve session is running (manual conflict resolution)
      merge_resolve_running=false
      if [[ -n "${all_sessions}" ]] && echo "${all_sessions}" | v0_grep_quiet "merge-resolve"; then
        merge_resolve_running=true
      fi

      # Determine merge status
      merge_status_text=""
      if [[ -f "${mergeq_pid_file}" ]] && kill -0 "$(cat "${mergeq_pid_file}" 2>/dev/null)" 2>/dev/null; then
        processing=$(echo "${mergeq_entries}" | v0_grep_count "^processing" 2>/dev/null)
        pending=$(echo "${mergeq_entries}" | v0_grep_count "^pending" 2>/dev/null)
        if [[ "${processing}" -gt 0 ]] || [[ "${pending}" -gt 0 ]]; then
          merge_status_text="active"
        else
          merge_status_text="polling"
        fi
      elif [[ "${merge_resolve_running}" = true ]]; then
        merge_status_text="active"
      elif [[ "${merges_empty}" = true ]]; then
        merge_status_text="none"
      else
        merge_status_text="stopped"
      fi

      # In short mode, skip unless actively processing (hide polling, stopped, none)
      if [[ -z "${SHORT}" ]] || [[ "${merge_status_text}" == "active" ]]; then
        # Display merge header based on status
        case "${merge_status_text}" in
          active)  echo -e "Merges: ${C_CYAN}Active${C_RESET}" ;;
          polling) echo -e "Merges: ${C_YELLOW}Polling${C_RESET}" ;;
          none)    echo -e "Merges: ${C_DIM}None${C_RESET}" ;;
          stopped) echo -e "Merges: ${C_DIM}Stopped${C_RESET}" ;;
        esac
        # Display queue items if not empty
        if [[ "${merges_empty}" != true ]]; then
          total=$(echo "${mergeq_entries}" | v0_grep_count '.' 2>/dev/null)
          if [[ "${total}" -le 3 ]]; then
            echo "${mergeq_entries}" | while IFS=$'\t' read -r status op; do
              [[ -z "${status}" ]] && continue
              status_color="${C_CYAN}"
              [[ "${status}" = "pending" ]] && status_color=""
              printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
            done
          else
            echo "${mergeq_entries}" | head -n 3 | while IFS=$'\t' read -r status op; do
              [[ -z "${status}" ]] && continue
              status_color="${C_CYAN}"
              [[ "${status}" = "pending" ]] && status_color=""
              printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
            done
            remaining=$((total - 3))
            echo -e "  ${C_DIM}... and ${remaining} more in queue${C_RESET}"
          fi
        fi
      fi
    fi
    [[ "${merges_empty}" != true ]] && [[ -z "${SHORT}" || "${merge_status_text}" == "active" ]] && echo ""

    # Show coffee and nudge status on one line (unless --short mode)
    if [[ -z "${SHORT}" ]]; then
      coffee_status=""
      nudge_status=""
      if coffee_is_running; then
        coffee_pid_val=$(coffee_pid)
        coffee_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${coffee_pid_val}]${C_RESET}"
      else
        coffee_status="${C_DIM}Stopped${C_RESET}"
      fi
      if nudge_running; then
        nudge_pid_val=$(nudge_pid)
        nudge_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${nudge_pid_val}]${C_RESET}"
      else
        nudge_status="${C_DIM}Stopped${C_RESET}"
      fi
      echo -e "Coffee: ${coffee_status}"
      echo -e "Nudge: ${nudge_status}"
    fi

    # Show recently completed items (opt-in to avoid N+1 queries)
    if [[ -n "${RECENT}" ]]; then
      show_recently_completed 3
    fi
  fi

  if [[ -z "${NO_HINTS}" ]]; then
    echo ""
    echo "Run with --help for more options"
  fi
  exit 0
fi

# Check operation exists using state machine
if ! sm_state_exists "${NAME}"; then
  echo "Error: No operation found for '${NAME}'"
  exit 1
fi

show_status() {
  # Batch read all state fields in single jq invocation (instead of 20+ separate calls)
  # Phase 5 optimization: added merge_commit and merge_error to batch read
  # Note: after/eager fields removed in schema v2 - blocking now tracked via wok
  local phase op_type feature_id machine session current_issue last_activity \
        merge_queued merge_status merged_at worker_pid worker_log \
        worker_started_at error_msg held held_at worktree merge_commit merge_error
  IFS=$'\t' read -r phase op_type feature_id machine session current_issue \
    last_activity merge_queued merge_status merged_at worker_pid \
    worker_log worker_started_at error_msg held held_at worktree merge_commit merge_error <<< \
    "$(sm_read_state_fields "${NAME}" phase type epic_id machine tmux_session \
       current_issue last_activity merge_queued merge_status merged_at \
       worker_pid worker_log worker_started_at error held held_at worktree \
       merge_commit merge_error)"

  # Handle defaults for fields that need them
  [[ -z "${op_type}" ]] && op_type="build"
  [[ -z "${merge_queued}" ]] && merge_queued="false"
  [[ -z "${held}" ]] && held="false"

  # Get completed count separately (requires array length calculation)
  local completed
  completed=$(sm_read_state "${NAME}" "completed | length")
  [[ -z "${completed}" ]] && completed=0

  local local_machine
  local_machine=$(hostname -s)

  if [[ -n "${JSON}" ]]; then
    cat "$(sm_get_state_file "${NAME}")"
    return
  fi

  echo "=== Operation: ${NAME} ==="
  echo "Type: ${op_type}"

  # Show user-friendly status
  # Helper to verify merged status using recorded merge_commit (read in batch above)
  local merge_verified=""
  if [[ -n "${merge_commit}" ]] && [[ "${merge_commit}" != "null" ]]; then
    if v0_verify_merge_by_op "${NAME}"; then
      merge_verified="yes"
    else
      merge_verified="no"
    fi
  fi

  case "${phase}" in
    merged)
      # Verify merged claims if merge_commit is recorded
      if [[ "${merge_verified}" = "no" ]]; then
        echo "Status: completed (== VERIFY FAILED ==)"
      else
        echo "Status: completed (merged)"
      fi
      ;;
    completed|pending_merge)
      # Plan-type operations don't merge, so show "plan completed" without merge indicators
      if [[ "${op_type}" = "plan" ]]; then
        echo "Status: plan completed"
      elif [[ "${merge_queued}" = "true" ]]; then
        # Always check queue status first - it's more authoritative than state.json
        # The queue reflects actual merge attempts, while state.json may be stale
        local queue_file="${BUILD_DIR}/mergeq/queue.json"
        local queue_entry_status=""
        if [[ -f "${queue_file}" ]]; then
          queue_entry_status=$(jq -r ".entries[] | select(.operation == \"${NAME}\") | .status" "${queue_file}" 2>/dev/null || true)
        fi
        case "${queue_entry_status}" in
          pending|processing)
            echo "Status: completed (merging...)"
            ;;
          completed)
            # Verify the merge if merge_commit is recorded
            if [[ "${merge_verified}" = "no" ]]; then
              echo "Status: completed (== VERIFY FAILED ==)"
            else
              echo "Status: completed (merged)"
            fi
            ;;
          failed)
            echo "Status: completed (== MERGE FAILED ==)"
            ;;
          conflict)
            echo "Status: completed (== CONFLICT ==)"
            ;;
          resumed)
            echo "Status: completed (== NEEDS MERGE ==)"
            ;;
          *)
            # No queue entry - fall back to state.json indicators
            if [[ "${merge_status}" = "merged" ]]; then
              # Verify the merge if merge_commit is recorded
              if [[ "${merge_verified}" = "no" ]]; then
                echo "Status: completed (== VERIFY FAILED ==)"
              else
                echo "Status: completed (merged)"
              fi
            elif [[ "${merge_status}" = "conflict" ]]; then
              echo "Status: completed (== CONFLICT ==)"
            elif [[ -n "${merged_at}" ]] && [[ "${merged_at}" != "null" ]]; then
              # Verify the merge if merge_commit is recorded
              if [[ "${merge_verified}" = "no" ]]; then
                echo "Status: completed (== VERIFY FAILED ==)"
              else
                echo "Status: completed (merged)"
              fi
            else
              echo "Status: completed (merge pending)"
            fi
            ;;
        esac
      else
        echo "Status: completed (== NEEDS MERGE ==)"
        # worktree already read in batch, branch is session (tmux_session)
        local branch="${session}"
        if [[ -n "${worktree}" ]] && [[ -d "${worktree}" ]]; then
          echo "  Merge: v0 merge ${worktree}"
        elif [[ -n "${branch}" ]] && git rev-parse --verify "${branch}" >/dev/null 2>&1; then
          echo "  Merge: git merge ${branch}  (worktree missing)"
        else
          echo "  (no branch or worktree found - may need cleanup)"
        fi
      fi
      ;;
    *)
      echo "Status: ${phase}"
      ;;
  esac

  echo "Machine: ${machine}"
  echo "Feature: ${feature_id:-N/A}"

  # Show hold status if held
  if [[ "${held}" = "true" ]]; then
    echo ""
    echo "Hold:"
    echo -e "  Status: ${C_RED}HELD${C_RESET} (since ${held_at})"
    echo "  Release: v0 resume ${NAME}"
  fi

  # Show blocker info from wok if applicable
  if [[ -n "${feature_id}" ]] && [[ "${feature_id}" != "null" ]]; then
    local blocker_display
    blocker_display=$(_status_get_blocker_display "${feature_id}")
    if [[ -n "${blocker_display}" ]]; then
      echo ""
      echo "Blocked by: ${blocker_display}"

      # Try to get blocker status
      local blocker_status
      blocker_status=$(sm_get_blocker_status "${blocker_display}")
      echo "Status: ${blocker_status}"
    fi
  fi

  # Show background worker info if applicable
  if [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
    echo ""
    echo "Background Worker:"
    if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
      echo "  Status: Running (pid: ${worker_pid})"
      if [[ -n "${worker_started_at}" ]] && [[ "${worker_started_at}" != "null" ]]; then
        local started_epoch now_epoch elapsed
        started_epoch=$(timestamp_to_epoch "${worker_started_at}")
        now_epoch=$(date +%s)
        if [[ -n "${started_epoch}" ]]; then
          elapsed=$((now_epoch - started_epoch))
          echo "  Started: $(format_elapsed "${elapsed}")"
        fi
      fi
    else
      echo "  Status: Stopped"
    fi
    if [[ -n "${worker_log}" ]] && [[ "${worker_log}" != "null" ]] && [[ -f "${worker_log}" ]]; then
      echo "  Log: ${worker_log}"
      echo ""
      echo "Recent activity:"
      tail -5 "${worker_log}" 2>/dev/null | sed 's/^/  /' || echo "  (no recent activity)"
    fi
  fi

  # Show error if phase is failed
  if [[ "${phase}" = "failed" ]] && [[ -n "${error_msg}" ]] && [[ "${error_msg}" != "null" ]]; then
    echo ""
    echo "Error: ${error_msg}"
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  # Show interrupted message
  if [[ "${phase}" = "interrupted" ]]; then
    echo ""
    echo "Worker was interrupted."
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  if [[ -n "${session}" ]]; then
    if [[ "${machine}" = "${local_machine}" ]]; then
      if tmux has-session -t "${session}" 2>/dev/null; then
        echo "Session: Running (${session})"
        echo "Attach:  v0 attach ${NAME}"
      else
        echo "Session: Stopped (was ${session})"
      fi
    else
      echo "Session: ${session} (on ${machine})"
      echo "Attach:  ssh ${machine} -t 'v0 attach ${NAME}'"
    fi
  fi

  if [[ -n "${current_issue}" ]]; then
    echo "Current: ${current_issue}"
  fi
  echo "Completed: ${completed} issues"

  if [[ -n "${last_activity}" ]]; then
    echo "Last Activity: ${last_activity}"
  fi

  # Show merge status if queued
  if [[ "${merge_queued}" = "true" ]]; then
    echo ""
    echo "Merge:"
    if [[ -n "${merge_status}" ]]; then
      case "${merge_status}" in
        merged)
          echo "  Status: Merged at ${merged_at}"
          ;;
        merging)
          echo "  Status: Merge in progress..."
          ;;
        conflict)
          # worktree already read in batch
          echo "  Status: CONFLICTS - needs resolution"
          echo "  Resolve: v0 merge ${worktree} --resolve"
          ;;
        failed)
          # merge_error already read in batch above (Phase 5 optimization)
          echo "  Status: FAILED - ${merge_error}"
          ;;
        *)
          echo "  Status: ${merge_status}"
          ;;
      esac
    else
      echo "  Status: Queued (waiting for completion)"
    fi
  fi

  echo ""
  if [[ -n "${feature_id}" ]]; then
    echo "Issue Status:"
    local total open closed in_progress
    total=$(wk list --label "plan:${NAME}" 2>/dev/null | wc -l | tr -d ' ')
    open=$(wk list --label "plan:${NAME}" --status todo 2>/dev/null | wc -l | tr -d ' ')
    in_progress=$(wk list --label "plan:${NAME}" --status in_progress 2>/dev/null | wc -l | tr -d ' ')
    closed=$(wk list --label "plan:${NAME}" --status "done" 2>/dev/null | wc -l | tr -d ' ')

    echo "  Total: ${total}  Open: ${open}  In Progress: ${in_progress}  Closed: ${closed}"
    echo ""
    echo "Commands:"
    echo "  wk list --label plan:${NAME}          # All issues"
    echo "  wk ready --label plan:${NAME}         # Ready to work"
    echo "  wk list --label plan:${NAME} --status in_progress  # Active"
  fi
}

if [[ -n "${WATCH}" ]]; then
  while true; do
    clear
    show_status
    echo ""
    echo "(Refreshing every 5s, Ctrl+C to stop)"
    sleep 5
  done
else
  show_status
fi
