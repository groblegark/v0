#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/lib/v0-common.sh"
v0_load_config

# Source coffee functions for status display
source "${V0_DIR}/lib/coffee-common.sh"

# Source nudge functions for status display
source "${V0_DIR}/lib/nudge-common.sh"

usage() {
  cat <<EOF
Usage: v0 status [name] [options]

Check status of build operations.

Options:
  --list         List all operations (default)
  --blocked      List only waiting operations (using --after)
  --merge        Show merge queue status
  --fix          Show fix worker status
  --chore        Show chore worker status
  --recent       Show recently completed bugs/chores
  --watch        Watch for live updates
  --json         Output as JSON

Examples:
  v0 status                # List all operations (default)
  v0 status auth           # Check auth operation
  v0 status --merge        # Show merge queue
  v0 status --fix          # Show fix worker status
  v0 status --chore        # Show chore worker status
  v0 status auth --watch   # Live updates

See also:
  v0 prune                 # Remove completed/cancelled operations
EOF
  exit 1
}

# Helper function to show bugs with indentation
show_bugs_indented() {
  local limit="$1"
  local in_progress open

  in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
  open=$(wk list --type bug --status todo 2>/dev/null || true)

  if [[ -z "${in_progress}" ]] && [[ -z "${open}" ]]; then
    echo -e "  Bugs: ${C_DIM}none${C_RESET}"
    return
  fi

  if [[ -n "${in_progress}" ]]; then
    local count
    count=$(echo "${in_progress}" | wc -l | tr -d ' ')
    echo "  In progress:"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${in_progress}" | sed 's/^/    /'
    else
      echo "${in_progress}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi

  if [[ -n "${open}" ]]; then
    local count
    count=$(echo "${open}" | wc -l | tr -d ' ')
    echo "  Queued:"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${open}" | sed 's/^/    /'
    else
      echo "${open}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi
}

# Helper function to show merge queue with indentation
show_mergeq_indented() {
  local limit="$1"
  local queue_file="${BUILD_DIR}/mergeq/queue.json"

  if [[ ! -f "${queue_file}" ]]; then
    echo -e "  Merges: ${C_DIM}none${C_RESET}"
    return
  fi

  local entries total
  entries=$(jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${queue_file}" 2>/dev/null || true)

  if [[ -z "${entries}" ]]; then
    echo -e "  Merges: ${C_DIM}none${C_RESET}"
  else
    total=$(echo "${entries}" | wc -l | tr -d ' ')

    echo "  Merges:"
    if [[ "${total}" -le "${limit}" ]]; then
      echo "${entries}" | while IFS=$'\t' read -r status op; do
        local status_color="${C_CYAN}"
        [[ "${status}" = "pending" ]] && status_color=""
        printf "    ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
      done
    else
      echo "${entries}" | head -n "${limit}" | while IFS=$'\t' read -r status op; do
        local status_color="${C_CYAN}"
        [[ "${status}" = "pending" ]] && status_color=""
        printf "    ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
      done
      local remaining=$((total - limit))
      echo -e "    ${C_DIM}... and ${remaining} more in queue${C_RESET}"
    fi
  fi
}

# Helper function to show chores with indentation
show_chores_indented() {
  local limit="$1"
  local in_progress open

  in_progress=$(wk list --type chore --status in_progress 2>/dev/null || true)
  open=$(wk list --type chore --status todo 2>/dev/null || true)

  if [[ -z "${in_progress}" ]] && [[ -z "${open}" ]]; then
    echo -e "  Chores: ${C_DIM}none${C_RESET}"
    return
  fi

  if [[ -n "${in_progress}" ]]; then
    local count
    count=$(echo "${in_progress}" | wc -l | tr -d ' ')
    echo "  In progress:"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${in_progress}" | sed 's/^/    /'
    else
      echo "${in_progress}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi

  if [[ -n "${open}" ]]; then
    local count
    count=$(echo "${open}" | wc -l | tr -d ' ')
    echo "  Queued:"
    if [[ "${count}" -le "${limit}" ]]; then
      echo "${open}" | sed 's/^/    /'
    else
      echo "${open}" | head -n "${limit}" | sed 's/^/    /'
      local remaining=$((count - limit))
      echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
    fi
  fi
}

# Convert ISO 8601 timestamp to epoch (macOS compatible)
# Note: Timestamps with Z suffix are UTC, so we parse in UTC timezone
timestamp_to_epoch() {
  local ts="$1"
  local formatted
  formatted=$(echo "${ts}" | sed 's/T/ /; s/Z$//; s/\.[0-9]*//')
  TZ=UTC date -j -f "%Y-%m-%d %H:%M:%S" "${formatted}" +%s 2>/dev/null
}

# Format elapsed time as human-readable string
format_elapsed() {
  local seconds="$1"
  if [[ "${seconds}" -lt 60 ]]; then
    echo "just now"
  elif [[ "${seconds}" -lt 3600 ]]; then
    local mins=$((seconds / 60))
    echo "${mins} min ago"
  elif [[ "${seconds}" -lt 86400 ]]; then
    local hours=$((seconds / 3600))
    echo "${hours} hr ago"
  else
    local days=$((seconds / 86400))
    echo "${days} day ago"
  fi
}

# Get recently merged operations (features/builds)
# Args: $1 = hours to look back (default: 72)
# Output: name|merged_at (one per line, sorted most recent first)
get_merged_operations() {
  local since_hours="${1:-72}"
  local cutoff_time
  cutoff_time=$(date -v-"${since_hours}"H +%s 2>/dev/null || date -d "${since_hours} hours ago" +%s 2>/dev/null || echo 0)

  if [[ ! -d "${BUILD_DIR}/operations" ]]; then
    return
  fi

  for state_file in "${BUILD_DIR}/operations"/*/state.json; do
    [[ -f "${state_file}" ]] || continue
    # Single jq call extracts all needed fields
    local name merge_status merged_at
    read -r name merge_status merged_at < <(
      jq -r '[.name, (.merge_status // ""), (.merged_at // "")] | @tsv' "${state_file}" 2>/dev/null
    )

    if [[ "${merge_status}" = "merged" ]] && [[ -n "${merged_at}" ]]; then
      local merged_epoch
      merged_epoch=$(timestamp_to_epoch "${merged_at}")
      if [[ -n "${merged_epoch}" ]] && [[ "${merged_epoch}" -ge "${cutoff_time}" ]]; then
        echo "${name}|${merged_at}"
      fi
    fi
  done | sort -t'|' -k2 -r
}

# Get recently completed bugs
# Args: $1 = hours to look back (default: 72), $2 = max results (optional)
# Output: id|title|updated_at (one per line, filtered by recency)
get_completed_bugs() {
  local since_hours="${1:-72}"
  local limit="${2:-}"

  local json_output limit_arg=""
  [[ -n "${limit}" ]] && limit_arg="--limit ${limit}"
  # Use wk list filter to efficiently get only recently updated bugs
  json_output=$(wk list --type bug --status "done" --format json -q "updated < ${since_hours}h" ${limit_arg:+"${limit_arg}"} 2>/dev/null) || return
  [[ -z "${json_output}" ]] && return

  # wk list --format json doesn't include updated_at, so we fetch from wk show for display
  echo "${json_output}" | jq -r '.issues[] | .id' 2>/dev/null | while read -r id; do
    [[ -z "${id}" ]] && continue
    local issue_json title updated_at
    issue_json=$(wk show "${id}" --format json 2>/dev/null) || continue
    title=$(echo "${issue_json}" | jq -r '.title // .summary // "Untitled"' 2>/dev/null)
    updated_at=$(echo "${issue_json}" | jq -r '.updated_at // .closed_at // ""' 2>/dev/null)
    echo "${id}|${title}|${updated_at}"
  done
}

# Get recently completed chores
# Args: $1 = hours to look back (default: 72), $2 = max results (optional)
# Output: id|title|updated_at (one per line, filtered by recency)
get_completed_chores() {
  local since_hours="${1:-72}"
  local limit="${2:-}"

  local json_output limit_arg=""
  [[ -n "${limit}" ]] && limit_arg="--limit ${limit}"
  # Use wk list filter to efficiently get only recently updated chores
  json_output=$(wk list --type chore --status "done" --format json -q "updated < ${since_hours}h" ${limit_arg:+"${limit_arg}"} 2>/dev/null) || return
  [[ -z "${json_output}" ]] && return

  # wk list --format json doesn't include updated_at, so we fetch from wk show for display
  echo "${json_output}" | jq -r '.issues[] | .id' 2>/dev/null | while read -r id; do
    [[ -z "${id}" ]] && continue
    local issue_json title updated_at
    issue_json=$(wk show "${id}" --format json 2>/dev/null) || continue
    title=$(echo "${issue_json}" | jq -r '.title // .summary // "Untitled"' 2>/dev/null)
    updated_at=$(echo "${issue_json}" | jq -r '.updated_at // .closed_at // ""' 2>/dev/null)
    echo "${id}|${title}|${updated_at}"
  done
}

# Show recently completed section in status output
# Args: $1 = max items per category (default: 5)
show_recently_completed() {
  local max_items="${1:-5}"
  local completed_bugs completed_chores

  # Fetch data first to check if there's anything to show
  completed_bugs=$(get_completed_bugs 72 $((max_items + 1)))
  completed_chores=$(get_completed_chores 72 $((max_items + 1)))

  # If nothing to show, omit the entire section
  if [[ -z "${completed_bugs}" ]] && [[ -z "${completed_chores}" ]]; then
    return
  fi

  echo ""
  echo "Recently Completed:"

  # Show completed bugs
  if [[ -n "${completed_bugs}" ]]; then
    echo "  Bugs:"
    echo "${completed_bugs}" | head -n "${max_items}" | while IFS='|' read -r id title updated_at; do
      local display_title="${title:0:50}"
      [[ ${#title} -gt 50 ]] && display_title="${display_title}..."
      if [[ -n "${updated_at}" ]]; then
        local now_epoch updated_epoch elapsed_sec elapsed
        now_epoch=$(date +%s)
        updated_epoch=$(timestamp_to_epoch "${updated_at}")
        if [[ -n "${updated_epoch}" ]] && [[ "${updated_epoch}" -gt 0 ]]; then
          elapsed_sec=$((now_epoch - updated_epoch))
          elapsed=$(format_elapsed "${elapsed_sec}")
          echo "    - ${id}: ${display_title} (${elapsed})"
        else
          echo "    - ${id}: ${display_title}"
        fi
      else
        echo "    - ${id}: ${display_title}"
      fi
    done
    local total
    total=$(echo "${completed_bugs}" | wc -l | tr -d ' ')
    if [[ "${total}" -gt "${max_items}" ]]; then
      echo "    ... and more"
    fi
  fi

  # Show completed chores
  if [[ -n "${completed_chores}" ]]; then
    echo "  Chores:"
    echo "${completed_chores}" | head -n "${max_items}" | while IFS='|' read -r id title updated_at; do
      local display_title="${title:0:50}"
      [[ ${#title} -gt 50 ]] && display_title="${display_title}..."
      if [[ -n "${updated_at}" ]]; then
        local now_epoch updated_epoch elapsed_sec elapsed
        now_epoch=$(date +%s)
        updated_epoch=$(timestamp_to_epoch "${updated_at}")
        if [[ -n "${updated_epoch}" ]] && [[ "${updated_epoch}" -gt 0 ]]; then
          elapsed_sec=$((now_epoch - updated_epoch))
          elapsed=$(format_elapsed "${elapsed_sec}")
          echo "    - ${id}: ${display_title} (${elapsed})"
        else
          echo "    - ${id}: ${display_title}"
        fi
      else
        echo "    - ${id}: ${display_title}"
      fi
    done
    local total
    total=$(echo "${completed_chores}" | wc -l | tr -d ' ')
    if [[ "${total}" -gt "${max_items}" ]]; then
      echo "    ... and more"
    fi
  fi
}

NAME=""
LIST=""
BLOCKED=""
MERGE_QUEUE=""
BUGFIX=""
CHORE=""
WATCH=""
JSON=""
RECENT=""
NO_HINTS=""

while [[ $# -gt 0 ]]; do
  case "$1" in
    --list) LIST=1; shift ;;
    --blocked) BLOCKED=1; shift ;;
    --merge) MERGE_QUEUE=1; shift ;;
    --fix) FIX=1; shift ;;
    --bugfix) FIX=1; shift ;;  # Backwards compatibility
    --chore) CHORE=1; shift ;;
    --watch) WATCH=1; shift ;;
    --json) JSON=1; shift ;;
    --recent) RECENT=1; shift ;;
    --no-hints) NO_HINTS=1; shift ;;
    --prune|--prune-all)
      echo "Warning: $1 is deprecated. Use 'v0 prune' instead." >&2
      exec "${V0_DIR}/bin/v0-prune" "$@"
      ;;
    -h|--help) usage ;;
    -*) echo "Unknown option: $1"; usage ;;
    *) NAME="$1"; shift ;;
  esac
done

# Show merge queue status
if [[ -n "${MERGE_QUEUE}" ]]; then
  echo "Merge Queue Status:"
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --status
  echo ""
  "${V0_DIR}/bin/v0-mergeq" --list
  exit 0
fi

# Show fix status (condensed view)
if [[ -n "${FIX}" ]]; then
  # Use namespaced session names based on PROJECT
  fix_session="v0-${PROJECT}-worker-fix"
  fix_polling_log="/tmp/v0-${PROJECT}-fix-polling.log"

  # Check worker and polling daemon status
  fix_worker_running=false
  fix_polling_pid=""

  tmux has-session -t "${fix_session}" 2>/dev/null && fix_worker_running=true
  [[ -f "${fix_polling_log}" ]] && fix_polling_pid=$(pgrep -f "while true.*${fix_session}" 2>/dev/null || true)

  if [[ "${fix_worker_running}" = true ]]; then
    echo -e "Fix Worker: ${C_CYAN}Active${C_RESET} ${C_DIM}[tmux: ${fix_session}]${C_RESET}"
    echo -e "Attach with: v0 attach fix"
  elif [[ -n "${fix_polling_pid}" ]]; then
    echo -e "Fix Worker: ${C_YELLOW}Polling${C_RESET} ${C_DIM}[pid: ${fix_polling_pid}]${C_RESET}"
  else
    echo -e "Fix Worker: ${C_DIM}Stopped${C_RESET}"
  fi

  in_progress_bugs=$(wk list --type bug --status in_progress 2>/dev/null || true)
  open_bugs=$(wk list --type bug --status todo 2>/dev/null || true)

  if [[ -z "${in_progress_bugs}" ]] && [[ -z "${open_bugs}" ]]; then
    echo ""
    echo "No bugs available"
  else
    shown=3

    if [[ -n "${in_progress_bugs}" ]]; then
      echo ""
      echo "In Progress:"
      count=$(echo "${in_progress_bugs}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${in_progress_bugs}" | sed 's/^/  /'
      else
        echo "${in_progress_bugs}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi

    if [[ -n "${open_bugs}" ]]; then
      echo ""
      echo "Queued:"
      count=$(echo "${open_bugs}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${open_bugs}" | sed 's/^/  /'
      else
        echo "${open_bugs}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi
  fi
  exit 0
fi

# Show chore status (condensed view)
if [[ -n "${CHORE}" ]]; then
  # Use namespaced session names based on PROJECT
  chore_session="v0-${PROJECT}-worker-chore"
  chore_polling_log="/tmp/v0-${PROJECT}-chore-polling.log"

  # Check worker and polling daemon status
  chore_worker_running=false
  chore_polling_pid=""

  tmux has-session -t "${chore_session}" 2>/dev/null && chore_worker_running=true
  [[ -f "${chore_polling_log}" ]] && chore_polling_pid=$(pgrep -f "while true.*${chore_session}" 2>/dev/null || true)

  if [[ "${chore_worker_running}" = true ]]; then
    echo -e "Chore Worker: ${C_CYAN}Active${C_RESET} ${C_DIM}[tmux: ${chore_session}]${C_RESET}"
    echo -e "Attach with: v0 attach chore"
  elif [[ -n "${chore_polling_pid}" ]]; then
    echo -e "Chore Worker: ${C_YELLOW}Polling${C_RESET} ${C_DIM}[pid: ${chore_polling_pid}]${C_RESET}"
  else
    echo -e "Chore Worker: ${C_DIM}Stopped${C_RESET}"
  fi

  in_progress_chores=$(wk list --type chore --status in_progress 2>/dev/null || true)
  open_chores=$(wk list --type chore --status todo 2>/dev/null || true)

  if [[ -z "${in_progress_chores}" ]] && [[ -z "${open_chores}" ]]; then
    echo ""
    echo "No chores available"
  else
    shown=3

    if [[ -n "${in_progress_chores}" ]]; then
      echo ""
      echo "In Progress:"
      count=$(echo "${in_progress_chores}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${in_progress_chores}" | sed 's/^/  /'
      else
        echo "${in_progress_chores}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi

    if [[ -n "${open_chores}" ]]; then
      echo ""
      echo "Queued:"
      count=$(echo "${open_chores}" | wc -l | tr -d ' ')
      if [[ "${count}" -le "${shown}" ]]; then
        echo "${open_chores}" | sed 's/^/  /'
      else
        echo "${open_chores}" | head -n "${shown}" | sed 's/^/  /'
        remaining=$((count - shown))
        echo "  ... and ${remaining} more"
      fi
    fi
  fi
  exit 0
fi

# Default to --list if no arguments
if [[ -z "${NAME}" ]]; then
  LIST=1
fi

# List all operations (default behavior)
if [[ -n "${LIST}" ]] || [[ -n "${BLOCKED}" ]]; then
  if [[ -n "${BLOCKED}" ]]; then
    echo "Blocked Operations:"
  else
    echo "Operations:"
  fi
  echo ""

  # Batch tmux session check - single call to list all sessions (used by operations loop and workers)
  all_sessions=$(tmux list-sessions -F '#{session_name}' 2>/dev/null || true)
  local_machine=$(hostname -s)

  if [[ ! -d "${BUILD_DIR}/operations" ]]; then
    echo -e "  ${C_DIM}(no operations found)${C_RESET}"
  else

  # Collect all state files (bash 3.2 compatible)
  state_files=()
  for f in "${BUILD_DIR}"/operations/*/state.json; do
    [[ -f "${f}" ]] && state_files+=("${f}")
  done

  found_any=""
  # Process all state files in single jq -s invocation (one process instead of many)
  if [[ ${#state_files[@]} -gt 0 ]]; then
    while IFS=$'\t' read -r name op_type phase created machine completed merge_queued merge_status merged_at after session worker_pid held held_at; do
      [[ -z "${name}" ]] && continue
    # If --blocked filter, skip non-blocked operations
    if [[ -n "${BLOCKED}" ]]; then
      if [[ -z "${after}" ]] || [[ "${after}" = "null" ]]; then
        continue
      fi
    fi

    found_any=1

    # Check if session is running - uses batched all_sessions
    # Note: all_sessions only contains LOCAL tmux sessions, so if we find a match,
    # it's definitely running locally regardless of the machine field in state.json
    status_icon=""
    if [[ -n "${session}" ]] && [[ "${all_sessions}" == *"${session}"* ]]; then
      status_icon=" ${C_CYAN}(active)${C_RESET}"
    fi
    # Check if background worker is running
    if [[ -z "${status_icon}" ]] && [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
      if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
        status_icon=" ${C_CYAN}(bg-worker)${C_RESET}"
      fi
    fi

    # Add after indicator (only show for phases where operation is still waiting)
    after_icon=""
    if [[ -n "${after}" ]] && [[ "${after}" != "null" ]]; then
      case "${phase}" in
        executing|completed|pending_merge|merged|cancelled)
          # Don't show [after] for these phases - operation is already past waiting
          ;;
        *)
          after_icon=" ${C_YELLOW}[after ${after}]${C_RESET}"
          ;;
      esac
    fi

    # Add hold indicator
    hold_icon=""
    if [[ "${held}" = "true" ]]; then
      hold_icon=" ${C_YELLOW}[held]${C_RESET}"
    fi

    # Get queue entry status for merge display (only needed when merge_queued)
    queue_entry_status=""
    if [[ "${merge_queued}" = "true" ]]; then
      queue_file="${BUILD_DIR}/mergeq/queue.json"
      if [[ -f "${queue_file}" ]]; then
        queue_entry_status=$(jq -r ".entries[] | select(.operation == \"${name}\") | .status" "${queue_file}" 2>/dev/null || true)
      fi
    fi

    # Use shared helper for phase display formatting
    IFS='|' read -r raw_display raw_merge_icon <<< \
      "$(_sm_format_phase_display "${phase}" "${op_type}" "${merge_queued}" "${merge_status}" "${merged_at}" "${queue_entry_status}")"

    # Get colors for display
    phase_color=$(_sm_get_phase_color "${raw_display}" "${raw_merge_icon}")
    merge_color=$(_sm_get_merge_icon_color "${raw_merge_icon}")

    # Apply colors to display_phase
    if [[ -n "${phase_color}" ]]; then
      display_phase="$(sm_get_status_color "${phase_color}")${raw_display}${C_RESET}"
    else
      display_phase="${raw_display}"
    fi

    # Apply colors to merge_icon
    merge_icon=""
    if [[ -n "${raw_merge_icon}" ]]; then
      if [[ -n "${merge_color}" ]]; then
        # Special formatting for certain merge icons
        case "${raw_merge_icon}" in
          "(merged)")
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_DIM}${raw_merge_icon}${C_RESET}"
            ;;
          "(== MERGE FAILED =="*|"(== CONFLICT =="*|"(== NEEDS MERGE =="*)
            merge_icon=" $(sm_get_status_color "${merge_color}")${C_BOLD}${raw_merge_icon}${C_RESET}"
            ;;
          *)
            merge_icon=" $(sm_get_status_color "${merge_color}")${raw_merge_icon}${C_RESET}"
            ;;
        esac
      else
        merge_icon=" ${raw_merge_icon}"
      fi
    fi

    # Update status_icon for specific phase/activity combinations
    # Use () for active status indicators, [] for conditions like [held] or [after ...]
    case "${phase}" in
      init)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(planning...)${C_RESET}"
        ;;
      planned)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(decomposing...)${C_RESET}"
        ;;
      queued|executing)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_CYAN}(building...)${C_RESET}"
        ;;
      blocked)
        [[ -n "${status_icon}" ]] && status_icon=" ${C_YELLOW}(waiting...)${C_RESET}"
        ;;
      failed)
        status_icon=" ${C_RED}${C_BOLD}(== ERROR ==)${C_RESET}"
        ;;
      interrupted)
        status_icon=" ${C_RED}${C_BOLD}(== INTERRUPTED ==)${C_RESET}"
        ;;
    esac

    printf "  %-20s %b%b%b%b%b ${C_DIM}(created: %s)${C_RESET}\n" "${name}:" "${display_phase}" "${status_icon}" "${after_icon}" "${hold_icon}" "${merge_icon}" "${created}"
    done < <(jq -rs 'sort_by(.created_at) | .[] | [
      .name,
      (.type // "build"),
      .phase,
      .created_at,
      (.machine // "unknown"),
      (.completed | length),
      (.merge_queued // false),
      (.merge_status // ""),
      (.merged_at // ""),
      (.after // ""),
      (.tmux_session // ""),
      (.worker_pid // ""),
      (.held // false),
      (.held_at // "")
    ] | @tsv' "${state_files[@]}")
  fi

  if [[ -z "${found_any}" ]]; then
    if [[ -n "${BLOCKED}" ]]; then
      echo -e "  ${C_DIM}(no waiting operations)${C_RESET}"
    else
      echo -e "  ${C_DIM}(no operations found)${C_RESET}"
    fi
  fi
  fi

  # Show fix, chore, and merge worker status in default list (not blocked view)
  if [[ -z "${BLOCKED}" ]]; then
    # Use namespaced session names based on PROJECT
    fix_session="v0-${PROJECT}-worker-fix"
    fix_polling_log="/tmp/v0-${PROJECT}-fix-polling.log"
    chore_session="v0-${PROJECT}-worker-chore"
    chore_polling_log="/tmp/v0-${PROJECT}-chore-polling.log"

    # Batch pgrep for all polling daemons - single call
    all_polling=$(pgrep -af "while true.*v0-${PROJECT}" 2>/dev/null || true)

    # Pre-check if all work queues are empty
    bugs_in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
    bugs_open=$(wk list --type bug --status todo 2>/dev/null || true)
    chores_in_progress=$(wk list --type chore --status in_progress 2>/dev/null || true)
    chores_open=$(wk list --type chore --status todo 2>/dev/null || true)
    mergeq_queue_file="${BUILD_DIR}/mergeq/queue.json"
    merges_pending=""
    if [[ -f "${mergeq_queue_file}" ]]; then
      merges_pending=$(jq -r '.entries[] | select(.status == "pending" or .status == "processing") | .operation' "${mergeq_queue_file}" 2>/dev/null || true)
    fi

    bugs_empty=false
    chores_empty=false
    merges_empty=false
    [[ -z "${bugs_in_progress}" ]] && [[ -z "${bugs_open}" ]] && bugs_empty=true
    [[ -z "${chores_in_progress}" ]] && [[ -z "${chores_open}" ]] && chores_empty=true
    [[ -z "${merges_pending}" ]] && merges_empty=true

    # If all queues are empty, show each on its own line
    if [[ "${bugs_empty}" = true ]] && [[ "${chores_empty}" = true ]] && [[ "${merges_empty}" = true ]]; then
      echo ""
      echo -e "Bugfix: ${C_DIM}None${C_RESET}"
      echo -e "Chores: ${C_DIM}None${C_RESET}"
      echo -e "Merges: ${C_DIM}None${C_RESET}"
    else
      # Show full sections for non-empty queues
      echo ""

      # Bugfix section
      fix_worker_running=false
      fix_polling_pid=""
      [[ "${all_sessions}" == *"${fix_session}"* ]] && fix_worker_running=true
      [[ -f "${fix_polling_log}" ]] && fix_polling_pid=$(echo "${all_polling}" | grep "worker-fix" | awk '{print $1}')
      if [[ "${fix_worker_running}" = true ]]; then
        echo -e "Bugfix: ${C_CYAN}Active${C_RESET}"
      elif [[ -n "${fix_polling_pid}" ]]; then
        echo -e "Bugfix: ${C_YELLOW}Polling${C_RESET}"
      elif [[ "${bugs_empty}" = true ]]; then
        echo -e "Bugfix: ${C_DIM}None${C_RESET}"
      else
        echo -e "Bugfix: ${C_DIM}Stopped${C_RESET}"
      fi
      if [[ "${bugs_empty}" != true ]]; then
        if [[ -n "${bugs_in_progress}" ]]; then
          count=$(echo "${bugs_in_progress}" | wc -l | tr -d ' ')
          echo "  In progress:"
          if [[ "${count}" -le 3 ]]; then
            echo "${bugs_in_progress}" | sed 's/^/    /'
          else
            echo "${bugs_in_progress}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
        if [[ -n "${bugs_open}" ]]; then
          count=$(echo "${bugs_open}" | wc -l | tr -d ' ')
          echo "  Queued:"
          if [[ "${count}" -le 3 ]]; then
            echo "${bugs_open}" | sed 's/^/    /'
          else
            echo "${bugs_open}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
      fi
      [[ "${bugs_empty}" != true ]] && echo ""

      # Chores section
      chore_worker_running=false
      chore_polling_pid=""
      [[ "${all_sessions}" == *"${chore_session}"* ]] && chore_worker_running=true
      [[ -f "${chore_polling_log}" ]] && chore_polling_pid=$(echo "${all_polling}" | grep "worker-chore" | awk '{print $1}')
      if [[ "${chore_worker_running}" = true ]]; then
        echo -e "Chores: ${C_CYAN}Active${C_RESET}"
      elif [[ -n "${chore_polling_pid}" ]]; then
        echo -e "Chores: ${C_YELLOW}Polling${C_RESET}"
      elif [[ "${chores_empty}" = true ]]; then
        echo -e "Chores: ${C_DIM}None${C_RESET}"
      else
        echo -e "Chores: ${C_DIM}Stopped${C_RESET}"
      fi
      if [[ "${chores_empty}" != true ]]; then
        if [[ -n "${chores_in_progress}" ]]; then
          count=$(echo "${chores_in_progress}" | wc -l | tr -d ' ')
          echo "  In progress:"
          if [[ "${count}" -le 3 ]]; then
            echo "${chores_in_progress}" | sed 's/^/    /'
          else
            echo "${chores_in_progress}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
        if [[ -n "${chores_open}" ]]; then
          count=$(echo "${chores_open}" | wc -l | tr -d ' ')
          echo "  Queued:"
          if [[ "${count}" -le 3 ]]; then
            echo "${chores_open}" | sed 's/^/    /'
          else
            echo "${chores_open}" | head -n 3 | sed 's/^/    /'
            remaining=$((count - 3))
            echo -e "    ${C_DIM}... and ${remaining} more${C_RESET}"
          fi
        fi
      fi
      [[ "${chores_empty}" != true ]] && echo ""

      # Merges section
      mergeq_pid_file="${BUILD_DIR}/mergeq/.daemon.pid"
      if [[ -f "${mergeq_pid_file}" ]] && kill -0 "$(cat "${mergeq_pid_file}" 2>/dev/null)" 2>/dev/null; then
        # Single jq call extracts both processing and pending counts
        read -r processing pending < <(
          jq -r '[
            ([.entries[] | select(.status == "processing")] | length),
            ([.entries[] | select(.status == "pending")] | length)
          ] | @tsv' "${mergeq_queue_file}" 2>/dev/null || echo "0	0"
        )
        if [[ "${processing}" -gt 0 ]]; then
          echo -e "Merges: ${C_CYAN}Active${C_RESET}"
        elif [[ "${pending}" -gt 0 ]]; then
          echo -e "Merges: ${C_CYAN}Active${C_RESET}"
        else
          echo -e "Merges: ${C_YELLOW}Polling${C_RESET}"
        fi
      elif [[ "${merges_empty}" = true ]]; then
        echo -e "Merges: ${C_DIM}None${C_RESET}"
      else
        echo -e "Merges: ${C_DIM}Stopped${C_RESET}"
      fi
      if [[ "${merges_empty}" != true ]]; then
        total=$(echo "${merges_pending}" | wc -l | tr -d ' ')
        if [[ "${total}" -le 3 ]]; then
          jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${mergeq_queue_file}" 2>/dev/null | while IFS=$'\t' read -r status op; do
            status_color="${C_CYAN}"
            [[ "${status}" = "pending" ]] && status_color=""
            printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
          done
        else
          jq -r '.entries[] | select(.status == "pending" or .status == "processing") | "\(.status)\t\(.operation)"' "${mergeq_queue_file}" 2>/dev/null | head -n 3 | while IFS=$'\t' read -r status op; do
            status_color="${C_CYAN}"
            [[ "${status}" = "pending" ]] && status_color=""
            printf "  ${status_color}%-12s${C_RESET} %s\n" "[${status}]" "${op}"
          done
          remaining=$((total - 3))
          echo -e "  ${C_DIM}... and ${remaining} more in queue${C_RESET}"
        fi
      fi
    fi

    # Show coffee and nudge status on one line
    echo ""
    coffee_status=""
    nudge_status=""
    if coffee_is_running; then
      coffee_pid_val=$(coffee_pid)
      coffee_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${coffee_pid_val}]${C_RESET}"
    else
      coffee_status="${C_DIM}Stopped${C_RESET}"
    fi
    if nudge_running; then
      nudge_pid_val=$(cat "$(nudge_pid_file)" 2>/dev/null || true)
      nudge_status="${C_GREEN}Running${C_RESET} ${C_DIM}[pid: ${nudge_pid_val}]${C_RESET}"
    else
      nudge_status="${C_DIM}Stopped${C_RESET}"
    fi
    echo -e "Coffee: ${coffee_status}"
    echo -e "Nudge: ${nudge_status}"

    # Show recently completed items (opt-in to avoid N+1 queries)
    if [[ -n "${RECENT}" ]]; then
      show_recently_completed 3
    fi
  fi

  if [[ -z "${NO_HINTS}" ]]; then
    echo ""
    echo "Run with --help for more options"
  fi
  exit 0
fi

# Check operation exists using state machine
if ! sm_state_exists "${NAME}"; then
  echo "Error: No operation found for '${NAME}'"
  exit 1
fi

show_status() {
  # Batch read all state fields in single jq invocation (instead of 20+ separate calls)
  local phase op_type feature_id machine session current_issue last_activity \
        merge_queued merge_status merged_at after eager worker_pid worker_log \
        worker_started_at error_msg held held_at worktree
  IFS=$'\t' read -r phase op_type feature_id machine session current_issue \
    last_activity merge_queued merge_status merged_at after eager worker_pid \
    worker_log worker_started_at error_msg held held_at worktree <<< \
    "$(sm_read_state_fields "${NAME}" phase type epic_id machine tmux_session \
       current_issue last_activity merge_queued merge_status merged_at \
       after eager worker_pid worker_log worker_started_at error held held_at worktree)"

  # Handle defaults for fields that need them
  [[ -z "${op_type}" ]] && op_type="build"
  [[ -z "${merge_queued}" ]] && merge_queued="false"
  [[ -z "${eager}" ]] && eager="false"
  [[ -z "${held}" ]] && held="false"

  # Get completed count separately (requires array length calculation)
  local completed
  completed=$(sm_read_state "${NAME}" "completed | length")
  [[ -z "${completed}" ]] && completed=0

  local local_machine
  local_machine=$(hostname -s)

  if [[ -n "${JSON}" ]]; then
    cat "$(sm_get_state_file "${NAME}")"
    return
  fi

  echo "=== Operation: ${NAME} ==="
  echo "Type: ${op_type}"

  # Show user-friendly status
  case "${phase}" in
    merged)
      echo "Status: completed (merged)"
      ;;
    completed|pending_merge)
      # Plan-type operations don't merge, so show "plan completed" without merge indicators
      if [[ "${op_type}" = "plan" ]]; then
        echo "Status: plan completed"
      elif [[ "${merge_queued}" = "true" ]]; then
        # Always check queue status first - it's more authoritative than state.json
        # The queue reflects actual merge attempts, while state.json may be stale
        local queue_file="${BUILD_DIR}/mergeq/queue.json"
        local queue_entry_status=""
        if [[ -f "${queue_file}" ]]; then
          queue_entry_status=$(jq -r ".entries[] | select(.operation == \"${NAME}\") | .status" "${queue_file}" 2>/dev/null || true)
        fi
        case "${queue_entry_status}" in
          pending|processing)
            echo "Status: completed (merging...)"
            ;;
          completed)
            echo "Status: completed (merged)"
            ;;
          failed)
            echo "Status: completed (== MERGE FAILED ==)"
            ;;
          conflict)
            echo "Status: completed (== CONFLICT ==)"
            ;;
          resumed)
            echo "Status: completed (== NEEDS MERGE ==)"
            ;;
          *)
            # No queue entry - fall back to state.json indicators
            if [[ "${merge_status}" = "merged" ]]; then
              echo "Status: completed (merged)"
            elif [[ "${merge_status}" = "conflict" ]]; then
              echo "Status: completed (== CONFLICT ==)"
            elif [[ -n "${merged_at}" ]] && [[ "${merged_at}" != "null" ]]; then
              echo "Status: completed (merged)"
            else
              echo "Status: completed (merge pending)"
            fi
            ;;
        esac
      else
        echo "Status: completed (== NEEDS MERGE ==)"
        # worktree already read in batch, branch is session (tmux_session)
        local branch="${session}"
        if [[ -n "${worktree}" ]] && [[ -d "${worktree}" ]]; then
          echo "  Merge: v0 merge ${worktree}"
        elif [[ -n "${branch}" ]] && git rev-parse --verify "${branch}" >/dev/null 2>&1; then
          echo "  Merge: git merge ${branch}  (worktree missing)"
        else
          echo "  (no branch or worktree found - may need cleanup)"
        fi
      fi
      ;;
    *)
      echo "Status: ${phase}"
      ;;
  esac

  echo "Machine: ${machine}"
  echo "Feature: ${feature_id:-N/A}"

  # Show hold status if held
  if [[ "${held}" = "true" ]]; then
    echo ""
    echo "Hold:"
    echo "  Status: HELD (since ${held_at})"
    echo "  Release: v0 resume ${NAME}"
  fi

  # Show after info if applicable
  if [[ -n "${after}" ]] && [[ "${after}" != "null" ]]; then
    echo ""
    echo "After: ${after}"
    [[ "${eager}" = "true" ]] && echo "Mode: eager (plan first)" || echo "Mode: wait first"

    # Use state machine to get after operation status
    local after_phase
    if sm_state_exists "${after}"; then
      after_phase=$(sm_get_phase "${after}")
      echo "Status: ${after_phase}"
    else
      echo "Status: unknown (operation not found)"
    fi
  fi

  # Show background worker info if applicable
  if [[ -n "${worker_pid}" ]] && [[ "${worker_pid}" != "null" ]]; then
    echo ""
    echo "Background Worker:"
    if [[ "${machine}" = "${local_machine}" ]] && kill -0 "${worker_pid}" 2>/dev/null; then
      echo "  Status: Running (pid: ${worker_pid})"
      if [[ -n "${worker_started_at}" ]] && [[ "${worker_started_at}" != "null" ]]; then
        local started_epoch now_epoch elapsed
        started_epoch=$(timestamp_to_epoch "${worker_started_at}")
        now_epoch=$(date +%s)
        if [[ -n "${started_epoch}" ]]; then
          elapsed=$((now_epoch - started_epoch))
          echo "  Started: $(format_elapsed "${elapsed}")"
        fi
      fi
    else
      echo "  Status: Stopped"
    fi
    if [[ -n "${worker_log}" ]] && [[ "${worker_log}" != "null" ]] && [[ -f "${worker_log}" ]]; then
      echo "  Log: ${worker_log}"
      echo ""
      echo "Recent activity:"
      tail -5 "${worker_log}" 2>/dev/null | sed 's/^/  /' || echo "  (no recent activity)"
    fi
  fi

  # Show error if phase is failed
  if [[ "${phase}" = "failed" ]] && [[ -n "${error_msg}" ]] && [[ "${error_msg}" != "null" ]]; then
    echo ""
    echo "Error: ${error_msg}"
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  # Show interrupted message
  if [[ "${phase}" = "interrupted" ]]; then
    echo ""
    echo "Worker was interrupted."
    echo ""
    echo "Resume with: v0 feature ${NAME} --resume"
  fi

  if [[ -n "${session}" ]]; then
    if [[ "${machine}" = "${local_machine}" ]]; then
      if tmux has-session -t "${session}" 2>/dev/null; then
        echo "Session: Running (${session})"
        echo "Attach:  v0 attach feature ${NAME}"
      else
        echo "Session: Stopped (was ${session})"
      fi
    else
      echo "Session: ${session} (on ${machine})"
      echo "Attach:  ssh ${machine} -t 'v0 attach feature ${NAME}'"
    fi
  fi

  if [[ -n "${current_issue}" ]]; then
    echo "Current: ${current_issue}"
  fi
  echo "Completed: ${completed} issues"

  if [[ -n "${last_activity}" ]]; then
    echo "Last Activity: ${last_activity}"
  fi

  # Show merge status if queued
  if [[ "${merge_queued}" = "true" ]]; then
    echo ""
    echo "Merge:"
    if [[ -n "${merge_status}" ]]; then
      case "${merge_status}" in
        merged)
          echo "  Status: Merged at ${merged_at}"
          ;;
        merging)
          echo "  Status: Merge in progress..."
          ;;
        conflict)
          # worktree already read in batch
          echo "  Status: CONFLICTS - needs resolution"
          echo "  Resolve: v0 merge ${worktree} --resolve"
          ;;
        failed)
          local merge_error
          merge_error=$(sm_read_state "${NAME}" "merge_error")
          echo "  Status: FAILED - ${merge_error}"
          ;;
        *)
          echo "  Status: ${merge_status}"
          ;;
      esac
    else
      echo "  Status: Queued (waiting for completion)"
    fi
  fi

  echo ""
  if [[ -n "${feature_id}" ]]; then
    echo "Issue Status:"
    local total open closed in_progress
    total=$(wk list --label "plan:${NAME}" 2>/dev/null | wc -l | tr -d ' ')
    open=$(wk list --label "plan:${NAME}" --status todo 2>/dev/null | wc -l | tr -d ' ')
    in_progress=$(wk list --label "plan:${NAME}" --status in_progress 2>/dev/null | wc -l | tr -d ' ')
    closed=$(wk list --label "plan:${NAME}" --status "done" 2>/dev/null | wc -l | tr -d ' ')

    echo "  Total: ${total}  Open: ${open}  In Progress: ${in_progress}  Closed: ${closed}"
    echo ""
    echo "Commands:"
    echo "  wk list --label plan:${NAME}          # All issues"
    echo "  wk ready --label plan:${NAME}         # Ready to work"
    echo "  wk list --label plan:${NAME} --status in_progress  # Active"
  fi
}

if [[ -n "${WATCH}" ]]; then
  while true; do
    clear
    show_status
    echo ""
    echo "(Refreshing every 5s, Ctrl+C to stop)"
    sleep 5
  done
else
  show_status
fi
