#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
V0_DIR="$(dirname "${SCRIPT_DIR}")"
ROOT_DIR="$(pwd)"  # Current directory where command was invoked

# Source shared utilities
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
source "${V0_DIR}/packages/cli/lib/history-format.sh"
source "${V0_DIR}/packages/worker/lib/worker-common.sh"
source "${V0_DIR}/packages/worker/lib/nudge-common.sh"

# Load project config (exits if not found)
v0_load_config

# Source branch status (warning if agent behind, info if ahead)
source "${V0_DIR}/packages/status/lib/branch-status.sh"
warn_branch_status || true

# Worker branch derived from develop branch (must be after v0_load_config)
WORKER_BRANCH=$(v0_worker_branch "fix")

# Initialize namespaced session names (must be after v0_load_config)
WORKER_SESSION=$(v0_session_name "worker" "fix")
POLLING_SESSION=$(v0_session_name "polling" "fix")
POLLING_LOG="/tmp/v0-${PROJECT}-fix-polling.log"

usage() {
  v0_help <<'EOF'
Usage: v0 fix [options] <bug description>
       v0 fix --status
       v0 fix --history

Simple sequential bug fixing.

Commands:
  <description>   Report a bug and ensure worker is running
  --status        Show worker state and pending bugs
  --logs          Show worker stdout/stderr logs
  --err           Show worker error logs
  --history       Show completed bugs and their fix details

Options:
  --after <ids>   Block this bug until specified issues complete
                  Accepts operation names or wok ticket IDs
                  (e.g., auth, v0-123, api-refactor,v0-456)
  --history       Show last 10 completed bugs
  --history=N     Show last N completed bugs
  --history=all   Show all completed bugs

Examples:
  v0 fix "Login button doesn't work on mobile"
  v0 fix --after v0-123 "Bug that depends on v0-123"
  v0 fix --after v0-1,v0-2 "Bug blocked by multiple issues"
  v0 fix --status
  v0 fix --logs
  v0 fix --err
  v0 fix --history
EOF
  exit 1
}

# Check dependencies
check_dep() {
  if ! command -v "$1" &> /dev/null; then
    echo "Error: $1 is required but not installed"
    exit 1
  fi
}

check_dep tmux
check_dep claude

# Ensure worker is running, start if not
ensure_worker_running() {
  if worker_running; then
    echo "Worker already running"
    return 0
  fi
  start_worker
}

# Start the worker
start_worker() {
  if worker_running || polling_running; then
    echo "Worker already running"
    return 0
  fi

  v0_trace "fix:worker" "Starting fix worker"

  # Create worktree with proper branch name
  local name="v0-fix-worker"
  local tree_output
  if ! tree_output=$("${SCRIPT_DIR}/v0-tree" "${name}" --branch "${WORKER_BRANCH}"); then
    echo "Error: Failed to create worktree for ${name}"
    exit 1
  fi
  WORKER_TREE_DIR=$(echo "${tree_output}" | head -1)
  WORKER_GIT_DIR=$(echo "${tree_output}" | tail -1)
  local tree_dir="${WORKER_TREE_DIR}"  # Alias for readability in this function

  # Save git dir, branch name, and current directory for later cleanup and reset
  setup_worker_markers "${tree_dir}" "${WORKER_GIT_DIR}" "${WORKER_BRANCH}"

  # Fast-forward worktree to latest develop branch
  v0_reset_to_develop "${WORKER_GIT_DIR}"

  # Link worktree to main repo's shared workspace
  rm -rf "${tree_dir}/.wok"
  link_to_workspace "${tree_dir}" "${ROOT_DIR}"

  # Write worker assignee role for this worktree
  mkdir -p "${tree_dir}/.wok/current"
  echo "worker:fix" > "${tree_dir}/.wok/current/assignee"

  # Copy worker instructions template
  cp "${V0_DIR}/packages/cli/lib/templates/claude.fix.md" "${tree_dir}/CLAUDE.md"

  # Create settings.local.json with Stop hook AND progress notification hook
  HOOK_SCRIPT="${V0_DIR}/packages/hooks/lib/stop-fix.sh"
  NOTIFY_HOOK="${V0_DIR}/packages/hooks/lib/notify-progress.sh"
  mkdir -p "${tree_dir}/.claude"
  cat > "${tree_dir}/.claude/settings.local.json" <<SETTINGS_EOF
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "${HOOK_SCRIPT}"
          }
        ]
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Bash",
        "hooks": [
          {
            "type": "command",
            "command": "V0_BUILD_DIR='${BUILD_DIR}' ${NOTIFY_HOOK}"
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "matcher": "",
        "hooks": [{"type": "command", "command": "wk prime"}]
      }
    ],
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [{"type": "command", "command": "wk prime"}]
      }
    ]
  }
}
SETTINGS_EOF

  # Create new-branch script (resets worktree to latest main)
  cat > "${tree_dir}/new-branch" <<NEW_BRANCH_SCRIPT
#!/bin/bash
set -e

BUG_ID="\$1"
if [[ -z "\$BUG_ID" ]]; then
  echo "Usage: ./new-branch <bug-id>"
  exit 1
fi

BRANCH="fix/\$BUG_ID"
STATE_DIR="${BUILD_DIR}/fix/\$BUG_ID"

# Derive paths from script location, not current working directory
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
WORKTREE_ROOT="\$SCRIPT_DIR"
GIT_DIR="\$WORKTREE_ROOT/${REPO_NAME}"

cd "\$GIT_DIR"

# Check if we're on a fix branch that needs to be completed first
CURRENT_BRANCH=\$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "")
if [[ "\$CURRENT_BRANCH" == fix/* ]]; then
  PREV_BUG_ID="\${CURRENT_BRANCH#fix/}"

  # Check if there are commits beyond origin develop branch
  COMMITS_AHEAD=\$(git rev-list --count "${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}..HEAD" 2>/dev/null || echo "0")

  if [[ "\$COMMITS_AHEAD" -gt 0 ]]; then
    echo "Found uncommitted fix on branch \$CURRENT_BRANCH"
    echo "Completing \$PREV_BUG_ID first..."

    PREV_BRANCH="\$CURRENT_BRANCH"
    PREV_STATE_DIR="${BUILD_DIR}/fix/\$PREV_BUG_ID"

    # Get commit info before pushing
    COMMIT_SHA=\$(git rev-parse HEAD)
    COMMIT_MSG=\$(git log -1 --format=%s)

    # Push current commits as fix/<id> branch
    echo "Pushing \$PREV_BRANCH..."
    git push -u "${V0_GIT_REMOTE}" "HEAD:refs/heads/\$PREV_BRANCH"

    # Update state file
    mkdir -p "\$PREV_STATE_DIR"
    cat > "\$PREV_STATE_DIR/state.json" <<STATE_EOF
{
  "issue_id": "\$PREV_BUG_ID",
  "branch": "\$PREV_BRANCH",
  "commit": "\$COMMIT_SHA",
  "commit_message": "\$(echo "\$COMMIT_MSG" | sed 's/"/\\\\"/g')",
  "pushed_at": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "pushed"
}
STATE_EOF

    # Queue for merge
    # Clear inherited MERGEQ_DIR/BUILD_DIR to prevent cross-project contamination
    # (tmux server may have inherited these from a different project)
    echo "Queueing for merge..."
    unset MERGEQ_DIR BUILD_DIR; "${V0_DIR}/bin/v0-mergeq" --enqueue "\$PREV_BRANCH" --issue-id "\$PREV_BUG_ID"

    # Transfer ownership to merge queue
    (cd "\$WORKTREE_ROOT" && wk edit "\$PREV_BUG_ID" assignee "worker:mergeq")

    # Close the bug (run from worktree root where .wok/config.toml has workspace setting)
    echo "Closing \$PREV_BUG_ID..."
    (cd "\$WORKTREE_ROOT" && wk done "\$PREV_BUG_ID")

    echo "Completed \$PREV_BUG_ID"
    echo ""
  fi
fi

# Reset worktree to latest develop branch
if git fetch "${V0_GIT_REMOTE}" "${V0_DEVELOP_BRANCH}" 2>/dev/null; then
  git reset --hard "${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}"
elif git rev-parse --verify "${V0_DEVELOP_BRANCH}" 2>/dev/null; then
  echo "Note: Remote branch '${V0_DEVELOP_BRANCH}' not found, using local" >&2
  git reset --hard "${V0_DEVELOP_BRANCH}"
else
  echo "Note: Branch '${V0_DEVELOP_BRANCH}' not found, creating from main" >&2
  git fetch "${V0_GIT_REMOTE}" main 2>/dev/null || true
  git branch -f "${V0_DEVELOP_BRANCH}" "${V0_GIT_REMOTE}/main" 2>/dev/null || true
  git reset --hard "${V0_DEVELOP_BRANCH}"
fi

# Record branch state for recovery
mkdir -p "\$STATE_DIR"
cat > "\$STATE_DIR/state.json" <<STATE_EOF
{
  "issue_id": "\$BUG_ID",
  "branch": "\$BRANCH",
  "started_at": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "started"
}
STATE_EOF

# Set assignee to this worker
(cd "\$WORKTREE_ROOT" && wk edit "\$BUG_ID" assignee "worker:fix")

echo "Reset to latest main"
echo "Ready to fix \$BUG_ID"
NEW_BRANCH_SCRIPT
  chmod +x "${tree_dir}/new-branch"

  # Create fixed script (push to fix/<id>, queue merge, close bug, reset to main)
  cat > "${tree_dir}/fixed" <<FIXED_SCRIPT
#!/bin/bash
set -e

BUG_ID="\$1"
if [[ -z "\$BUG_ID" ]]; then
  echo "Usage: ./fixed <bug-id>"
  exit 1
fi

BRANCH="fix/\$BUG_ID"
STATE_DIR="${BUILD_DIR}/fix/\$BUG_ID"

# Derive paths from script location, not current working directory
SCRIPT_DIR="\$(cd "\$(dirname "\${BASH_SOURCE[0]}")" && pwd)"
WORKTREE_ROOT="\$SCRIPT_DIR"
GIT_DIR="\$WORKTREE_ROOT/${REPO_NAME}"

cd "\$GIT_DIR"

# Check for commits beyond develop branch
COMMITS_AHEAD=\$(git rev-list --count "${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}..HEAD" 2>/dev/null || echo "0")

if [[ "\$COMMITS_AHEAD" -eq 0 ]]; then
  # No commits - check if there's a note explaining why
  NOTES_COUNT=\$(wk show "\$BUG_ID" -o json 2>/dev/null | jq '.notes | length' 2>/dev/null || echo "0")

  if [[ "\$NOTES_COUNT" -gt 0 ]]; then
    echo "Bug has note but no fix commits - handing to human for review"
    (cd "\$WORKTREE_ROOT" && wk edit "\$BUG_ID" assignee "worker:human") 2>/dev/null || true
    echo "Assigned \$BUG_ID to worker:human"
    # Exit cleanly without pushing or closing
    touch "${tree_dir}/.done-exit"
    exit 0
  else
    echo "Error: No commits to push and no notes explaining why"
    exit 1
  fi
fi

# Get commit info before pushing
COMMIT_SHA=\$(git rev-parse HEAD)
COMMIT_MSG=\$(git log -1 --format=%s)

# Push current commits as fix/<id> branch
echo "Pushing \$BRANCH..."
git push -u "${V0_GIT_REMOTE}" "HEAD:refs/heads/\$BRANCH"

# Update state file
mkdir -p "\$STATE_DIR"
cat > "\$STATE_DIR/state.json" <<STATE_EOF
{
  "issue_id": "\$BUG_ID",
  "branch": "\$BRANCH",
  "commit": "\$COMMIT_SHA",
  "commit_message": "\$(echo "\$COMMIT_MSG" | sed 's/"/\\\\"/g')",
  "pushed_at": "\$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "status": "pushed"
}
STATE_EOF

# Queue for merge with issue ID tracking (for logging/debugging)
# Clear inherited MERGEQ_DIR/BUILD_DIR to prevent cross-project contamination
# (tmux server may have inherited these from a different project)
echo "Queueing for merge..."
unset MERGEQ_DIR BUILD_DIR; "${V0_DIR}/bin/v0-mergeq" --enqueue "\$BRANCH" --issue-id "\$BUG_ID"

# Transfer ownership to merge queue
(cd "\$WORKTREE_ROOT" && wk edit "\$BUG_ID" assignee "worker:mergeq")

# Close the bug (run from worktree root where .wok/config.toml has workspace setting)
echo "Closing \$BUG_ID..."
(cd "\$WORKTREE_ROOT" && wk done "\$BUG_ID")

# Reset worktree to latest develop branch
echo "Resetting to latest ${V0_DEVELOP_BRANCH}..."
if git fetch "${V0_GIT_REMOTE}" "${V0_DEVELOP_BRANCH}" 2>/dev/null; then
  git reset --hard "${V0_GIT_REMOTE}/${V0_DEVELOP_BRANCH}"
elif git rev-parse --verify "${V0_DEVELOP_BRANCH}" 2>/dev/null; then
  echo "Note: Remote branch '${V0_DEVELOP_BRANCH}' not found, using local" >&2
  git reset --hard "${V0_DEVELOP_BRANCH}"
else
  echo "Note: Branch '${V0_DEVELOP_BRANCH}' not found, creating from main" >&2
  git fetch "${V0_GIT_REMOTE}" main 2>/dev/null || true
  git branch -f "${V0_DEVELOP_BRANCH}" "${V0_GIT_REMOTE}/main" 2>/dev/null || true
  git reset --hard "${V0_DEVELOP_BRANCH}"
fi

echo ""
echo "Completed \$BUG_ID"
echo "Branch \$BRANCH queued for merge"

# Exit Claude session to keep context window small
echo "Exiting session..."

# Mark clean exit
touch "${tree_dir}/.done-exit"

# Find and kill claude process
find_claude() {
  local pid=\$1
  while [[ -n "\$pid" ]] && [[ "\$pid" != "1" ]]; do
    local cmd
    cmd=\$(ps -o comm= -p "\$pid" 2>/dev/null)
    if [[ "\$cmd" == *"claude"* ]]; then
      echo "\$pid"
      return
    fi
    pid=\$(ps -o ppid= -p "\$pid" 2>/dev/null | tr -d ' ')
  done
}

CLAUDE_PID=\$(find_claude \$\$)
if [[ -n "\$CLAUDE_PID" ]]; then
  kill -TERM "\$CLAUDE_PID" 2>/dev/null || true
fi
exit 0
FIXED_SCRIPT
  chmod +x "${tree_dir}/fixed"

  # Create done script for worker
  # Create helper scripts using shared functions
  create_done_script "${tree_dir}" "fix"

  # Read CLAUDE.md and pass as instruction
  local claude_instruction
  claude_instruction="$(cat "${tree_dir}/CLAUDE.md")"
  create_wrapper_script "${tree_dir}" "claude-worker.log" "Claude Fix Worker" "v0 fix --err" "${V0_DIR}" claude --model opus --dangerously-skip-permissions --allow-dangerously-skip-permissions "${claude_instruction}"

  echo -e "Starting fix worker in tmux session: ${C_CYAN}${WORKER_SESSION}${C_RESET}"
  echo -e "Worktree: ${C_CYAN}${tree_dir}${C_RESET}"

  local wrapper_script="${tree_dir}/claude-worker.sh"

  # Ensure nudge worker is running to monitor the session
  ensure_nudge_running

  # Start the polling loop
  create_polling_loop "${tree_dir}" bug "${POLLING_LOG}"

  # Launch Claude for the first time
  tmux new-session -d -s "${WORKER_SESSION}" -c "${tree_dir}" "${wrapper_script}"

  # Verify the session started
  if tmux has-session -t "${WORKER_SESSION}" 2>/dev/null; then
    v0_trace "fix:worker" "Fix worker started (session: ${WORKER_SESSION})"
    echo -e "${C_GREEN}Worker started.${C_RESET} Use '${C_BOLD}v0 fix --status${C_RESET}' to check progress."
  else
    v0_trace "fix:worker:failed" "Failed to start fix worker tmux session"
    echo "Error: Failed to start worker tmux session" >&2
    return 1
  fi
}

# Stop the worker
stop_worker() {
  v0_trace "fix:worker" "Stopping fix worker"
  reopen_worker_issues "worker:fix"
  generic_stop_worker "${WORKER_SESSION}" "${WORKER_BRANCH}"
  v0_trace "fix:worker" "Fix worker stopped"
}

# Show status
show_status() {
  local in_progress open
  in_progress=$(wk list --type bug --status in_progress 2>/dev/null || true)
  open=$(wk list --type bug --status todo 2>/dev/null || true)

  # Count queued bugs for status message
  local open_count=0
  if [[ -n "${open}" ]]; then
    open_count=$(echo "${open}" | wc -l | tr -d ' ')
  fi

  if worker_running; then
    echo -e "Worker: ${C_CYAN}Active${C_RESET}"
    echo ""
    echo "Attach with: v0 attach fix"
  elif polling_running; then
    if [[ "${open_count}" -gt 0 ]]; then
      echo -e "Worker: ${C_YELLOW}Polling${C_RESET} (${open_count} bugs queued)"
    else
      echo -e "Worker: ${C_YELLOW}Polling${C_RESET} (waiting for bugs)"
    fi
  else
    echo -e "Worker: ${C_DIM}Stopped${C_RESET}"
  fi

  if [[ -z "${in_progress}" ]] && [[ -z "${open}" ]]; then
    echo ""
    echo "No bugs available"
    return 0
  fi

  local shown=5

  if [[ -n "${in_progress}" ]]; then
    echo ""
    echo "In Progress:"
    local count
    count=$(echo "${in_progress}" | wc -l | tr -d ' ')
    if [[ "${count}" -le "${shown}" ]]; then
      echo "${in_progress}" | sed 's/^/  /'
    else
      echo "${in_progress}" | head -n "${shown}" | sed 's/^/  /'
      local remaining=$((count - shown))
      echo "  ... and ${remaining} more"
    fi
  fi

  if [[ -n "${open}" ]]; then
    echo ""
    echo "Queued:"
    local count
    count=$(echo "${open}" | wc -l | tr -d ' ')
    if [[ "${count}" -le "${shown}" ]]; then
      echo "${open}" | sed 's/^/  /'
    else
      echo "${open}" | head -n "${shown}" | sed 's/^/  /'
      local remaining=$((count - shown))
      echo "  ... and ${remaining} more"
    fi
  fi
}

# View worker logs

# Report a bug
report_bug() {
  local input="$*"

  if [[ -z "${input}" ]]; then
    echo "Error: Bug description required"
    usage
  fi

  v0_trace "fix:report" "Reporting new bug"

  # Split at first double newline (paragraph break)
  local title description
  if [[ "${input}" == *$'\n\n'* ]]; then
    # Extract title (before double newline) and description (after)
    title="${input%%$'\n\n'*}"
    description="${input#*$'\n\n'}"
  else
    title="${input}"
    description=""
  fi

  # Create the bug (allow failure so we can show the error)
  local output id exit_code
  if [[ -n "${description}" ]]; then
    output=$(wk new bug "${title}" --description "${description}" -o id 2>&1) && exit_code=0 || exit_code=$?
  else
    output=$(wk new bug "${title}" -o id 2>&1) && exit_code=0 || exit_code=$?
  fi

  if [[ "${exit_code}" -ne 0 ]]; then
    echo "Error: Failed to create bug"
    echo "${output}"
    exit 1
  fi

  # -o id returns just the issue ID
  id="${output}"

  if [[ -z "${id}" ]]; then
    echo "Error: Failed to create bug (no ID returned)"
    exit 1
  fi

  # Add blocked-by dependencies if --after was specified
  if [[ ${#AFTER_IDS[@]} -gt 0 ]]; then
    # Resolve operation names to wok ticket IDs
    local resolved_ids=()
    for after_id in "${AFTER_IDS[@]}"; do
      local resolved
      if resolved=$(v0_resolve_to_wok_id "${after_id}"); then
        resolved_ids+=("${resolved}")
      else
        echo "Warning: Could not resolve '${after_id}' to a wok ticket ID (skipping)"
      fi
    done

    if [[ ${#resolved_ids[@]} -gt 0 ]]; then
      if ! wk dep "${id}" blocked-by "${resolved_ids[@]}" 2>/dev/null; then
        echo "Warning: Failed to add dependencies"
      else
        echo "  Blocked by: ${resolved_ids[*]}"
      fi
    fi
  fi

  v0_trace "fix:report" "Created bug ${id}"
  echo -e "${C_GREEN}Created bug:${C_RESET} ${C_CYAN}${id}${C_RESET}"
  echo "  Title:"
  echo "${title}" | fmt -w 76 | sed 's/^/    /'

  # Ensure worker is running
  ensure_worker_running
}

# Show bug history
show_history() {
  local limit="${1:-10}"
  local bugs
  bugs=$(wk list --type bug --status "done" 2>/dev/null || true)

  if [[ -z "${bugs}" ]]; then
    echo "No completed bugs"
    return 0
  fi

  echo "Completed Bugs:"
  echo ""

  local count=0
  while IFS= read -r line; do
    [[ "${count}" -ge "${limit}" ]] && break

    local id
    id=$(echo "${line}" | v0_grep_extract "$(v0_issue_pattern)" | head -1)
    [[ -z "${id}" ]] && continue

    local state_file="${BUILD_DIR}/fix/${id}/state.json"
    if [[ -f "${state_file}" ]]; then
      local pushed_at commit_msg
      pushed_at=$(v0_grep_extract '"pushed_at": "[^"]*"' "${state_file}" | cut -d'"' -f4)
      commit_msg=$(v0_grep_extract '"commit_message": "[^"]*"' "${state_file}" | cut -d'"' -f4)

      # Format date - relative for today, date for older
      local date_str
      date_str=$(format_timestamp "${pushed_at}")

      printf "%-12s (%s) %s\n" "${id}" "${date_str}" "${commit_msg}"
    else
      # No state file - show from wk list
      local title
      title=$(echo "${line}" | sed 's/^[^-]*-[^ ]* \[P[0-4]\] \[bug\] closed - //')
      printf "%-12s (no state) %s\n" "${id}" "${title}"
    fi

    count=$((count + 1))
  done <<< "${bugs}"
}

# Parse arguments
AFTER_IDS=()
ACTION=""
POSITIONAL=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --after)
      # Split comma-separated IDs and add to array
      IFS=',' read -ra ids <<< "$2"
      AFTER_IDS+=("${ids[@]}")
      shift 2
      ;;
    --after=*)
      IFS=',' read -ra ids <<< "${1#--after=}"
      AFTER_IDS+=("${ids[@]}")
      shift
      ;;
    --start)
      ACTION="start"
      shift
      ;;
    --stop)
      ACTION="stop"
      shift
      ;;
    --restart)
      ACTION="restart"
      shift
      ;;
    --status)
      ACTION="status"
      shift
      ;;
    --logs)
      ACTION="logs"
      shift
      ;;
    --err)
      ACTION="err"
      shift
      ;;
    --history)
      ACTION="history"
      HISTORY_LIMIT=10
      shift
      ;;
    --history=*)
      ACTION="history"
      arg="${1#--history=}"
      if [[ "${arg}" = "all" ]]; then
        HISTORY_LIMIT=999999
      else
        HISTORY_LIMIT="${arg}"
      fi
      shift
      ;;
    -h|--help)
      usage
      ;;
    --)
      echo "Error: Invalid argument '--'. Did you mean '--status'?"
      usage
      ;;
    --*)
      echo "Error: Unknown flag '$1'"
      echo "Run 'v0 fix --help' for usage"
      exit 1
      ;;
    -*)
      echo "Error: Unknown flag '$1'"
      echo "Run 'v0 fix --help' for usage"
      exit 1
      ;;
    attach)
      # Handle 'v0 fix attach' as alias for 'v0 attach fix'
      exec "${SCRIPT_DIR}/v0-attach" fix
      ;;
    status)
      # Auto-correct 'v0 fix status' to 'v0 fix --status'
      ACTION="status"
      shift
      ;;
    start)
      # Auto-correct 'v0 fix start' to 'v0 fix --start'
      ACTION="start"
      shift
      ;;
    stop)
      # Auto-correct 'v0 fix stop' to 'v0 fix --stop'
      ACTION="stop"
      shift
      ;;
    restart)
      # Auto-correct 'v0 fix restart' to 'v0 fix --restart'
      ACTION="restart"
      shift
      ;;
    *)
      POSITIONAL+=("$1")
      shift
      ;;
  esac
done

# Main dispatch
case "${ACTION}" in
  start)
    start_worker
    ;;
  stop)
    stop_worker
    ;;
  restart)
    stop_worker
    start_worker
    ;;
  status)
    show_status
    if [[ ${#POSITIONAL[@]} -eq 0 ]]; then
      echo ""
      echo "Run with --help for more options"
    fi
    ;;
  logs)
    show_logs
    ;;
  err)
    show_errors
    ;;
  history)
    show_history "${HISTORY_LIMIT}"
    ;;
  "")
    if [[ ${#POSITIONAL[@]} -gt 0 ]]; then
      report_bug "${POSITIONAL[*]}"
    else
      show_status
      echo ""
      echo "Run with --help for more options"
    fi
    ;;
esac
