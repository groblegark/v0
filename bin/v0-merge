#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
# v0 merge - Merge a worktree branch to main
#
# This script provides the CLI interface for merge operations.
# Helper functions are implemented in lib/merge/ modules.
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

# Find main repo - git merge operations must run from main repo, not worktrees
MAIN_REPO=$(v0_find_main_repo "${V0_ROOT}")

# Source the merge modules
source "${V0_DIR}/packages/merge/lib/merge.sh"

usage() {
    v0_help <<'EOF'
Usage: v0 merge <operation> [--resolve]
       v0 merge <tree-dir> [--resolve]

Merge a worktree branch to main, then delete worktree and branch.
Exits with error if merge would have conflicts.

Options:
  --resolve    If conflicts exist, open claude to resolve them

Examples:
  v0 merge my-feature
  v0 merge my-feature --resolve
  v0 merge ~/.local/state/v0/\$PROJECT/tree/my-feature
EOF
    exit 1
}

[[ -z "$1" ]] && usage

# Parse arguments - allow --resolve before or after operation name
RESOLVE=false
INPUT=""
for arg in "$@"; do
    if [[ "$arg" = "--resolve" ]]; then
        RESOLVE=true
    else
        INPUT="$arg"
    fi
done

[[ -z "$INPUT" ]] && usage

# Resolve input to worktree and tree_dir
if mg_is_input_path "${INPUT}"; then
    mg_resolve_path_to_worktree "${INPUT}"
else
    MG_OP_NAME="${INPUT}"
    mg_resolve_operation_to_worktree "${INPUT}"
fi

HAS_WORKTREE="${MG_HAS_WORKTREE:-true}"
OP_NAME="${MG_OP_NAME:-}"

if [[ "${HAS_WORKTREE}" = true ]]; then
    WORKTREE="${MG_WORKTREE}"
    TREE_DIR="${MG_TREE_DIR}"

    # Validate worktree
    mg_validate_worktree "${WORKTREE}"

    # Get actual branch name from the worktree
    BRANCH="$(mg_get_branch "${WORKTREE}")"
else
    # No worktree - use branch directly
    BRANCH="${MG_BRANCH}"
    WORKTREE=""
    TREE_DIR=""

    echo "Note: No worktree found. Attempting direct branch merge."
fi

# All git operations must run from main repo (not a worktree)
cd "${MAIN_REPO}"

# Worktree-specific checks (skip if no worktree)
if [[ "${HAS_WORKTREE}" = true ]]; then
    # Check for and clean up mid-rebase state
    mg_abort_incomplete_rebase "${WORKTREE}"

    # Check worktree is clean (ignore untracked files)
    if mg_worktree_has_uncommitted "${WORKTREE}"; then
        if [[ "${RESOLVE}" = true ]]; then
            echo "Uncommitted changes detected. Starting claude to resolve..."
            mg_resolve_uncommitted_changes "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
            # Re-check after resolution
            if mg_worktree_has_uncommitted "${WORKTREE}"; then
                echo "Error: Uncommitted changes still exist after resolution"
                exit 1
            fi
        else
            echo "Error: Worktree has uncommitted changes"
            echo "  cd ${WORKTREE} && git status"
            echo ""
            echo "To resolve with agent assistance:"
            echo "  v0 merge ${TREE_DIR} --resolve"
            exit 1
        fi
    fi
fi

# Acquire lock before any merge operations
mg_acquire_lock "${BRANCH}"

if mg_has_conflicts "${BRANCH}"; then
    if [[ "${RESOLVE}" = true ]]; then
        echo "Conflicts detected. Starting claude to resolve..."

        # If no worktree, create a temporary one for resolution
        if [[ "${HAS_WORKTREE}" = false ]]; then
            echo "Creating temporary worktree for conflict resolution..."
            mg_create_temp_worktree_for_resolution "${BRANCH}"
            WORKTREE="${MG_TEMP_WORKTREE}"
            TREE_DIR="${MG_TEMP_TREE_DIR}"
            USING_TEMP_WORKTREE=true
        else
            USING_TEMP_WORKTREE=false
        fi

        mg_launch_resolve_session "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
        mg_wait_for_resolve_session "${MG_RESOLVE_SESSION}"
        mg_cleanup_resolve_session "${TREE_DIR}"

        cd "${MAIN_REPO}"

        # Check success by outcome
        if mg_worktree_has_conflicts "${WORKTREE}"; then
            echo "Error: Conflicts still exist after resolution attempt"
            if [[ -f "${MG_RESOLVE_LOG:-}" ]]; then
                echo "Check log file: ${MG_RESOLVE_LOG}"
            fi
            if [[ "${USING_TEMP_WORKTREE}" = true ]]; then
                mg_cleanup_temp_worktree
            fi
            exit 1
        fi

        # Check if rebase is still in progress
        worktree_git_dir=$(mg_get_worktree_git_dir "${WORKTREE}")
        if [[ -d "${worktree_git_dir}/rebase-merge" ]] || [[ -d "${worktree_git_dir}/rebase-apply" ]]; then
            echo "Error: Rebase not completed. Claude should have run 'git rebase --continue'"
            if [[ -f "${MG_RESOLVE_LOG:-}" ]]; then
                echo "Check log file: ${MG_RESOLVE_LOG}"
            fi
            if [[ "${USING_TEMP_WORKTREE}" = true ]]; then
                mg_cleanup_temp_worktree
            fi
            exit 1
        fi

        # After successful resolution, merge using mg_do_merge
        if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
            merge_commit=$(mg_get_merge_commit)
            rm -f "${MG_RESOLVE_LOG:-}"

            if [[ "${USING_TEMP_WORKTREE}" = true ]]; then
                mg_cleanup_temp_worktree
                mg_cleanup_branch_only "${BRANCH}"
            else
                mg_cleanup_worktree "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
            fi

            if mg_push_and_verify "${merge_commit}"; then
                op_to_update=$(mg_resolve_op_name "${OP_NAME}" "${BRANCH}")
                if [[ -n "${op_to_update}" ]]; then
                    mg_record_merge_commit "${op_to_update}" "${merge_commit}"
                fi

                mg_update_operation_state "${BRANCH}"
                if [[ -z "${V0_MERGEQ_CALLER:-}" ]]; then
                    mg_update_queue_entry "${OP_NAME}" "${BRANCH}"
                fi

                mg_trigger_dependents "${BRANCH}"
                mg_notify_merge "${PROJECT}" "${BRANCH}" "(after resolution)"
                mg_delete_remote_branch "${BRANCH}"
            fi
        fi
    else
        echo
        echo -e "${C_RED}${C_BOLD}Error:${C_RESET} Merge would have conflicts. To resolve:"
        if [[ "${HAS_WORKTREE}" = true ]]; then
            echo -e "  ${C_BOLD}v0 merge ${TREE_DIR} --resolve${C_RESET}"
        else
            echo -e "  ${C_BOLD}v0 merge ${INPUT} --resolve${C_RESET}"
        fi
        exit 1
    fi
else
    # No conflicts - direct merge
    if [[ "${HAS_WORKTREE}" = true ]]; then
        # With worktree - use standard merge flow
        if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
            merge_commit=$(mg_get_merge_commit)
            mg_cleanup_worktree "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"

            if mg_push_and_verify "${merge_commit}"; then
                op_to_update=$(mg_resolve_op_name "${OP_NAME}" "${BRANCH}")
                if [[ -n "${op_to_update}" ]]; then
                    mg_record_merge_commit "${op_to_update}" "${merge_commit}"
                fi

                mg_update_operation_state "${BRANCH}"
                if [[ -z "${V0_MERGEQ_CALLER:-}" ]]; then
                    mg_update_queue_entry "${OP_NAME}" "${BRANCH}"
                fi

                mg_trigger_dependents "${BRANCH}"
                mg_notify_merge "${PROJECT}" "${BRANCH}"
                mg_delete_remote_branch "${BRANCH}"
            fi
        fi
    else
        # Without worktree - use fast-forward merge
        if mg_do_merge_without_worktree "${BRANCH}"; then
            merge_commit=$(mg_get_merge_commit)
            mg_cleanup_branch_only "${BRANCH}"

            if mg_push_and_verify "${merge_commit}"; then
                op_to_update=$(mg_resolve_op_name "${OP_NAME}" "${BRANCH}")
                if [[ -n "${op_to_update}" ]]; then
                    mg_record_merge_commit "${op_to_update}" "${merge_commit}"
                fi

                mg_update_operation_state "${BRANCH}"
                if [[ -z "${V0_MERGEQ_CALLER:-}" ]]; then
                    mg_update_queue_entry "${OP_NAME}" "${BRANCH}"
                fi

                mg_trigger_dependents "${BRANCH}"
                mg_notify_merge "${PROJECT}" "${BRANCH}"
                mg_delete_remote_branch "${BRANCH}"
            fi
        else
            # Fast-forward failed - need worktree for rebase
            if [[ "${RESOLVE}" = true ]]; then
                echo "Creating temporary worktree for rebase..."
                mg_create_temp_worktree_for_resolution "${BRANCH}"
                WORKTREE="${MG_TEMP_WORKTREE}"
                TREE_DIR="${MG_TEMP_TREE_DIR}"

                # Do the merge with the temp worktree
                if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
                    merge_commit=$(mg_get_merge_commit)
                    mg_cleanup_temp_worktree
                    mg_cleanup_branch_only "${BRANCH}"

                    if mg_push_and_verify "${merge_commit}"; then
                        op_to_update=$(mg_resolve_op_name "${OP_NAME}" "${BRANCH}")
                        if [[ -n "${op_to_update}" ]]; then
                            mg_record_merge_commit "${op_to_update}" "${merge_commit}"
                        fi

                        mg_update_operation_state "${BRANCH}"
                        if [[ -z "${V0_MERGEQ_CALLER:-}" ]]; then
                            mg_update_queue_entry "${OP_NAME}" "${BRANCH}"
                        fi

                        mg_trigger_dependents "${BRANCH}"
                        mg_notify_merge "${PROJECT}" "${BRANCH}" "(after rebase)"
                        mg_delete_remote_branch "${BRANCH}"
                    fi
                else
                    mg_cleanup_temp_worktree
                    exit 1
                fi
            else
                echo
                echo -e "${C_RED}${C_BOLD}Error:${C_RESET} Cannot fast-forward merge. To resolve:"
                echo -e "  ${C_BOLD}v0 merge ${INPUT} --resolve${C_RESET}"
                exit 1
            fi
        fi
    fi
fi
