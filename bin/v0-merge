#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
# v0 merge - Merge a worktree branch to main
#
# This script provides the CLI interface for merge operations.
# Helper functions are implemented in lib/merge/ modules.
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"

# Save inherited BUILD_DIR before v0_load_config potentially overwrites it.
# When running from the workspace (e.g., called by mergeq daemon), v0_load_config
# sets BUILD_DIR based on the workspace's .v0.rc, but we need to preserve the
# main repo's BUILD_DIR so we can access operation state files.
_INHERITED_BUILD_DIR="${BUILD_DIR:-}"

v0_load_config

# Restore inherited BUILD_DIR if it was set by parent process (e.g., mergeq daemon).
# Always export so child processes (v0-build launched by mg_trigger_dependents)
# inherit the correct path, even when BUILD_DIR was computed by v0_load_config.
[[ -n "${_INHERITED_BUILD_DIR}" ]] && BUILD_DIR="${_INHERITED_BUILD_DIR}"
export BUILD_DIR

# Ensure workspace exists for merge operations
# All merges happen in the workspace, not V0_ROOT
if ! ws_ensure_workspace; then
    echo "Error: Failed to create workspace for merge operations" >&2
    exit 1
fi

# All git operations run in the workspace from this point forward
cd "${V0_WORKSPACE_DIR}"

# Source the merge modules
source "${V0_DIR}/packages/merge/lib/merge.sh"

usage() {
    v0_help <<'EOF'
Usage: v0 merge <operation> [--resolve]
       v0 merge <tree-dir> [--resolve]

Merge a worktree branch to main, then delete worktree and branch.
Exits with error if merge would have conflicts.

Options:
  --resolve    If conflicts exist, open claude to resolve them

Examples:
  v0 merge my-feature
  v0 merge my-feature --resolve
  v0 merge ~/.local/state/v0/\$PROJECT/tree/my-feature
EOF
    exit 1
}

[[ -z "$1" ]] && usage

# Parse arguments - allow --resolve before or after operation name
RESOLVE=false
INPUT=""
for arg in "$@"; do
    if [[ "$arg" = "--resolve" ]]; then
        RESOLVE=true
    else
        INPUT="$arg"
    fi
done

[[ -z "$INPUT" ]] && usage

v0_trace "merge:cmd" "v0 merge invoked with input: ${INPUT} (resolve: ${RESOLVE})"

# Resolve input to worktree and tree_dir
if mg_is_input_path "${INPUT}"; then
    mg_resolve_path_to_worktree "${INPUT}"
else
    MG_OP_NAME="${INPUT}"
    mg_resolve_operation_to_worktree "${INPUT}"
fi

HAS_WORKTREE="${MG_HAS_WORKTREE:-true}"
OP_NAME="${MG_OP_NAME:-}"

if [[ "${HAS_WORKTREE}" = true ]]; then
    WORKTREE="${MG_WORKTREE}"
    TREE_DIR="${MG_TREE_DIR}"

    # Validate worktree
    mg_validate_worktree "${WORKTREE}"

    # Get actual branch name from the worktree
    BRANCH="$(mg_get_branch "${WORKTREE}")"
else
    # No worktree - use branch directly
    BRANCH="${MG_BRANCH}"
    WORKTREE=""
    TREE_DIR=""

    echo "Note: No worktree found. Attempting direct branch merge."
fi

# Worktree-specific checks (skip if no worktree)
if [[ "${HAS_WORKTREE}" = true ]]; then
    # Check for and clean up mid-rebase state
    mg_abort_incomplete_rebase "${WORKTREE}"

    # Check worktree is clean (ignore untracked files)
    if mg_worktree_has_uncommitted "${WORKTREE}"; then
        if [[ "${RESOLVE}" = true ]]; then
            echo "Uncommitted changes detected. Starting claude to resolve..."
            mg_resolve_uncommitted_changes "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
            # Re-check after resolution
            if mg_worktree_has_uncommitted "${WORKTREE}"; then
                echo "Error: Uncommitted changes still exist after resolution"
                exit 1
            fi
        else
            echo "Error: Worktree has uncommitted changes"
            echo "  cd ${WORKTREE} && git status"
            echo ""
            echo "To resolve with agent assistance:"
            echo "  v0 merge ${TREE_DIR} --resolve"
            exit 1
        fi
    fi
fi

# Acquire lock before any merge operations
mg_acquire_lock "${BRANCH}"

# Ensure we're on the develop branch before merging
if ! mg_ensure_develop_branch; then
    exit 1
fi

# Try the merge first - mg_do_merge handles rebase+FF which often succeeds
# even when git merge-tree would report conflicts. Only fall back to Claude
# resolution if the actual merge fails.
#
# This fixes false positive conflict detection: mg_has_conflicts uses git merge-tree
# which reports conflicts for any non-FF merge, but rebase+FF can succeed in those cases.

_mg_attempt_merge() {
    if [[ "${HAS_WORKTREE}" = true ]]; then
        # With worktree - use standard merge flow (rebase+FF)
        if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
            merge_commit=$(mg_get_merge_commit)
            # Push first, only cleanup on success (so worktree remains for retry on push failure)
            if mg_finalize_merge "${merge_commit}" "${OP_NAME}" "${BRANCH}" "${PROJECT}"; then
                mg_cleanup_merge "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
                return 0
            else
                return 1
            fi
        fi
        return 2  # Merge failed, may need resolution
    else
        # Without worktree - try fast-forward first
        if mg_do_merge_without_worktree "${BRANCH}"; then
            merge_commit=$(mg_get_merge_commit)
            if mg_finalize_merge "${merge_commit}" "${OP_NAME}" "${BRANCH}" "${PROJECT}"; then
                mg_cleanup_merge "" "" "${BRANCH}"
                return 0
            else
                return 1
            fi
        fi

        # Fast-forward failed - need worktree for rebase
        if [[ "${RESOLVE}" = true ]]; then
            echo "Creating temporary worktree for rebase..."
            mg_create_temp_worktree_for_resolution "${BRANCH}"
            WORKTREE="${MG_TEMP_WORKTREE}"
            TREE_DIR="${MG_TEMP_TREE_DIR}"
            HAS_WORKTREE=true

            if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
                merge_commit=$(mg_get_merge_commit)
                if mg_finalize_merge "${merge_commit}" "${OP_NAME}" "${BRANCH}" "${PROJECT}" "(after rebase)"; then
                    mg_cleanup_merge "${WORKTREE}" "${TREE_DIR}" "${BRANCH}" true
                    return 0
                else
                    return 1
                fi
            fi
            return 2  # Merge failed after creating worktree, may need resolution
        fi
        return 2  # No worktree and not allowed to create one
    fi
}

# Attempt the merge
v0_trace "merge:cmd:attempt" "Attempting merge of ${BRANCH}"
set +e
_mg_attempt_merge
merge_result=$?
set -e

case ${merge_result} in
    0)
        # Success - already handled in _mg_attempt_merge
        exit 0
        ;;
    1)
        # Push/finalize failed - already printed error
        exit 1
        ;;
    2)
        # Merge failed - may need resolution
        if [[ "${RESOLVE}" = true ]]; then
            v0_trace "merge:cmd:resolve" "Merge failed, launching conflict resolution for ${BRANCH}"
            echo "Merge failed. Starting claude to resolve..."

            # If no worktree, create a temporary one for resolution
            if [[ "${HAS_WORKTREE}" = false ]]; then
                echo "Creating temporary worktree for conflict resolution..."
                mg_create_temp_worktree_for_resolution "${BRANCH}"
                WORKTREE="${MG_TEMP_WORKTREE}"
                TREE_DIR="${MG_TEMP_TREE_DIR}"
                USING_TEMP_WORKTREE=true
            else
                USING_TEMP_WORKTREE=false
            fi

            mg_launch_resolve_session "${WORKTREE}" "${TREE_DIR}" "${BRANCH}"
            mg_wait_for_resolve_session "${MG_RESOLVE_SESSION}"
            mg_cleanup_resolve_session "${TREE_DIR}"

            cd "${V0_WORKSPACE_DIR}"

            # Check success by outcome
            if mg_worktree_has_conflicts "${WORKTREE}"; then
                mg_fail_resolution "Conflicts still exist after resolution attempt"
            fi

            # Check if rebase is still in progress
            worktree_git_dir=$(mg_get_worktree_git_dir "${WORKTREE}")
            if [[ -d "${worktree_git_dir}/rebase-merge" ]] || [[ -d "${worktree_git_dir}/rebase-apply" ]]; then
                mg_fail_resolution "Rebase not completed. Claude should have run 'git rebase --continue'"
            fi

            # After successful resolution, merge using mg_do_merge
            if mg_do_merge "${WORKTREE}" "${BRANCH}"; then
                merge_commit=$(mg_get_merge_commit)
                rm -f "${MG_RESOLVE_LOG:-}"
                # Push first, only cleanup on success (so worktree remains for retry on push failure)
                if mg_finalize_merge "${merge_commit}" "${OP_NAME}" "${BRANCH}" "${PROJECT}" "(after resolution)"; then
                    mg_cleanup_merge "${WORKTREE}" "${TREE_DIR}" "${BRANCH}" "${USING_TEMP_WORKTREE}"
                else
                    exit 1
                fi
            else
                mg_fail_resolution "Merge still failed after resolution attempt"
            fi
        else
            echo
            echo -e "${C_RED}${C_BOLD}Error:${C_RESET} Merge failed. To resolve:"
            if [[ "${HAS_WORKTREE}" = true ]]; then
                echo -e "  ${C_BOLD}v0 merge ${TREE_DIR} --resolve${C_RESET}"
            else
                echo -e "  ${C_BOLD}v0 merge ${INPUT} --resolve${C_RESET}"
            fi
            exit 1
        fi
        ;;
esac
