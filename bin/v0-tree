#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

# Determine the git repo to create worktrees from:
# - In worktree mode: use V0_ROOT (worktrees are siblings)
# - In clone mode: use workspace clone (worktrees branch from workspace)
if [[ "${V0_WORKSPACE_MODE}" == "clone" ]]; then
  # Ensure workspace exists before creating feature worktrees
  if ! ws_ensure_workspace; then
    echo "Error: Failed to create workspace (required for clone mode)" >&2
    exit 1
  fi
  WORKTREE_PARENT="${V0_WORKSPACE_DIR}"
else
  WORKTREE_PARENT="${V0_ROOT}"
fi

# Storage locations (in order of preference):
# 1. XDG state directory: ~/.local/state/v0/{project}/tree/<name>/{repo}/
# 2. Git directory fallback: .git/v0-worktrees/<name>/{repo}/
XDG_ROOT="${V0_STATE_DIR}/tree"
GIT_ROOT="$(git -C "${WORKTREE_PARENT}" rev-parse --git-common-dir 2>/dev/null || echo "${WORKTREE_PARENT}/.git")/v0-worktrees"

# Normalize git root path (may be relative)
if [[ "${GIT_ROOT}" != /* ]]; then
  GIT_ROOT="${WORKTREE_PARENT}/${GIT_ROOT}"
fi

usage() {
  v0_help <<'EOF'
Usage: v0 tree <name> [--branch <branch-name>]

Create a worktree and sync settings. Skips creation if worktree already exists.
Outputs two lines: TREE_DIR path, then WORKTREE path.

Options:
  --branch, -b <name>  Git branch name to use (defaults to <name>)

Storage locations (in order of preference):
  1. XDG state directory: ~/.local/state/v0/${PROJECT}/tree/<name>/${REPO_NAME}/
  2. Git directory fallback: .git/v0-worktrees/<name>/${REPO_NAME}/

The XDG location is preferred because it keeps .git/ clean and survives
git clean operations. Falls back to .git/ when XDG directory cannot be
created (permissions, disk space, restricted environment).

Environment:
  V0_WORKTREE_INIT    Optional shell command to run after worktree creation.
                      Runs in the worktree directory with V0_CHECKOUT_DIR and
                      V0_WORKTREE_DIR environment variables set.

Example:
  read -r TREE_DIR; read -r WORKTREE < <(v0 tree my-feature)
  read -r TREE_DIR; read -r WORKTREE < <(v0 tree v0-fix-worker --branch v0/worker/fix)
EOF
  exit 1
}

# Parse arguments
name=""
branch=""
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      ;;
    -b|--branch)
      branch="$2"
      shift 2
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      usage
      ;;
    *)
      if [[ -z "${name}" ]]; then
        name="$1"
      else
        echo "Error: Unexpected argument: $1" >&2
        usage
      fi
      shift
      ;;
  esac
done

[[ -z "${name}" ]] && usage

# Default branch name to the tree name if not specified
[[ -z "${branch}" ]] && branch="${name}"

# Check for old-style worktree and warn
OLD_TREE="${WORKTREE_PARENT}/.tree/${name}"
if [[ -d "${OLD_TREE}" ]]; then
  echo "Warning: Old worktree exists at ${OLD_TREE}" >&2
  echo "Remove with: git worktree remove ${OLD_TREE}/${REPO_NAME}" >&2
fi

# Find existing worktree in either location
# This prevents creating duplicates during migration
find_existing_worktree() {
  local xdg_worktree="${XDG_ROOT}/${name}/${REPO_NAME}"
  local git_worktree="${GIT_ROOT}/${name}/${REPO_NAME}"

  # Check XDG location first
  if [[ -d "${xdg_worktree}" ]] && { [[ -d "${xdg_worktree}/.git" ]] || [[ -f "${xdg_worktree}/.git" ]]; }; then
    echo "${XDG_ROOT}/${name}"
    return 0
  fi

  # Check git fallback location
  if [[ -d "${git_worktree}" ]] && { [[ -d "${git_worktree}/.git" ]] || [[ -f "${git_worktree}/.git" ]]; }; then
    echo "${GIT_ROOT}/${name}"
    return 0
  fi

  return 1
}

# Try to create directory, return success if created or already exists
try_create_tree_dir() {
  local base="$1"
  local tree="${base}/${name}"

  if mkdir -p "${base}" 2>/dev/null && mkdir -p "${tree}" 2>/dev/null; then
    echo "${tree}"
    return 0
  fi
  return 1
}

# Check for existing worktree first
if existing=$(find_existing_worktree); then
  tree_dir="${existing}"
  worktree="${tree_dir}/${REPO_NAME}"
else
  # Try XDG location first, fall back to .git/ if it fails
  if tree_dir=$(try_create_tree_dir "${XDG_ROOT}"); then
    : # Success
  elif tree_dir=$(try_create_tree_dir "${GIT_ROOT}"); then
    echo "Note: Using .git/v0-worktrees/ (XDG location unavailable)" >&2
  else
    echo "Error: Failed to create tree directory in both locations" >&2
    echo "  Tried: ${XDG_ROOT}/${name}" >&2
    echo "  Tried: ${GIT_ROOT}/${name}" >&2
    exit 1
  fi
  worktree="${tree_dir}/${REPO_NAME}"
fi

# If directory exists but is not a valid worktree, remove and recreate
if [[ -d "${worktree}" ]] && [[ ! -d "${worktree}/.git" ]] && [[ ! -f "${worktree}/.git" ]]; then
  echo "Note: Removing invalid worktree directory: ${worktree}" >&2
  rm -rf "${worktree}"
fi

if [[ ! -d "${worktree}" ]]; then
  # Try creating with new branch first, fall back to existing branch
  # Suppress git output to keep v0 output clean (errors still reported via exit code)
  # Use WORKTREE_PARENT as the git repo (V0_ROOT in worktree mode, workspace in clone mode)
  if ! git -C "${WORKTREE_PARENT}" worktree add "${worktree}" -b "${branch}" main >/dev/null 2>&1; then
    if ! git -C "${WORKTREE_PARENT}" worktree add "${worktree}" "${branch}" >/dev/null 2>&1; then
      echo "Error: Failed to create worktree at ${worktree}" >&2
      exit 1
    fi
  fi
fi

# Sync settings to tree_dir (Claude looks up the directory tree)
if [[ -f "${V0_ROOT}/.claude/settings.json" ]]; then
  mkdir -p "${tree_dir}/.claude"
  cp -f "${V0_ROOT}/.claude/settings.json" "${tree_dir}/.claude/settings.local.json"
fi

# Run worktree init hook if configured
if [[ -n "${V0_WORKTREE_INIT:-}" ]]; then
  init_exit_code=0
  (
    export V0_CHECKOUT_DIR="${V0_ROOT}"
    export V0_WORKTREE_DIR="${worktree}"
    cd "${worktree}" || exit 1
    eval "${V0_WORKTREE_INIT}" >&2
  ) || init_exit_code=$?
  if [[ "${init_exit_code}" -ne 0 ]]; then
    # Color for stderr (different from v0-common.sh which checks stdout)
    if [[ -t 2 ]]; then
      echo -e "\033[31m>>> Worktree init hook failed (exit code: ${init_exit_code})\033[0m" >&2
    else
      echo ">>> Worktree init hook failed (exit code: ${init_exit_code})" >&2
    fi
  fi
fi

# Output paths (one per line: TREE_DIR, WORKTREE)
echo "${tree_dir}"
echo "${worktree}"
