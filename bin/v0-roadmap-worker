#!/bin/bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
# v0-roadmap-worker - Background worker for v0 roadmap orchestration
#
# This script runs the roadmap orchestration pipeline:
# - Sets up working environment (worktree, CLAUDE.md, hooks)
# - Launches Claude agent to break down the roadmap into epics/milestones
# - Agent queues all features with v0 feature --after
#
# Key responsibilities:
# - Create worktree for roadmap orchestration
# - Generate CLAUDE.md from roadmap template
# - Configure hooks for completion detection
# - Launch Claude agent in tmux
# - Handle errors and interruptions gracefully

set -e

V0_DIR="$(cd "$(dirname "$0")/.." && pwd)"
source "${V0_DIR}/packages/cli/lib/v0-common.sh"
v0_load_config

usage() {
  cat <<EOF
Usage: v0-roadmap-worker <name>

Background worker for v0 roadmap orchestration.
This script is launched by v0-roadmap and should not be called directly.

Arguments:
  name    Name of the roadmap to orchestrate
EOF
  exit 1
}

NAME="$1"
[[ -z "${NAME}" ]] && usage

# Roadmap state is stored in roadmaps/ directory (separate from operations)
ROADMAPS_DIR="${BUILD_DIR}/roadmaps"
STATE_DIR="${ROADMAPS_DIR}/${NAME}"
STATE_FILE="${STATE_DIR}/state.json"
LOG_FILE="${STATE_DIR}/logs/worker.log"

if [[ ! -f "${STATE_FILE}" ]]; then
  echo "Error: No roadmap found for '${NAME}'"
  exit 1
fi

mkdir -p "${STATE_DIR}/logs"

exec > >(tee -a "${LOG_FILE}") 2>&1

log() { echo "[$(date '+%H:%M:%S')] $*"; }

get_state() {
  jq -r ".$1 // empty" "${STATE_FILE}"
}

update_state() {
  local key="$1"
  local value="$2"
  local tmp
  tmp=$(mktemp)
  jq ".${key} = ${value}" "${STATE_FILE}" > "${tmp}" && mv "${tmp}" "${STATE_FILE}"
}

emit_event() {
  local event="$1"
  local details="$2"
  log "${event}: ${details}"
  echo "[$(date -u +%Y-%m-%dT%H:%M:%SZ)] ${event}: ${details}" >> "${STATE_DIR}/logs/events.log"
}

ERROR_MSG=""
INTERRUPTED=""

handle_signal() {
  log "Received termination signal"
  INTERRUPTED=1
  ERROR_MSG=""
}
trap handle_signal SIGTERM SIGINT

cleanup() {
  update_state "worker_pid" "null"
  if [[ -n "${INTERRUPTED}" ]]; then
    update_state "phase" '"interrupted"'
    emit_event "worker:interrupted" "Worker was terminated by signal"
    log "Worker interrupted"
  elif [[ -n "${ERROR_MSG}" ]]; then
    update_state "phase" '"failed"'
    emit_event "worker:failed" "${ERROR_MSG}"
    log "Worker failed: ${ERROR_MSG}"
  fi
  log "Background worker cleanup complete"
}
trap cleanup EXIT

create_done_script() {
  local target_dir="$1"
  local roadmap_name="$2"
  local idea_id="$3"

  cat > "${target_dir}/done" <<DONE_SCRIPT
#!/bin/bash
# Mark roadmap as completed and add completion note to idea

ROADMAP_NAME="${roadmap_name}"
IDEA_ID="${idea_id}"

# Add completion note to idea issue if we have one
if [[ -n "\${IDEA_ID}" ]] && [[ "\${IDEA_ID}" != "null" ]]; then
  QUEUED_COUNT=\$(wk list --label "roadmap:\${ROADMAP_NAME}" 2>/dev/null | wc -l | tr -d ' ')
  wk note "\${IDEA_ID}" "Orchestration complete. \${QUEUED_COUNT} features queued." 2>/dev/null || true
fi

find_claude() {
  local pid=\$1
  while [[ -n "\${pid}" ]] && [[ "\${pid}" != "1" ]]; do
    local cmd=\$(ps -o comm= -p \${pid} 2>/dev/null)
    if [[ "\${cmd}" == *"claude"* ]]; then
      echo "\${pid}"
      return
    fi
    pid=\$(ps -o ppid= -p \${pid} 2>/dev/null | tr -d ' ')
  done
}
CLAUDE_PID=\$(find_claude \$\$)
if [[ -n "\${CLAUDE_PID}" ]]; then
  kill -TERM "\${CLAUDE_PID}" 2>/dev/null || true
fi
exit 0
DONE_SCRIPT
  chmod +x "${target_dir}/done"
}

create_incomplete_script() {
  local target_dir="$1"
  local roadmap_name="$2"

  cat > "${target_dir}/incomplete" <<INCOMPLETE_SCRIPT
#!/bin/bash
# Exit session marking roadmap as incomplete

echo "Roadmap orchestration incomplete."
echo "Resume with: v0 roadmap ${roadmap_name} --resume"

find_claude() {
  local pid=\$1
  while [[ -n "\${pid}" ]] && [[ "\${pid}" != "1" ]]; do
    local cmd=\$(ps -o comm= -p \${pid} 2>/dev/null)
    if [[ "\${cmd}" == *"claude"* ]]; then
      echo "\${pid}"
      return
    fi
    pid=\$(ps -o ppid= -p \${pid} 2>/dev/null | tr -d ' ')
  done
}
CLAUDE_PID=\$(find_claude \$\$)
if [[ -n "\${CLAUDE_PID}" ]]; then
  kill -TERM "\${CLAUDE_PID}" 2>/dev/null || true
fi
exit 1
INCOMPLETE_SCRIPT
  chmod +x "${target_dir}/incomplete"
}

run_orchestration_phase() {
  log "Starting orchestration phase"

  local DESCRIPTION
  DESCRIPTION=$(get_state roadmap_description)
  local IDEA_ID
  IDEA_ID=$(get_state idea_id)

  emit_event "orchestrate:starting" "Setting up roadmap orchestration environment"

  # Create worktree for roadmap orchestration
  # Use a roadmap-specific branch pattern
  ROADMAP_BRANCH="roadmap/${NAME}"
  if ! tree_output=$("${V0_DIR}/bin/v0-tree" "${ROADMAP_BRANCH}"); then
    ERROR_MSG="Failed to create worktree for ${ROADMAP_BRANCH}"
    return 1
  fi
  { read -r TREE_DIR; read -r WORKTREE; } <<< "${tree_output}"

  update_state "worktree" "\"${WORKTREE}\""

  SESSION=$(v0_session_name "${NAME}" "roadmap")

  if tmux has-session -t "${SESSION}" 2>/dev/null; then
    log "Roadmap session '${SESSION}' already running, waiting for completion..."
    # Just wait for it to complete
    while tmux has-session -t "${SESSION}" 2>/dev/null; do
      sleep 5
    done
    return 0
  fi

  emit_event "orchestrate:setup" "Creating CLAUDE.md and hooks"

  # Create CLAUDE.md from roadmap template
  M4_ARGS="-D ROADMAP_NAME=${NAME} -D ROADMAP_DESCRIPTION=$(printf '%s' "${DESCRIPTION}" | sed 's/"/\\"/g') -D IDEA_ID=${IDEA_ID:-none} -D V0_GIT_REMOTE=${V0_GIT_REMOTE}"
  m4 ${M4_ARGS} "${V0_DIR}/packages/cli/lib/templates/claude.roadmap.m4" > "${TREE_DIR}/CLAUDE.md"
  emit_event "claude.md:created" "${TREE_DIR}/CLAUDE.md"

  # Copy roadmap prompt as ROADMAP.md
  if [[ -f "${V0_DIR}/packages/cli/lib/prompts/roadmap.md" ]]; then
    /bin/cp "${V0_DIR}/packages/cli/lib/prompts/roadmap.md" "${TREE_DIR}/ROADMAP.md"
    emit_event "roadmap.md:copied" "Copied roadmap orchestration instructions"
  fi

  # Configure hooks
  HOOK_SCRIPT="${V0_DIR}/packages/hooks/lib/stop-roadmap.sh"
  mkdir -p "${TREE_DIR}/.claude"
  cat > "${TREE_DIR}/.claude/settings.local.json" <<SETTINGS_EOF
{
  "hooks": {
    "Stop": [
      {
        "hooks": [
          {
            "type": "command",
            "command": "${HOOK_SCRIPT}"
          }
        ]
      }
    ],
    "PreCompact": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "v0 prime"
          }
        ]
      }
    ],
    "SessionStart": [
      {
        "matcher": "",
        "hooks": [
          {
            "type": "command",
            "command": "v0 prime"
          }
        ]
      }
    ]
  }
}
SETTINGS_EOF

  # Create done and incomplete scripts
  create_done_script "${TREE_DIR}" "${NAME}" "${IDEA_ID}"
  create_incomplete_script "${TREE_DIR}" "${NAME}"

  # Create on-complete script
  cat > "${TREE_DIR}/.claude/on-complete.sh" <<WRAPPER
#!/bin/bash
STATE_FILE="${STATE_FILE}"
ROADMAP_NAME="${NAME}"

# Count queued features
QUEUED_COUNT=\$(wk list --label "roadmap:\${ROADMAP_NAME}" 2>/dev/null | wc -l | tr -d ' ')

# Get list of queued feature names
QUEUED_FEATURES=\$(wk list --label "roadmap:\${ROADMAP_NAME}" 2>/dev/null | grep -oE '[a-zA-Z]+-[a-z0-9]+' | tr '\n' ' ')

# Update state with queued features
tmp=\$(mktemp)
jq ".features_queued = [\$(echo \${QUEUED_FEATURES} | tr ' ' '\n' | grep -v '^$' | sed 's/.*/"&"/' | paste -sd, -)] | .phase = \"completed\" | .completed_at = \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"" "\${STATE_FILE}" > "\${tmp}" && mv "\${tmp}" "\${STATE_FILE}"

echo ""
echo "=== Roadmap Orchestration Complete ==="
echo "Features queued: \${QUEUED_COUNT}"
echo ""
echo "View queued work: wk list --label roadmap:${NAME}"
echo "Start first feature: v0 feature <first-feature-name> --resume"
WRAPPER
  chmod +x "${TREE_DIR}/.claude/on-complete.sh"

  # Update state to planning phase
  update_state "phase" '"planning"'
  update_state "planning_session" "\"${SESSION}\""

  emit_event "orchestrate:launching" "Launching Claude agent in tmux session ${SESSION}"

  # Launch Claude agent
  CLAUDE_ARGS="--model opus --dangerously-skip-permissions --allow-dangerously-skip-permissions"

  tmux new-session -d -s "${SESSION}" -c "${TREE_DIR}" \
    "V0_ROADMAP_NAME='${NAME}' V0_IDEA_ID='${IDEA_ID}' V0_ROOT='${V0_ROOT}' claude ${CLAUDE_ARGS} 'Orchestrate the roadmap. Follow instructions in CLAUDE.md and ROADMAP.md.'; \
     '${TREE_DIR}/.claude/on-complete.sh'; \
     echo ''; echo 'Session complete. Closing in 5 seconds...'; sleep 5"

  log "Orchestration phase started: tmux session ${SESSION}"
  log "Watch live: v0 attach roadmap ${NAME}"

  # Wait for session to complete
  while tmux has-session -t "${SESSION}" 2>/dev/null; do
    sleep 5
  done

  # Check if we successfully queued features
  QUEUED_COUNT=$(wk list --label "roadmap:${NAME}" 2>/dev/null | wc -l | tr -d ' ')
  if [[ "${QUEUED_COUNT}" -gt 0 ]]; then
    emit_event "orchestrate:complete" "${QUEUED_COUNT} features queued for roadmap"
    update_state "phase" '"orchestrating"'
    log "Roadmap orchestration complete. ${QUEUED_COUNT} features queued."
  else
    emit_event "orchestrate:warning" "No features were queued"
    log "Warning: No features were queued for this roadmap"
  fi
}

main() {
  log "Starting background worker for roadmap: ${NAME}"

  PHASE=$(get_state phase)
  log "Current phase: ${PHASE}"

  case "${PHASE}" in
    init|planning)
      run_orchestration_phase || exit 1
      ;;
    orchestrating)
      log "Roadmap is already orchestrating (features have been queued)"
      ;;
    completed)
      log "Roadmap orchestration already completed"
      ;;
    failed|interrupted)
      log "Recovering from ${PHASE} state"
      update_state "phase" '"init"'
      run_orchestration_phase || exit 1
      ;;
    *)
      log "Unknown phase: ${PHASE}"
      run_orchestration_phase || exit 1
      ;;
  esac

  log "Background worker completed"
}

main
