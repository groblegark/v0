#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../packages/cli/lib/v0-common.sh"

# Default configuration
REFRESH_INTERVAL=5
FILTER_ARGS=()
OPERATION_NAME=""
MAX_ITERATIONS=""  # For testing: limit number of watch iterations
WATCH_ALL=""       # Set to 1 for system-wide watch mode

usage() {
  v0_help <<'EOF'
Usage: v0 watch [OPTIONS] [OPERATION]

Continuously watch v0 status output.

Arguments:
  OPERATION             Watch a specific operation by name

Options:
  --all                 Watch all running v0 projects on the system
  -n, --interval SECS   Refresh interval in seconds (default: 5)
  -o, --operation NAME  Watch a specific operation by name
  --fix                 Watch fix worker status only
  --chore               Watch chore worker status only
  --merge               Watch merge queue status only
  --max-iterations N    Exit after N iterations (for testing)
  -h, --help            Show this help message

Press Ctrl+C to exit.
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    --all)
      WATCH_ALL=1
      shift
      ;;
    -n|--interval)
      REFRESH_INTERVAL="$2"
      shift 2
      ;;
    -o|--operation)
      OPERATION_NAME="$2"
      shift 2
      ;;
    --fix|--chore|--merge)
      FILTER_ARGS+=("$1")
      shift
      ;;
    --max-iterations)
      MAX_ITERATIONS="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      # Treat bare argument as operation name
      if [[ -z "${OPERATION_NAME}" ]] && [[ ! "$1" =~ ^- ]]; then
        OPERATION_NAME="$1"
        shift
      else
        echo "Unknown option: $1" >&2
        usage
        exit 1
      fi
      ;;
  esac
done

# Validate interval is a positive number
if ! [[ "${REFRESH_INTERVAL}" =~ ^[0-9]+$ ]] || [[ "${REFRESH_INTERVAL}" -lt 1 ]]; then
  echo "Error: Interval must be a positive integer" >&2
  exit 1
fi

# System-wide watch mode
if [[ -n "${WATCH_ALL}" ]]; then
  V0_STATE_BASE="${XDG_STATE_HOME:-${HOME}/.local/state}/v0"

  # Force colors in subcommands when our stdout is a TTY
  # (subcommand stdout goes through sed pipe, so isn't a TTY itself)
  if [[ -t 1 ]]; then
    export V0_FORCE_COLOR=1
  fi

  # Discover running projects
  discover_running_projects() {
    for root_file in "${V0_STATE_BASE}"/*/.v0.root; do
      [[ ! -f "${root_file}" ]] && continue
      local project_dir
      project_dir=$(dirname "${root_file}")
      local project
      project=$(basename "${project_dir}")
      [[ "${project}" = "standalone" ]] && continue

      local v0_root
      v0_root=$(cat "${root_file}")
      [[ ! -d "${v0_root}" ]] && continue

      # Check for active tmux sessions (v0-${project}-*)
      if tmux list-sessions -F '#{session_name}' 2>/dev/null | v0_grep -q "^v0-${project}-"; then
        echo "${project}:${v0_root}"
        continue
      fi

      # Check for daemon PID files (mergeq, fix, chore)
      local build_dir="${v0_root}/.v0/build"
      for daemon_dir in mergeq fix chore; do
        local pid_file="${build_dir}/${daemon_dir}/.daemon.pid"
        if [[ -f "${pid_file}" ]]; then
          local pid
          pid=$(cat "${pid_file}")
          if [[ -n "${pid}" ]] && kill -0 "${pid}" 2>/dev/null; then
            echo "${project}:${v0_root}"
            break
          fi
        fi
      done
    done
  }

  # Get terminal width (copy of logic from show_header)
  get_terminal_width() {
    local width
    if [[ -n "${COLUMNS+set}" ]]; then
      width="${COLUMNS}"
      if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
        width=80
      fi
    else
      width=$( { stty size </dev/tty | awk '{print $2}'; } 2>/dev/null ) || width=""
      if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
        width=$( { tput cols </dev/tty; } 2>/dev/null ) || width=""
      fi
      if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
        width=$(tput cols 2>/dev/null) || width=""
      fi
      if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
        width=80
      fi
    fi
    echo "${width}"
  }

  # Show header with timestamp for system-wide watch
  show_all_header() {
    local now version width
    now=$(date '+%Y-%m-%d %H:%M:%S')
    version=$(cat "${SCRIPT_DIR}/../VERSION" 2>/dev/null || echo "unknown")
    width=$(get_terminal_width)
    echo -e "v0 ${C_DIM}${C_LAVENDER}${version}${C_RESET} | ${C_BOLD}System Watch${C_RESET} | ${C_CYAN}${now}${C_RESET} | ${C_DIM}Ctrl+C to exit${C_RESET}"
    local bar=""
    for ((i=0; i<width; i++)); do bar+="═"; done
    printf '%s\n' "${bar}"
  }

  trap 'echo; exit 0' INT TERM

  iteration=0
  while true; do
    [[ -t 1 ]] && clear
    show_all_header

    # Get running projects
    projects=$(discover_running_projects)

    if [[ -z "${projects}" ]]; then
      echo ""
      echo -e "${C_DIM}No running v0 projects found${C_RESET}"
      echo ""
      echo "Projects are registered when you run v0 commands (start, build, etc.)"
      echo "Start a project with: v0 start"
    else
      while IFS=':' read -r project v0_root; do
        [[ -z "${project}" ]] && continue
        echo ""
        echo -e "${C_BOLD}▶ ${project}${C_RESET} ${C_DIM}(${v0_root})${C_RESET}"
        echo ""
        # Run v0 status from the project directory
        (cd "${v0_root}" && "${SCRIPT_DIR}/v0-status" --no-hints --max-ops 5 2>/dev/null) | sed 's/^/  /' || true
      done <<< "${projects}"
    fi

    # Check iteration limit (for testing)
    ((iteration++)) || true
    if [[ -n "${MAX_ITERATIONS}" && "${iteration}" -ge "${MAX_ITERATIONS}" ]]; then
      break
    fi

    sleep "${REFRESH_INTERVAL}"
  done

  exit 0
fi

# Regular project-specific watch mode - requires config
v0_load_config

# Show header with timestamp
show_header() {
  local now version project_name width
  now=$(date '+%Y-%m-%d %H:%M:%S')
  version=$(cat "${SCRIPT_DIR}/../VERSION" 2>/dev/null || echo "unknown")
  project_name=$(basename "$(pwd)")
  # Get terminal width: try multiple methods for portability
  # 1. COLUMNS if explicitly set and valid → use it
  # 2. COLUMNS is explicitly set but invalid → fallback to 80
  # 3. COLUMNS is unset → try stty/tput, then fallback to 80
  if [[ -n "${COLUMNS+set}" ]]; then
    # COLUMNS is explicitly set - use it if valid, otherwise 80
    width="${COLUMNS}"
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      width=80
    fi
  else
    # COLUMNS is unset - try stty/tput fallback chain
    # Try stty first (most reliable with actual terminal)
    # Use subshell to suppress bash's input redirection errors
    width=$( { stty size </dev/tty | awk '{print $2}'; } 2>/dev/null ) || width=""
    # Validate stty result
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      # Try tput with /dev/tty
      width=$( { tput cols </dev/tty; } 2>/dev/null ) || width=""
    fi
    # Validate tput result
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      # Try tput without /dev/tty
      width=$(tput cols 2>/dev/null) || width=""
    fi
    # Final fallback
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      width=80
    fi
  fi
  echo -e "v0 (${C_DIM}${C_LAVENDER}${version}${C_RESET}) | Project: ${C_CYAN}${project_name}/${C_RESET} | Last refresh: ${C_CYAN}${now}${C_RESET} | Interval: ${C_CYAN}${REFRESH_INTERVAL}s${C_RESET} | ${C_DIM}Ctrl+C to exit${C_RESET}"
  # Use bash string replication for portability across macOS/Linux
  local bar=""
  for ((i=0; i<width; i++)); do bar+="─"; done
  printf '%s\n' "${bar}"
}

# Main watch loop
trap 'echo; exit 0' INT TERM

iteration=0
while true; do
  # Only clear screen if stdout is a terminal
  [[ -t 1 ]] && clear
  show_header
  if [[ -n "${OPERATION_NAME}" ]]; then
    "${SCRIPT_DIR}/v0-status" "${OPERATION_NAME}" --no-hints --max-ops "${V0_STATUS_LIMIT}" ${FILTER_ARGS[@]+"${FILTER_ARGS[@]}"} 2>&1 || true
  else
    "${SCRIPT_DIR}/v0-status" --no-hints --max-ops "${V0_STATUS_LIMIT}" ${FILTER_ARGS[@]+"${FILTER_ARGS[@]}"} 2>&1 || true
  fi

  # Check iteration limit (for testing)
  ((iteration++)) || true
  if [[ -n "${MAX_ITERATIONS}" && "${iteration}" -ge "${MAX_ITERATIONS}" ]]; then
    break
  fi

  sleep "${REFRESH_INTERVAL}"
done
