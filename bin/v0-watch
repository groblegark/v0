#!/usr/bin/env bash
# SPDX-License-Identifier: MIT
# Copyright (c) 2026 Alfred Jean LLC
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
source "${SCRIPT_DIR}/../packages/cli/lib/v0-common.sh"
v0_load_config

# Default configuration
REFRESH_INTERVAL=5
FILTER_ARGS=()
OPERATION_NAME=""
MAX_ITERATIONS=""  # For testing: limit number of watch iterations

usage() {
  v0_help <<'EOF'
Usage: v0 watch [OPTIONS] [OPERATION]

Continuously watch v0 status output.

Arguments:
  OPERATION             Watch a specific operation by name

Options:
  -n, --interval SECS   Refresh interval in seconds (default: 5)
  -o, --operation NAME  Watch a specific operation by name
  --fix                 Watch fix worker status only
  --chore               Watch chore worker status only
  --merge               Watch merge queue status only
  --max-iterations N    Exit after N iterations (for testing)
  -h, --help            Show this help message

Press Ctrl+C to exit.
EOF
}

# Parse arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -n|--interval)
      REFRESH_INTERVAL="$2"
      shift 2
      ;;
    -o|--operation)
      OPERATION_NAME="$2"
      shift 2
      ;;
    --fix|--chore|--merge)
      FILTER_ARGS+=("$1")
      shift
      ;;
    --max-iterations)
      MAX_ITERATIONS="$2"
      shift 2
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      # Treat bare argument as operation name
      if [[ -z "${OPERATION_NAME}" ]] && [[ ! "$1" =~ ^- ]]; then
        OPERATION_NAME="$1"
        shift
      else
        echo "Unknown option: $1" >&2
        usage
        exit 1
      fi
      ;;
  esac
done

# Validate interval is a positive number
if ! [[ "${REFRESH_INTERVAL}" =~ ^[0-9]+$ ]] || [[ "${REFRESH_INTERVAL}" -lt 1 ]]; then
  echo "Error: Interval must be a positive integer" >&2
  exit 1
fi

# Show header with timestamp
show_header() {
  local now version project_name width
  now=$(date '+%Y-%m-%d %H:%M:%S')
  version=$(cat "${SCRIPT_DIR}/../VERSION" 2>/dev/null || echo "unknown")
  project_name=$(basename "$(pwd)")
  # Get terminal width: try multiple methods for portability
  # 1. COLUMNS if explicitly set and valid → use it
  # 2. COLUMNS is explicitly set but invalid → fallback to 80
  # 3. COLUMNS is unset → try stty/tput, then fallback to 80
  if [[ -n "${COLUMNS+set}" ]]; then
    # COLUMNS is explicitly set - use it if valid, otherwise 80
    width="${COLUMNS}"
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      width=80
    fi
  else
    # COLUMNS is unset - try stty/tput fallback chain
    # Try stty first (most reliable with actual terminal)
    # Use subshell to suppress bash's input redirection errors
    width=$( { stty size </dev/tty | awk '{print $2}'; } 2>/dev/null ) || width=""
    # Validate stty result
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      # Try tput with /dev/tty
      width=$( { tput cols </dev/tty; } 2>/dev/null ) || width=""
    fi
    # Validate tput result
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      # Try tput without /dev/tty
      width=$(tput cols 2>/dev/null) || width=""
    fi
    # Final fallback
    if ! [[ "${width}" =~ ^[0-9]+$ ]] || [[ "${width}" -lt 1 ]]; then
      width=80
    fi
  fi
  echo -e "v0 (${C_DIM}${C_LAVENDER}${version}${C_RESET}) | Project: ${C_CYAN}${project_name}/${C_RESET} | Last refresh: ${C_CYAN}${now}${C_RESET} | Interval: ${C_CYAN}${REFRESH_INTERVAL}s${C_RESET} | ${C_DIM}Ctrl+C to exit${C_RESET}"
  # Use bash string replication for portability across macOS/Linux
  local bar=""
  for ((i=0; i<width; i++)); do bar+="─"; done
  printf '%s\n' "${bar}"
}

# Main watch loop
trap 'echo; exit 0' INT TERM

iteration=0
while true; do
  # Only clear screen if stdout is a terminal
  [[ -t 1 ]] && clear
  show_header
  if [[ -n "${OPERATION_NAME}" ]]; then
    "${SCRIPT_DIR}/v0-status" "${OPERATION_NAME}" --no-hints --max-ops "${V0_STATUS_LIMIT}" ${FILTER_ARGS[@]+"${FILTER_ARGS[@]}"} 2>&1 || true
  else
    "${SCRIPT_DIR}/v0-status" --no-hints --max-ops "${V0_STATUS_LIMIT}" ${FILTER_ARGS[@]+"${FILTER_ARGS[@]}"} 2>&1 || true
  fi

  # Check iteration limit (for testing)
  ((iteration++)) || true
  if [[ -n "${MAX_ITERATIONS}" && "${iteration}" -ge "${MAX_ITERATIONS}" ]]; then
    break
  fi

  sleep "${REFRESH_INTERVAL}"
done
